{
  "firstLayout": "",
  "gdVersion": {
    "build": 99,
    "major": 4,
    "minor": 0,
    "revision": 0
  },
  "properties": {
    "adaptGameResolutionAtRuntime": true,
    "antialiasingMode": "MSAA",
    "antialisingEnabledOnMobile": false,
    "folderProject": false,
    "orientation": "landscape",
    "packageName": "com.example.gamename",
    "pixelsRounding": false,
    "projectUuid": "427b1008-8fe6-4e45-893e-77d101cca660",
    "scaleMode": "linear",
    "sizeOnStartupMode": "adaptWidth",
    "templateSlug": "",
    "useExternalSourceFiles": false,
    "version": "1.0.0",
    "name": "3D Car Coin Hunt",
    "description": "A top-down 3D racing game with 360Â° controls where players chase coins that are spread in a city.",
    "author": "",
    "windowWidth": 1280,
    "windowHeight": 720,
    "latestCompilationDirectory": "",
    "maxFPS": 60,
    "minFPS": 20,
    "verticalSync": false,
    "platformSpecificAssets": {
      "android-icon-144": "android-icon-144.png",
      "android-icon-192": "android-icon-192.png",
      "android-icon-36": "android-icon-36.png",
      "android-icon-48": "android-icon-48.png",
      "android-icon-72": "android-icon-72.png",
      "android-icon-96": "android-icon-96.png",
      "android-windowSplashScreenAnimatedIcon": "android-windowSplashScreenAnimatedIcon.png",
      "desktop-icon-512": "desktop-icon-512.png",
      "ios-icon-100": "ios-icon-100.png",
      "ios-icon-1024": "ios-icon-1024.png",
      "ios-icon-114": "ios-icon-114.png",
      "ios-icon-120": "ios-icon-120.png",
      "ios-icon-144": "ios-icon-144.png",
      "ios-icon-152": "ios-icon-152.png",
      "ios-icon-167": "ios-icon-167.png",
      "ios-icon-180": "ios-icon-180.png",
      "ios-icon-20": "ios-icon-20.png",
      "ios-icon-29": "ios-icon-29.png",
      "ios-icon-40": "ios-icon-40.png",
      "ios-icon-50": "ios-icon-50.png",
      "ios-icon-57": "ios-icon-57.png",
      "ios-icon-58": "ios-icon-58.png",
      "ios-icon-60": "ios-icon-60.png",
      "ios-icon-72": "ios-icon-72.png",
      "ios-icon-76": "ios-icon-76.png",
      "ios-icon-80": "ios-icon-80.png",
      "ios-icon-87": "ios-icon-87.png",
      "liluo-thumbnail": "thumbnail.png"
    },
    "loadingScreen": {
      "backgroundColor": 0,
      "backgroundFadeInDuration": 0.2,
      "backgroundImageResourceName": "",
      "gdevelopLogoStyle": "light",
      "logoAndProgressFadeInDuration": 0.2,
      "logoAndProgressLogoFadeInDelay": 0.2,
      "minDuration": 1.5,
      "progressBarColor": 16777215,
      "progressBarHeight": 20,
      "progressBarMaxWidth": 200,
      "progressBarMinWidth": 40,
      "progressBarWidthPercent": 30,
      "showGDevelopSplash": true,
      "showProgressBar": true
    },
    "watermark": {
      "placement": "bottom-left",
      "showWatermark": true
    },
    "authorIds": [],
    "authorUsernames": [],
    "categories": [
      "racing",
      "leaderboard"
    ],
    "playableDevices": [
      "keyboard",
      "mobile"
    ],
    "extensionProperties": [],
    "platforms": [
      {
        "name": "GDevelop JS platform"
      }
    ],
    "currentPlatform": "GDevelop JS platform"
  },
  "resources": {
    "resources": [
      {
        "file": "assets/Chango-Regular.ttf",
        "kind": "font",
        "metadata": "",
        "name": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
        "userAdded": true,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/Open Font License/27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
          "name": "gdevelop-asset-store"
        }
      },
      {
        "file": "assets/Collision.wav",
        "kind": "audio",
        "metadata": "{\"extension\":\".wav\",\"jfxr\":{\"data\":\"{\\\"_version\\\":1,\\\"_name\\\":\\\"Jump 1\\\",\\\"_locked\\\":[],\\\"sampleRate\\\":44100,\\\"attack\\\":0,\\\"sustain\\\":0.07,\\\"sustainPunch\\\":20,\\\"decay\\\":0.14343251891524278,\\\"tremoloDepth\\\":0,\\\"tremoloFrequency\\\":10,\\\"frequency\\\":7700,\\\"frequencySweep\\\":-4600,\\\"frequencyDeltaSweep\\\":-3100,\\\"repeatFrequency\\\":0,\\\"frequencyJump1Onset\\\":33,\\\"frequencyJump1Amount\\\":0,\\\"frequencyJump2Onset\\\":66,\\\"frequencyJump2Amount\\\":0,\\\"harmonics\\\":0,\\\"harmonicsFalloff\\\":0.5,\\\"waveform\\\":\\\"brownnoise\\\",\\\"interpolateNoise\\\":false,\\\"vibratoDepth\\\":0,\\\"vibratoFrequency\\\":10,\\\"squareDuty\\\":50,\\\"squareDutySweep\\\":0,\\\"flangerOffset\\\":0,\\\"flangerOffsetSweep\\\":0,\\\"bitCrush\\\":16,\\\"bitCrushSweep\\\":0,\\\"lowPassCutoff\\\":22050,\\\"lowPassCutoffSweep\\\":0,\\\"highPassCutoff\\\":0,\\\"highPassCutoffSweep\\\":0,\\\"compression\\\":1.7000000000000002,\\\"normalization\\\":true,\\\"amplification\\\":100}\",\"name\":\"Collision\"}}",
        "name": "Collision",
        "preloadAsMusic": false,
        "preloadAsSound": true,
        "preloadInCache": false,
        "userAdded": false
      },
      {
        "file": "assets/CarEngine.mp3",
        "kind": "audio",
        "metadata": "",
        "name": "assets\\CarEngine.mp3",
        "preloadAsMusic": false,
        "preloadAsSound": true,
        "preloadInCache": false,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Line light joystick thumb.png",
        "kind": "image",
        "metadata": "",
        "name": "Line light joystick thumb.png",
        "smoothed": true,
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/Multitouch joysticks/6e451170154c7ae31c25495ad2d2ac48ba8c8d62e93e90bfcfe3c7e509c9ce66_Line light joystick thumb.png",
          "name": "Line light joystick thumb.png"
        }
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Line light joystick border UpDown.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\Line light joystick border UpDown.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Line light joystick border LeftRightt.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\Line light joystick border LeftRightt.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "file": "assets/CoinPickUP.wav",
        "kind": "audio",
        "metadata": "{\"extension\":\".wav\",\"jfxr\":{\"data\":\"{\\\"_version\\\":1,\\\"_name\\\":\\\"Jump 1\\\",\\\"_locked\\\":[],\\\"sampleRate\\\":44100,\\\"attack\\\":0,\\\"sustain\\\":0.02,\\\"sustainPunch\\\":70,\\\"decay\\\":0.1,\\\"tremoloDepth\\\":0,\\\"tremoloFrequency\\\":10,\\\"frequency\\\":700,\\\"frequencySweep\\\":0,\\\"frequencyDeltaSweep\\\":0,\\\"repeatFrequency\\\":0,\\\"frequencyJump1Onset\\\":25,\\\"frequencyJump1Amount\\\":25,\\\"frequencyJump2Onset\\\":66,\\\"frequencyJump2Amount\\\":0,\\\"harmonics\\\":0,\\\"harmonicsFalloff\\\":0.5,\\\"waveform\\\":\\\"whistle\\\",\\\"interpolateNoise\\\":true,\\\"vibratoDepth\\\":0,\\\"vibratoFrequency\\\":10,\\\"squareDuty\\\":70,\\\"squareDutySweep\\\":65,\\\"flangerOffset\\\":0,\\\"flangerOffsetSweep\\\":0,\\\"bitCrush\\\":16,\\\"bitCrushSweep\\\":0,\\\"lowPassCutoff\\\":22050,\\\"lowPassCutoffSweep\\\":0,\\\"highPassCutoff\\\":0,\\\"highPassCutoffSweep\\\":0,\\\"compression\\\":1,\\\"normalization\\\":true,\\\"amplification\\\":100}\",\"name\":\"CoinPickUP\"},\"localFilePath\":\"assets/CoinPickUP.wav\"}",
        "name": "CoinPickUP",
        "preloadAsMusic": false,
        "preloadAsSound": false,
        "preloadInCache": false,
        "userAdded": true
      },
      {
        "file": "assets/Large Building A.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Large Building A.glb",
        "userAdded": true
      },
      {
        "file": "assets/Sedan Sports.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Sedan Sports.glb",
        "userAdded": true
      },
      {
        "file": "assets/Coin.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Coin.glb",
        "userAdded": true
      },
      {
        "file": "assets/Suv Luxury5.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Suv Luxury5.glb",
        "userAdded": true
      },
      {
        "file": "assets/Large Building F2.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Large Building F2.glb",
        "userAdded": true
      },
      {
        "file": "assets/Van2.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Van2.glb",
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "thumbnail.png",
        "kind": "image",
        "metadata": "",
        "name": "thumbnail.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "desktop-icon-512.png",
        "kind": "image",
        "metadata": "",
        "name": "desktop-icon-512.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "android-icon-192.png",
        "kind": "image",
        "metadata": "",
        "name": "android-icon-192.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "android-icon-144.png",
        "kind": "image",
        "metadata": "",
        "name": "android-icon-144.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "android-icon-96.png",
        "kind": "image",
        "metadata": "",
        "name": "android-icon-96.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "android-icon-72.png",
        "kind": "image",
        "metadata": "",
        "name": "android-icon-72.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "android-icon-48.png",
        "kind": "image",
        "metadata": "",
        "name": "android-icon-48.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "android-icon-36.png",
        "kind": "image",
        "metadata": "",
        "name": "android-icon-36.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "android-windowSplashScreenAnimatedIcon.png",
        "kind": "image",
        "metadata": "",
        "name": "android-windowSplashScreenAnimatedIcon.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-1024.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-1024.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-180.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-180.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-167.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-167.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-152.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-152.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-144.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-144.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-120.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-120.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-114.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-114.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-100.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-100.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-87.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-87.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-80.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-80.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-76.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-76.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-72.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-72.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-60.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-60.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-58.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-58.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-57.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-57.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-50.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-50.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-40.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-40.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-29.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-29.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "ios-icon-20.png",
        "kind": "image",
        "metadata": "",
        "name": "ios-icon-20.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Grey Button_Idle.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\Grey Button_Idle.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Yellow Button_Hovered.png",
        "kind": "image",
        "metadata": "",
        "name": "Yellow Button_Hovered.png",
        "smoothed": true,
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/Menu buttons/c1e14acb64b9963341656c997853154dc4c86cd1c46fb12bfbe012d99712ef61_Yellow Button_Hovered.png",
          "name": "Yellow Button_Hovered.png"
        }
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Yellow Button_Idle.png",
        "kind": "image",
        "metadata": "",
        "name": "Yellow Button_Idle.png",
        "smoothed": true,
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/Menu buttons/1cacfd123a1eb708837337c27982f6871f5127c5890dbf0775e0f411958fcbf1_Yellow Button_Idle.png",
          "name": "Yellow Button_Idle.png"
        }
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Yellow Button_Pressed.png",
        "kind": "image",
        "metadata": "",
        "name": "Yellow Button_Pressed.png",
        "smoothed": true,
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/Menu buttons/928c3ea4db1da835c9f8cc5b7089a47228350209d2ff489e1484c31e5ce41b3d_Yellow Button_Pressed.png",
          "name": "Yellow Button_Pressed.png"
        }
      },
      {
        "file": "assets/Road Straight.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Road Straight.glb",
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/3D City Kit (Roads)/Ground/01e0d2aa154aaca671e074c6fb5f92e37a75cf9606a88e889a0a2b0934e64122_Road Straight.glb",
          "name": "Road Straight.glb"
        }
      },
      {
        "file": "assets/Road Crossroad Path.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Road Crossroad Path.glb",
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/3D City Kit (Roads)/Ground/002f076f02776d316382227980bfd080c3c30c663c7846f6f4207a006735ae7c_Road Crossroad Path.glb",
          "name": "Road Crossroad Path.glb"
        }
      },
      {
        "file": "assets/Road Intersection Path.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Road Intersection Path.glb",
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/3D City Kit (Roads)/Ground/b9771937f69cff0ec5a74cf13ded2017b02b25294684c87bbbf5ca44519f2a51_Road Intersection Path.glb",
          "name": "Road Intersection Path.glb"
        }
      },
      {
        "file": "assets/Road Bend.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Road Bend.glb",
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/3D City Kit (Roads)/Ground/12e5d612ecde68cdda96d3e48b7c7de88221b35721c4af03607eecbf691d9f99_Road Bend.glb",
          "name": "Road Bend.glb"
        }
      },
      {
        "file": "assets/Common Tree 1.glb",
        "kind": "model3D",
        "metadata": "",
        "name": "Common Tree 1.glb",
        "userAdded": false,
        "origin": {
          "identifier": "https://asset-resources.gdevelop.io/public-resources/3D Rocks and Trees/Plant/7c4f3d2324ecd1f8910652478dd7bcb1ac714b260c66a562318c3f72c37bb404_Common Tree 1.glb",
          "name": "Common Tree 1.glb"
        }
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Grass.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\Grass.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Arrow.png",
        "kind": "image",
        "metadata": "{\"extension\":\".png\",\"pskl\":{}}",
        "name": "Arrow.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "Cross.png",
        "kind": "image",
        "metadata": "",
        "name": "Cross.png",
        "smoothed": true,
        "userAdded": false
      },
      {
        "alwaysLoaded": false,
        "file": "assets/Particle.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\Particle.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/NewSprite.png",
        "kind": "image",
        "metadata": "{\"extension\":\".png\"}",
        "name": "NewSprite",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/NewSprite2.png",
        "kind": "image",
        "metadata": "{\"extension\":\".png\"}",
        "name": "NewSprite2",
        "smoothed": true,
        "userAdded": true
      }
    ],
    "resourceFolders": []
  },
  "objects": [],
  "objectsFolderStructure": {
    "folderName": "__ROOT"
  },
  "objectsGroups": [],
  "variables": [
    {
      "folded": true,
      "name": "PlayerName",
      "type": "string",
      "value": ""
    },
    {
      "folded": true,
      "name": "Score",
      "type": "number",
      "value": 0
    }
  ],
  "layouts": [
    {
      "b": 216,
      "disableInputWhenNotFocused": true,
      "mangledName": "Game",
      "name": "Game",
      "r": 135,
      "standardSortMethod": true,
      "stopSoundsOnStartup": true,
      "title": "",
      "v": 179,
      "uiSettings": {
        "grid": false,
        "gridType": "rectangular",
        "gridWidth": 128,
        "gridHeight": 128,
        "gridOffsetX": 0,
        "gridOffsetY": 0,
        "gridColor": 10401023,
        "gridAlpha": 0.8,
        "snap": false,
        "zoomFactor": 0.546875000000018,
        "windowMask": false
      },
      "objectsGroups": [
        {
          "name": "Hazards",
          "objects": [
            {
              "name": "SuvLuxury"
            },
            {
              "name": "LargeBuildingA"
            },
            {
              "name": "LargeBuildingF"
            },
            {
              "name": "Van"
            }
          ]
        },
        {
          "name": "Road",
          "objects": [
            {
              "name": "RoadStraight"
            },
            {
              "name": "RoadCrossroadPath"
            },
            {
              "name": "RoadIntersectionPath"
            },
            {
              "name": "RoadBend"
            }
          ]
        }
      ],
      "variables": [
        {
          "folded": true,
          "name": "CameraAngle",
          "type": "number",
          "value": 0
        },
        {
          "folded": true,
          "name": "GameState",
          "type": "string",
          "value": "Playing"
        },
        {
          "folded": true,
          "name": "HighScore",
          "type": "number",
          "value": 0
        },
        {
          "name": "RunTime",
          "type": "number",
          "value": 0
        },
        {
          "folded": true,
          "name": "RisingPitch",
          "type": "number",
          "value": 0.9
        },
        {
          "folded": true,
          "name": "IsGamePaused",
          "type": "boolean",
          "value": false
        }
      ],
      "instances": [
        {
          "angle": 0,
          "customSize": false,
          "height": 46,
          "layer": "UI",
          "name": "BestTimeText",
          "persistentUuid": "30596d44-7cf8-4fee-8fdd-c76c86c9e777",
          "width": 187,
          "x": 5,
          "y": 50,
          "zOrder": 23,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "TimeText",
          "persistentUuid": "cec96115-b593-411f-93ad-8ed85b3ea2eb",
          "width": 0,
          "x": 5,
          "y": 0,
          "zOrder": 24,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 32,
          "height": 160,
          "layer": "MobileControls",
          "name": "SteeringJoystick",
          "persistentUuid": "e7a38e33-5747-430c-a64d-48abea077533",
          "width": 160,
          "x": 112,
          "y": 592,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 32,
          "height": 160,
          "layer": "MobileControls",
          "name": "PedalJoystick",
          "persistentUuid": "9ba6ad16-9ad5-46b5-b696-e0d27e639c61",
          "width": 160,
          "x": 1168,
          "y": 592,
          "zOrder": 26,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 0,
          "height": 44,
          "layer": "UI",
          "name": "TutorialText",
          "persistentUuid": "10449ac5-6445-4470-a25a-84dbe88687ba",
          "width": 604,
          "x": 4,
          "y": 688,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "RemainingText",
          "persistentUuid": "2b76bb1d-a62d-49db-ba85-d80a0aeb0572",
          "width": 0,
          "x": 5,
          "y": 110,
          "zOrder": 41,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Arrow",
          "persistentUuid": "bc0dd56c-75c6-4ec9-b4d9-e392704ada45",
          "width": 0,
          "x": 1332,
          "y": -58,
          "z": 10,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        }
      ],
      "objects": [
        {
          "assetStoreId": "",
          "name": "Dust",
          "type": "ParticleEmitter3D::ParticleEmitter3D",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {
            "StartColor": "255;255;255",
            "EndColor": "177;177;177",
            "Blending": "Normal",
            "Flow": 20,
            "Duration": 123456,
            "StartSizeMin": 12,
            "StartSizeMax": 12,
            "EndScale": 5,
            "StartSpeedMin": 30,
            "StartSpeedMax": 50,
            "GravityTop": "Z+",
            "Gravity": -100,
            "EndOpacity": 0,
            "StartOpacity": 220,
            "SpayConeAngle": 45,
            "Z": 9,
            "RotationX": 0,
            "LifespanMin": 0.5,
            "LifespanMax": 1,
            "RotationY": -22.5
          },
          "childrenContent": {
            "Particle": {
              "adaptCollisionMaskAutomatically": true,
              "updateIfNotVisible": false,
              "animations": [
                {
                  "name": "Particle",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "metadata": "{\"pskl\":{}}",
                      "timeBetweenFrames": 0.08,
                      "sprites": [
                        {
                          "hasCustomCollisionMask": true,
                          "image": "assets\\Particle.png",
                          "points": [],
                          "originPoint": {
                            "name": "origine",
                            "x": 0,
                            "y": 0
                          },
                          "centerPoint": {
                            "automatic": true,
                            "name": "centre",
                            "x": 0,
                            "y": 0
                          },
                          "customCollisionMask": [
                            [
                              {
                                "x": 0,
                                "y": 0
                              },
                              {
                                "x": 32,
                                "y": 0
                              },
                              {
                                "x": 32,
                                "y": 32
                              },
                              {
                                "x": 0,
                                "y": 32
                              }
                            ]
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        },
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "BestTimeText",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "string": "Best: 0",
          "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
          "textAlignment": "left",
          "characterSize": 25,
          "color": {
            "b": 255,
            "g": 255,
            "r": 255
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "Best: 0",
            "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
            "textAlignment": "left",
            "characterSize": 25,
            "color": "255;255;255"
          }
        },
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "RemainingText",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "string": "Remaining: 0",
          "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
          "textAlignment": "left",
          "characterSize": 25,
          "color": {
            "b": 255,
            "g": 255,
            "r": 255
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "Remaining: 0",
            "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
            "textAlignment": "left",
            "characterSize": 25,
            "color": "255;255;255"
          }
        },
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "TimeText",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "string": "Time:",
          "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
          "textAlignment": "left",
          "characterSize": 40,
          "color": {
            "b": 255,
            "g": 255,
            "r": 255
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "Time:",
            "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
            "textAlignment": "left",
            "characterSize": 40,
            "color": "255;255;255"
          }
        },
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "TutorialText",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "string": "Arrow keys to drive. Collect all coins.",
          "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
          "textAlignment": "left",
          "characterSize": 20,
          "color": {
            "b": 255,
            "g": 255,
            "r": 255
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "Arrow keys to drive. Collect all coins.",
            "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
            "textAlignment": "left",
            "characterSize": 20,
            "color": "255;255;255"
          }
        },
        {
          "assetStoreId": "112c69f62e03fa6df7716cc6b8f174c17857fbf71c8d3fffd16fa8fdbfa49bf1",
          "name": "SteeringJoystick",
          "type": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {
            "DeadZoneRadius": 0.2
          },
          "childrenContent": {
            "Border": {
              "adaptCollisionMaskAutomatically": false,
              "updateIfNotVisible": false,
              "animations": [
                {
                  "name": "Idle",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": [
                        {
                          "hasCustomCollisionMask": false,
                          "image": "assets\\Line light joystick border LeftRightt.png",
                          "points": [],
                          "originPoint": {
                            "name": "origine",
                            "x": 0,
                            "y": 0
                          },
                          "centerPoint": {
                            "automatic": true,
                            "name": "centre",
                            "x": 0,
                            "y": 0
                          },
                          "customCollisionMask": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "Thumb": {
              "adaptCollisionMaskAutomatically": false,
              "updateIfNotVisible": false,
              "animations": [
                {
                  "name": "Idle",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": [
                        {
                          "hasCustomCollisionMask": false,
                          "image": "Line light joystick thumb.png",
                          "points": [],
                          "originPoint": {
                            "name": "origine",
                            "x": 0,
                            "y": 0
                          },
                          "centerPoint": {
                            "automatic": true,
                            "name": "centre",
                            "x": 0,
                            "y": 0
                          },
                          "customCollisionMask": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        },
        {
          "assetStoreId": "112c69f62e03fa6df7716cc6b8f174c17857fbf71c8d3fffd16fa8fdbfa49bf1",
          "name": "PedalJoystick",
          "type": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Anchor",
              "type": "AnchorBehavior::AnchorBehavior",
              "bottomEdgeAnchor": 0,
              "leftEdgeAnchor": 0,
              "relativeToOriginalWindowSize": true,
              "rightEdgeAnchor": 2,
              "topEdgeAnchor": 0,
              "useLegacyBottomAndRightAnchors": false
            }
          ],
          "content": {
            "DeadZoneRadius": 0.2
          },
          "childrenContent": {
            "Border": {
              "adaptCollisionMaskAutomatically": false,
              "updateIfNotVisible": false,
              "animations": [
                {
                  "name": "Idle",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": [
                        {
                          "hasCustomCollisionMask": false,
                          "image": "assets\\Line light joystick border UpDown.png",
                          "points": [],
                          "originPoint": {
                            "name": "origine",
                            "x": 0,
                            "y": 0
                          },
                          "centerPoint": {
                            "automatic": true,
                            "name": "centre",
                            "x": 0,
                            "y": 0
                          },
                          "customCollisionMask": []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "Thumb": {
              "adaptCollisionMaskAutomatically": false,
              "updateIfNotVisible": false,
              "animations": [
                {
                  "name": "Idle",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": [
                        {
                          "hasCustomCollisionMask": false,
                          "image": "Line light joystick thumb.png",
                          "points": [],
                          "originPoint": {
                            "name": "origine",
                            "x": 0,
                            "y": 0
                          },
                          "centerPoint": {
                            "automatic": true,
                            "name": "centre",
                            "x": 0,
                            "y": 0
                          },
                          "customCollisionMask": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        },
        {
          "assetStoreId": "cddab55130dbd5a0b36f763200e876fb514aa608e1b057a136ebdb5f80006e2c",
          "name": "Player",
          "type": "Scene3D::Model3DObject",
          "variables": [
            {
              "folded": true,
              "name": "Force",
              "type": "number",
              "value": 0
            }
          ],
          "effects": [],
          "behaviors": [
            {
              "name": "Physics2",
              "type": "Physics2::Physics2Behavior",
              "bodyType": "Dynamic",
              "bullet": false,
              "fixedRotation": false,
              "canSleep": true,
              "shape": "Box",
              "shapeDimensionA": 0,
              "shapeDimensionB": 0,
              "shapeOffsetX": 0,
              "shapeOffsetY": 0,
              "polygonOrigin": "Center",
              "vertices": [],
              "density": 1,
              "friction": 2,
              "restitution": 1.5,
              "linearDamping": 4,
              "angularDamping": 20,
              "gravityScale": 0,
              "layers": 1,
              "masks": 1
            }
          ],
          "content": {
            "centerLocation": "ObjectCenter",
            "depth": 74,
            "height": 74,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Sedan Sports.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": -90,
            "width": 74,
            "animations": []
          }
        },
        {
          "assetStoreId": "541d82997e1d0e79b20a617cfcc249d1169d838db8512612894f18d64ea7374f",
          "name": "LargeBuildingF",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Physics2",
              "type": "Physics2::Physics2Behavior",
              "bodyType": "Static",
              "bullet": false,
              "fixedRotation": false,
              "canSleep": true,
              "shape": "Box",
              "shapeDimensionA": 0,
              "shapeDimensionB": 0,
              "shapeOffsetX": 0,
              "shapeOffsetY": 0,
              "polygonOrigin": "Center",
              "vertices": [],
              "density": 1,
              "friction": 0.3,
              "restitution": 0.1,
              "linearDamping": 0.1,
              "angularDamping": 0.1,
              "gravityScale": 1,
              "layers": 1,
              "masks": 1
            }
          ],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 245,
            "height": 245,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Large Building F2.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 245,
            "animations": []
          }
        },
        {
          "assetStoreId": "479c508ead309e45d684605c3539fd2b3a3a3a1ea8a277f102e8366873aad249",
          "name": "LargeBuildingA",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Physics2",
              "type": "Physics2::Physics2Behavior",
              "bodyType": "Static",
              "bullet": false,
              "fixedRotation": false,
              "canSleep": true,
              "shape": "Box",
              "shapeDimensionA": 0,
              "shapeDimensionB": 0,
              "shapeOffsetX": 0,
              "shapeOffsetY": 0,
              "polygonOrigin": "Center",
              "vertices": [],
              "density": 1,
              "friction": 0.3,
              "restitution": 0.1,
              "linearDamping": 0.1,
              "angularDamping": 0.1,
              "gravityScale": 1,
              "layers": 1,
              "masks": 1
            }
          ],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 245,
            "height": 245,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Large Building A.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 245,
            "animations": []
          }
        },
        {
          "assetStoreId": "fcb1a484380a00837bfc40406681f434dd57cce8bdf94694b237fc809bf7b4fb",
          "name": "SuvLuxury",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Physics2",
              "type": "Physics2::Physics2Behavior",
              "bodyType": "Dynamic",
              "bullet": false,
              "fixedRotation": false,
              "canSleep": true,
              "shape": "Box",
              "shapeDimensionA": 0,
              "shapeDimensionB": 0,
              "shapeOffsetX": 0,
              "shapeOffsetY": 0,
              "polygonOrigin": "Center",
              "vertices": [],
              "density": 1,
              "friction": 0.5,
              "restitution": 0.2,
              "linearDamping": 7,
              "angularDamping": 4,
              "gravityScale": 0,
              "layers": 1,
              "masks": 1
            }
          ],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 84,
            "height": 84,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Suv Luxury5.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": -90,
            "width": 84,
            "animations": []
          }
        },
        {
          "assetStoreId": "0d7e7a700fe654df077830ff50844449cdaddbb46dbe23de65f970569e6a983b",
          "name": "Van",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Physics2",
              "type": "Physics2::Physics2Behavior",
              "bodyType": "Dynamic",
              "bullet": false,
              "fixedRotation": false,
              "canSleep": true,
              "shape": "Box",
              "shapeDimensionA": 0,
              "shapeDimensionB": 0,
              "shapeOffsetX": 0,
              "shapeOffsetY": 0,
              "polygonOrigin": "Center",
              "vertices": [],
              "density": 1,
              "friction": 0.5,
              "restitution": 0.2,
              "linearDamping": 7,
              "angularDamping": 4,
              "gravityScale": 0,
              "layers": 1,
              "masks": 1
            }
          ],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 79,
            "height": 79,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Van2.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": -90,
            "width": 79,
            "animations": []
          }
        },
        {
          "assetStoreId": "b8200f0619b25c76e3d392f1d0d16d7547bf1c96097bc23af81b68cf11e57677",
          "name": "Coin",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "InOnScreen",
              "type": "IsOnScreen::InOnScreen"
            }
          ],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 31,
            "height": 31,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Coin.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 0,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 31,
            "animations": []
          }
        },
        {
          "assetStoreId": "",
          "name": "Arrow",
          "type": "Scene3D::Cube3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {
            "width": 32,
            "height": 32,
            "depth": 1,
            "enableTextureTransparency": true,
            "facesOrientation": "Y",
            "frontFaceResourceName": "Arrow.png",
            "backFaceResourceName": "",
            "backFaceUpThroughWhichAxisRotation": "X",
            "leftFaceResourceName": "",
            "rightFaceResourceName": "",
            "topFaceResourceName": "",
            "bottomFaceResourceName": "",
            "frontFaceVisible": true,
            "backFaceVisible": false,
            "leftFaceVisible": false,
            "rightFaceVisible": false,
            "topFaceVisible": false,
            "bottomFaceVisible": false,
            "frontFaceResourceRepeat": false,
            "backFaceResourceRepeat": false,
            "leftFaceResourceRepeat": false,
            "rightFaceResourceRepeat": false,
            "topFaceResourceRepeat": false,
            "bottomFaceResourceRepeat": false,
            "materialType": "Basic"
          }
        },
        {
          "assetStoreId": "bbdd1d6c7d452e1847310eb327cddabe057cb893886f3a7a1af1c38e353eac92",
          "name": "RoadStraight",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "ObjectStack",
              "type": "ObjectStack::ObjectStack"
            },
            {
              "name": "RoadTile",
              "type": "TiledRoad::RoadTile",
              "ShapeName": "Line",
              "RotationOffset": 0,
              "Shape": 2.0247e-320
            }
          ],
          "content": {
            "centerLocation": "ObjectCenter",
            "depth": 384,
            "height": 384,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Road Straight.glb",
            "originLocation": "TopLeft",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 384,
            "animations": []
          }
        },
        {
          "assetStoreId": "ae09642f549122b398405ffda9bd787c20f0fdfcb555a4535c710a3f218c8130",
          "name": "RoadCrossroadPath",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "ObjectStack",
              "type": "ObjectStack::ObjectStack"
            },
            {
              "name": "RoadTile",
              "type": "TiledRoad::RoadTile",
              "ShapeName": "Crossroads",
              "RotationOffset": 0,
              "Shape": 2.0247e-320
            }
          ],
          "content": {
            "centerLocation": "ObjectCenter",
            "depth": 384,
            "height": 384,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Road Crossroad Path.glb",
            "originLocation": "TopLeft",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 384,
            "animations": []
          }
        },
        {
          "assetStoreId": "fad6af3a34db69705540270898681716e47359bbb1b474b27104f823098ef0aa",
          "name": "RoadIntersectionPath",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "ObjectStack",
              "type": "ObjectStack::ObjectStack"
            },
            {
              "name": "RoadTile",
              "type": "TiledRoad::RoadTile",
              "ShapeName": "T-Shaped crossroads",
              "RotationOffset": 180,
              "Shape": 2.0247e-320
            }
          ],
          "content": {
            "centerLocation": "ObjectCenter",
            "depth": 384,
            "height": 384,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Road Intersection Path.glb",
            "originLocation": "TopLeft",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 384,
            "animations": []
          }
        },
        {
          "assetStoreId": "79a334f5403b6c2daa0625e37c715ede02c9283c06721ee917767f36efff8570",
          "name": "RoadBend",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "ObjectStack",
              "type": "ObjectStack::ObjectStack"
            },
            {
              "name": "RoadTile",
              "type": "TiledRoad::RoadTile",
              "ShapeName": "L-Shaped bend",
              "RotationOffset": 0,
              "Shape": 2.0247e-320
            }
          ],
          "content": {
            "centerLocation": "ObjectCenter",
            "depth": 384,
            "height": 384,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Road Bend.glb",
            "originLocation": "TopLeft",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 384,
            "animations": []
          }
        },
        {
          "assetStoreId": "16fac9714ba0a9eb3c83984910c70b11affca1b4e6a8bed49c22af1d30f957da",
          "name": "CommonTree1",
          "type": "Scene3D::Model3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 250,
            "height": 250,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Common Tree 1.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 250,
            "animations": []
          }
        },
        {
          "assetStoreId": "",
          "name": "Grass",
          "type": "Scene3D::Cube3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {
            "width": 100,
            "height": 100,
            "depth": 0,
            "enableTextureTransparency": false,
            "facesOrientation": "Y",
            "frontFaceResourceName": "assets\\Grass.png",
            "backFaceResourceName": "",
            "backFaceUpThroughWhichAxisRotation": "X",
            "leftFaceResourceName": "",
            "rightFaceResourceName": "",
            "topFaceResourceName": "",
            "bottomFaceResourceName": "",
            "frontFaceVisible": true,
            "backFaceVisible": false,
            "leftFaceVisible": false,
            "rightFaceVisible": false,
            "topFaceVisible": false,
            "bottomFaceVisible": false,
            "frontFaceResourceRepeat": false,
            "backFaceResourceRepeat": false,
            "leftFaceResourceRepeat": false,
            "rightFaceResourceRepeat": false,
            "topFaceResourceRepeat": false,
            "bottomFaceResourceRepeat": false,
            "materialType": "Basic"
          }
        },
        {
          "assetStoreId": "",
          "name": "CameraTarget",
          "type": "Scene3D::Cube3DObject",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {
            "width": 30,
            "height": 30,
            "depth": 74,
            "enableTextureTransparency": false,
            "facesOrientation": "Y",
            "frontFaceResourceName": "Cross.png",
            "backFaceResourceName": "",
            "backFaceUpThroughWhichAxisRotation": "X",
            "leftFaceResourceName": "",
            "rightFaceResourceName": "",
            "topFaceResourceName": "",
            "bottomFaceResourceName": "",
            "frontFaceVisible": true,
            "backFaceVisible": false,
            "leftFaceVisible": false,
            "rightFaceVisible": false,
            "topFaceVisible": false,
            "bottomFaceVisible": false,
            "frontFaceResourceRepeat": false,
            "backFaceResourceRepeat": false,
            "leftFaceResourceRepeat": false,
            "rightFaceResourceRepeat": false,
            "topFaceResourceRepeat": false,
            "bottomFaceResourceRepeat": false,
            "materialType": "Basic"
          }
        },
        {
          "assetStoreId": "",
          "name": "CoinPickUp",
          "type": "ParticleEmitter3D::ParticleEmitter3D",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {
            "StartColor": "255;230;145",
            "EndOpacity": 255,
            "StartOpacity": 128,
            "EndScale": 0,
            "SpayConeAngle": 180,
            "RotationY": 90,
            "StartSpeedMin": 400,
            "StartSpeedMax": 600,
            "LifespanMax": 0.5,
            "LifespanMin": 0.25,
            "Duration": 0.0625,
            "Flow": 200,
            "StartSizeMin": 15,
            "EndColor": "255;230;142",
            "Blending": "Normal",
            "StartSizeMax": 30
          },
          "childrenContent": {
            "Particle": {
              "adaptCollisionMaskAutomatically": true,
              "updateIfNotVisible": false,
              "animations": [
                {
                  "name": "Image",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": [
                        {
                          "hasCustomCollisionMask": true,
                          "image": "assets\\Particle.png",
                          "points": [],
                          "originPoint": {
                            "name": "origine",
                            "x": 0,
                            "y": 0
                          },
                          "centerPoint": {
                            "automatic": true,
                            "name": "centre",
                            "x": 0,
                            "y": 0
                          },
                          "customCollisionMask": [
                            [
                              {
                                "x": 0,
                                "y": 0
                              },
                              {
                                "x": 32,
                                "y": 0
                              },
                              {
                                "x": 32,
                                "y": 32
                              },
                              {
                                "x": 0,
                                "y": 32
                              }
                            ]
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        },
        {
          "adaptCollisionMaskAutomatically": true,
          "assetStoreId": "",
          "name": "RoadGrid",
          "type": "Sprite",
          "updateIfNotVisible": false,
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "ObjectRectangularGrid",
              "type": "ObjectRectangularGrid::ObjectRectangularGrid",
              "CellWidth": 384,
              "CellHeight": 384,
              "OffsetX": 0,
              "OffsetY": 0
            }
          ],
          "animations": [
            {
              "name": "NewSprite",
              "useMultipleDirections": false,
              "directions": [
                {
                  "looping": false,
                  "metadata": "{\"pskl\":{}}",
                  "timeBetweenFrames": 0.08,
                  "sprites": [
                    {
                      "hasCustomCollisionMask": true,
                      "image": "NewSprite2",
                      "points": [],
                      "originPoint": {
                        "name": "origine",
                        "x": 0,
                        "y": 0
                      },
                      "centerPoint": {
                        "automatic": true,
                        "name": "centre",
                        "x": 0,
                        "y": 0
                      },
                      "customCollisionMask": [
                        [
                          {
                            "x": 0,
                            "y": 0
                          },
                          {
                            "x": 64,
                            "y": 0
                          },
                          {
                            "x": 64,
                            "y": 64
                          },
                          {
                            "x": 0,
                            "y": 64
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "assetStoreId": "fcb1a484380a00837bfc40406681f434dd57cce8bdf94694b237fc809bf7b4fb",
          "name": "MovingSuvLuxury",
          "type": "Scene3D::Model3DObject",
          "variables": [
            {
              "folded": true,
              "name": "RoadTargetEdge",
              "type": "number",
              "value": 0
            }
          ],
          "effects": [],
          "behaviors": [
            {
              "name": "Physics2",
              "type": "Physics2::Physics2Behavior",
              "bodyType": "Kinematic",
              "bullet": false,
              "fixedRotation": false,
              "canSleep": true,
              "shape": "Box",
              "shapeDimensionA": 0,
              "shapeDimensionB": 0,
              "shapeOffsetX": 0,
              "shapeOffsetY": 0,
              "polygonOrigin": "Center",
              "vertices": [],
              "density": 1,
              "friction": 0.5,
              "restitution": 0.2,
              "linearDamping": 7,
              "angularDamping": 4,
              "gravityScale": 0,
              "layers": 1,
              "masks": 1
            },
            {
              "name": "SpeedPathMovement",
              "type": "CurvedMovement::SpeedPathMovement",
              "Rotation": true,
              "RotationOffset": 0,
              "Speed": 0,
              "PathOriginX": 2.0247e-320,
              "PathOriginY": 2.0247e-320,
              "PathName": "",
              "TargetedSpeed": 0,
              "Acceleration": 0,
              "DrawingElementIndex": 0,
              "X": 2.0247e-320,
              "Y": 2.0247e-320,
              "PathAngle": 2.0247e-320,
              "PathScale": 2.0247e-320,
              "RepetitionCount": 2.0247e-320,
              "ShouldLoop": false,
              "DrawingPathOriginX": 2.0247e-320,
              "DrawingPathOriginY": 2.0247e-320,
              "DebugLineStrokeWidth": 2.0247e-320,
              "PreviousSpeed": 2.0247e-320,
              "CurrentLength": 2.0247e-320,
              "IsLookingBack": false,
              "Viewpoint": "Top-Down"
            },
            {
              "name": "TrafficCar",
              "type": "TrafficCar::TrafficCar",
              "SpeedMax": 200,
              "RoadTargetEdge": 100.00000000005824,
              "SpeedPathMovement": "SpeedPathMovement",
              "Deceleration": 400,
              "Acceleration": 100
            }
          ],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 84,
            "height": 84,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Suv Luxury5.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 90,
            "rotationY": 0,
            "rotationZ": -90,
            "width": 84,
            "animations": []
          }
        },
        {
          "assetStoreId": "",
          "name": "NewText",
          "type": "Text3D::Text3D",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Sticker",
              "type": "Sticker::Sticker",
              "OnlyFollowPosition": true,
              "IsDestroyedWithParent": false
            }
          ],
          "content": {},
          "childrenContent": {
            "Text": {
              "bold": false,
              "italic": false,
              "smoothed": true,
              "underlined": false,
              "string": "Text",
              "font": "",
              "textAlignment": "left",
              "characterSize": 80,
              "color": {
                "b": 255,
                "g": 255,
                "r": 255
              },
              "content": {
                "bold": false,
                "isOutlineEnabled": true,
                "isShadowEnabled": false,
                "italic": false,
                "outlineColor": "0;0;0",
                "outlineThickness": 4,
                "shadowAngle": 90,
                "shadowBlurRadius": 2,
                "shadowColor": "0;0;0",
                "shadowDistance": 4,
                "shadowOpacity": 127,
                "smoothed": true,
                "underlined": false,
                "text": "Text",
                "font": "",
                "textAlignment": "left",
                "characterSize": 80,
                "color": "255;255;255"
              }
            }
          }
        }
      ],
      "objectsFolderStructure": {
        "folderName": "__ROOT",
        "children": [
          {
            "folderName": "Backgrounds",
            "children": [
              {
                "objectName": "Grass"
              },
              {
                "objectName": "CommonTree1"
              },
              {
                "objectName": "RoadBend"
              },
              {
                "objectName": "RoadIntersectionPath"
              },
              {
                "objectName": "RoadCrossroadPath"
              },
              {
                "objectName": "RoadStraight"
              }
            ]
          },
          {
            "folderName": "Obstacles",
            "children": [
              {
                "objectName": "Van"
              },
              {
                "objectName": "SuvLuxury"
              },
              {
                "objectName": "MovingSuvLuxury"
              },
              {
                "objectName": "LargeBuildingA"
              },
              {
                "objectName": "LargeBuildingF"
              }
            ]
          },
          {
            "folderName": "UI",
            "children": [
              {
                "objectName": "Arrow"
              },
              {
                "objectName": "PedalJoystick"
              },
              {
                "objectName": "SteeringJoystick"
              },
              {
                "objectName": "TutorialText"
              },
              {
                "objectName": "TimeText"
              },
              {
                "objectName": "RemainingText"
              },
              {
                "objectName": "BestTimeText"
              }
            ]
          },
          {
            "folderName": "VFX",
            "children": [
              {
                "objectName": "Dust"
              },
              {
                "objectName": "CoinPickUp"
              }
            ]
          },
          {
            "objectName": "Player"
          },
          {
            "objectName": "Coin"
          },
          {
            "objectName": "CameraTarget"
          },
          {
            "objectName": "RoadGrid"
          },
          {
            "objectName": "NewText"
          }
        ]
      },
      "events": [
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Game Set Up and controls for mobile."
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "DepartScene"
              },
              "parameters": [
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "BuiltinExternalLayouts::CreateObjectsFromExternalLayout"
              },
              "parameters": [
                "",
                "\"Level1\"",
                "0",
                "0"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "DepartScene"
              },
              "parameters": [
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "CentreCamera"
              },
              "parameters": [
                "",
                "Player",
                "",
                "\"\"",
                ""
              ]
            },
            {
              "type": {
                "value": "LireFichierExp"
              },
              "parameters": [
                "\"HighScore\"",
                "\"HighScore\"",
                "",
                "HighScore"
              ]
            },
            {
              "type": {
                "value": "TextContainerCapability::TextContainerBehavior::SetValue"
              },
              "parameters": [
                "BestTimeText",
                "Text",
                "=",
                "\"Best: \" + TimeFormatter::SecondsToHHMMSS000(Variable(HighScore))"
              ]
            },
            {
              "type": {
                "value": "TextContainerCapability::TextContainerBehavior::SetValue"
              },
              "parameters": [
                "RemainingText",
                "Text",
                "=",
                "\"Remaining: \" + ToString(SceneInstancesCount(Coin))"
              ]
            },
            {
              "type": {
                "value": "PlaySoundCanal"
              },
              "parameters": [
                "",
                "assets\\CarEngine.mp3",
                "0",
                "yes",
                "30",
                "1"
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "SystemInfo::IsMobile"
                  },
                  "parameters": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Delete"
                  },
                  "parameters": [
                    "SteeringJoystick",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Delete"
                  },
                  "parameters": [
                    "PedalJoystick",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SystemInfo::IsMobile"
                  },
                  "parameters": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Delete"
                  },
                  "parameters": [
                    "TutorialText",
                    ""
                  ]
                }
              ]
            }
          ]
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Traffic",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "DepartScene"
                  },
                  "parameters": [
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Create"
                  },
                  "parameters": [
                    "",
                    "RoadGrid",
                    "0",
                    "0",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Cache"
                  },
                  "parameters": [
                    "RoadGrid"
                  ]
                },
                {
                  "type": {
                    "value": "ObjectRectangularGrid::ObjectRectangularGrid::AddFromPosition"
                  },
                  "parameters": [
                    "RoadGrid",
                    "ObjectRectangularGrid",
                    "Road",
                    ""
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::ForEach",
                  "object": "Road",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::CompareNumbers"
                      },
                      "parameters": [
                        "RandomFloat(1)",
                        "<",
                        "0.75"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "MovingSuvLuxury",
                        "Road.CenterX()",
                        "Road.CenterY()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ActivateBehavior"
                      },
                      "parameters": [
                        "MovingSuvLuxury",
                        "Physics2",
                        ""
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "name": "Debug",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "disabled": true,
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "DepartScene"
                      },
                      "parameters": [
                        ""
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::ForEach",
                      "object": "MovingSuvLuxury",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "Create"
                          },
                          "parameters": [
                            "",
                            "NewText",
                            "MovingSuvLuxury.X()",
                            "MovingSuvLuxury.Y()",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "Scene3D::Base3DBehavior::SetZ"
                          },
                          "parameters": [
                            "NewText",
                            "Object3D",
                            "=",
                            "60"
                          ]
                        },
                        {
                          "type": {
                            "value": "Sticker::Sticker::Stick"
                          },
                          "parameters": [
                            "NewText",
                            "Sticker",
                            "MovingSuvLuxury",
                            ""
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::ForEach",
                  "object": "MovingSuvLuxury",
                  "conditions": [
                    {
                      "type": {
                        "value": "Sticker::IsStuck"
                      },
                      "parameters": [
                        "",
                        "NewText",
                        "Sticker",
                        "MovingSuvLuxury",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                      },
                      "parameters": [
                        "NewText",
                        "Text",
                        "=",
                        "ToString(round(MovingSuvLuxury.TrafficCar::PropertyNextCarDistance()))"
                      ]
                    }
                  ]
                },
                {
                  "disabled": true,
                  "type": "BuiltinCommonInstructions::ForEach",
                  "object": "MovingSuvLuxury",
                  "conditions": [
                    {
                      "type": {
                        "value": "Sticker::IsStuck"
                      },
                      "parameters": [
                        "",
                        "NewText",
                        "Sticker",
                        "MovingSuvLuxury",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                      },
                      "parameters": [
                        "NewText",
                        "Text",
                        "=",
                        "ToString(round(MovingSuvLuxury.TrafficCar::PropertyRoadOriginEdge()))"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "MouseButtonReleased"
                      },
                      "parameters": [
                        "",
                        "Right"
                      ]
                    },
                    {
                      "type": {
                        "value": "SourisSurObjet"
                      },
                      "parameters": [
                        "Road",
                        "",
                        "",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Scene3D::Base3DBehavior::FlipZ"
                      },
                      "parameters": [
                        "MovingSuvLuxury",
                        "Object3D",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                      },
                      "parameters": [
                        "BestTimeText",
                        "Text",
                        "=",
                        "\"0\""
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ObjectStack::Contains"
                          },
                          "parameters": [
                            "",
                            "Road",
                            "ObjectStack",
                            "MovingSuvLuxury",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Scene3D::Base3DBehavior::FlipZ"
                          },
                          "parameters": [
                            "MovingSuvLuxury",
                            "Object3D",
                            "yes"
                          ]
                        },
                        {
                          "type": {
                            "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                          },
                          "parameters": [
                            "BestTimeText",
                            "Text",
                            "=",
                            "ToString(PickedInstancesCount(MovingSuvLuxury))"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "MouseButtonReleased"
                      },
                      "parameters": [
                        "",
                        "Left"
                      ]
                    },
                    {
                      "type": {
                        "value": "SourisSurObjet"
                      },
                      "parameters": [
                        "MovingSuvLuxury",
                        "",
                        "",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                      },
                      "parameters": [
                        "BestTimeText",
                        "Text",
                        "=",
                        "ToString(MovingSuvLuxury.TrafficCar::PropertyNextCarDistance())"
                      ]
                    },
                    {
                      "type": {
                        "value": "Scene3D::Base3DBehavior::FlipZ"
                      },
                      "parameters": [
                        "Road",
                        "Object3D",
                        "no"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ObjectStack::Contains"
                          },
                          "parameters": [
                            "",
                            "Road",
                            "ObjectStack",
                            "MovingSuvLuxury",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Scene3D::Base3DBehavior::FlipZ"
                          },
                          "parameters": [
                            "Road",
                            "Object3D",
                            "yes"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "KeyPressed"
                      },
                      "parameters": [
                        "",
                        "Space"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetBooleanVariable"
                      },
                      "parameters": [
                        "IsGamePaused",
                        "Toggle",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": []
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BooleanVariable"
                  },
                  "parameters": [
                    "IsGamePaused",
                    "False",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "TrafficCar::Move"
                  },
                  "parameters": [
                    "MovingSuvLuxury",
                    "MovingSuvLuxury",
                    "TrafficCar",
                    "SpeedPathMovement",
                    "RoadGrid",
                    "ObjectRectangularGrid",
                    "Road",
                    "RoadTile",
                    "ObjectStack",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": []
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "When the game is playing",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "StringVariable"
                  },
                  "parameters": [
                    "GameState",
                    "=",
                    "\"Playing\""
                  ]
                }
              ],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Start timer only when the SedanPlayer starts moving."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Physics2::LinearVelocityLength"
                      },
                      "parameters": [
                        "Player",
                        "Physics2",
                        ">",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "inverted": true,
                        "value": "CompareTimer"
                      },
                      "parameters": [
                        "",
                        "\"Time\"",
                        ">",
                        "0"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ResetTimer"
                      },
                      "parameters": [
                        "",
                        "\"Time\""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Display the timer."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                      },
                      "parameters": [
                        "TimeText",
                        "Text",
                        "=",
                        "\"Time: \" + TimeFormatter::SecondsToHHMMSS000(TimerElapsedTime(\"Time\"))"
                      ]
                    }
                  ]
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "SedanPlayer controls",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberObjectVariable"
                          },
                          "parameters": [
                            "Player",
                            "Force",
                            "=",
                            "0"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "KeyPressed"
                          },
                          "parameters": [
                            "",
                            "Down"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberObjectVariable"
                          },
                          "parameters": [
                            "Player",
                            "Force",
                            "=",
                            "-4"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "KeyPressed"
                          },
                          "parameters": [
                            "",
                            "Up"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberObjectVariable"
                          },
                          "parameters": [
                            "Player",
                            "Force",
                            "=",
                            "6"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::SpriteMultitouchJoystick::IsDirectionPushed4Way"
                          },
                          "parameters": [
                            "PedalJoystick",
                            "\"Down\"",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberObjectVariable"
                          },
                          "parameters": [
                            "Player",
                            "Force",
                            "=",
                            "-4 * PedalJoystick.StickForce()"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::SpriteMultitouchJoystick::IsDirectionPushed4Way"
                          },
                          "parameters": [
                            "PedalJoystick",
                            "\"Up\"",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberObjectVariable"
                          },
                          "parameters": [
                            "Player",
                            "Force",
                            "=",
                            "6 * PedalJoystick.StickForce()"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "Physics2::ApplyPolarForce"
                          },
                          "parameters": [
                            "Player",
                            "Physics2",
                            "Player.Angle()",
                            "Player.Force",
                            "Player.CenterX()",
                            "Player.CenterY()"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "When going backward, a car go back in its trail without direction change."
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "KeyPressed"
                          },
                          "parameters": [
                            "",
                            "Right"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Physics2::ApplyTorque"
                          },
                          "parameters": [
                            "Player",
                            "Physics2",
                            "0.002 * Player.Physics2::LinearVelocity() * sign(Player.Force)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "KeyPressed"
                          },
                          "parameters": [
                            "",
                            "Left"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Physics2::ApplyTorque"
                          },
                          "parameters": [
                            "Player",
                            "Physics2",
                            "-0.002 * Player.Physics2::LinearVelocity() * sign(Player.Force)"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::SpriteMultitouchJoystick::IsDirectionPushed4Way"
                          },
                          "parameters": [
                            "SteeringJoystick",
                            "\"Right\"",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Physics2::ApplyTorque"
                          },
                          "parameters": [
                            "Player",
                            "Physics2",
                            "0.002 * Player.Physics2::LinearVelocity() * sign(Player.Force) * SteeringJoystick.StickForce()"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::SpriteMultitouchJoystick::IsDirectionPushed4Way"
                          },
                          "parameters": [
                            "SteeringJoystick",
                            "\"Left\"",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Physics2::ApplyTorque"
                          },
                          "parameters": [
                            "Player",
                            "Physics2",
                            "-0.002 * Player.Physics2::LinearVelocity() * sign(Player.Force) * SteeringJoystick.StickForce()"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "If on/off road, increase/decrease linear damping."
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "Physics2::LinearDamping"
                          },
                          "parameters": [
                            "Player",
                            "Physics2",
                            "=",
                            "9"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "CollisionNP"
                          },
                          "parameters": [
                            "Player",
                            "Road",
                            "",
                            "",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Physics2::LinearDamping"
                          },
                          "parameters": [
                            "Player",
                            "Physics2",
                            "=",
                            "4"
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ]
            }
          ],
          "parameters": []
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Particles, car rev volume, and camera controls",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "DepartScene"
                  },
                  "parameters": [
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Create"
                  },
                  "parameters": [
                    "",
                    "CameraTarget",
                    "0",
                    "0",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Cache"
                  },
                  "parameters": [
                    "CameraTarget"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "CameraAngle",
                    "=",
                    "lerp(CameraAngle, Player.Angle(), TimeDelta() * 4)"
                  ]
                },
                {
                  "type": {
                    "value": "MettreAutour"
                  },
                  "parameters": [
                    "CameraTarget",
                    "Player",
                    "200",
                    "CameraAngle"
                  ]
                },
                {
                  "type": {
                    "value": "ThirdPersonCamera::LookFromDistanceAtObject3D"
                  },
                  "parameters": [
                    "",
                    "CameraTarget",
                    "Object3D",
                    "800 + 2000",
                    "CameraAngle + 90",
                    "80",
                    "",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Scene3D::SetCameraZ"
                  },
                  "parameters": [
                    "",
                    "+",
                    "0",
                    "",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "SetAngle"
                  },
                  "parameters": [
                    "Dust",
                    "=",
                    "Player.Angle() + 180"
                  ]
                },
                {
                  "type": {
                    "value": "MettreAutour"
                  },
                  "parameters": [
                    "Dust",
                    "Player",
                    "10",
                    "Player.Angle() - 180"
                  ]
                },
                {
                  "type": {
                    "value": "MettreXY"
                  },
                  "parameters": [
                    "Dust",
                    "=",
                    "Dust.X() + RandomFloatInRange(-6, 6)",
                    "=",
                    "Dust.Y() + RandomFloatInRange(-6, 6)"
                  ]
                },
                {
                  "type": {
                    "value": "ModPitchSoundChannel"
                  },
                  "parameters": [
                    "",
                    "0",
                    "=",
                    "min((Player.Physics2::LinearVelocity() / 300), 1)"
                  ]
                },
                {
                  "type": {
                    "value": "ModVolumeSoundCanal"
                  },
                  "parameters": [
                    "",
                    "0",
                    "=",
                    "min((Player.Physics2::LinearVelocity()) * 10, 25)"
                  ]
                }
              ]
            }
          ],
          "parameters": []
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Coins",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "Rotate"
                  },
                  "parameters": [
                    "Coin",
                    "50",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Coins indicator"
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "PickNearest"
                  },
                  "parameters": [
                    "Coin",
                    "Player.CenterX()",
                    "Player.CenterY()",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetAngle"
                  },
                  "parameters": [
                    "Arrow",
                    "=",
                    "AngleBetweenPositions(Player.CenterX(), Player.CenterY(), Coin.CenterX(), Coin.CenterY())"
                  ]
                },
                {
                  "type": {
                    "value": "MettreAutour"
                  },
                  "parameters": [
                    "Arrow",
                    "Player",
                    "160",
                    "Arrow.Angle()"
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "IsOnScreen::InOnScreen::IsOnScreen"
                      },
                      "parameters": [
                        "Coin",
                        "InOnScreen",
                        "0",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Arrow"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "IsOnScreen::InOnScreen::IsOnScreen"
                      },
                      "parameters": [
                        "Coin",
                        "InOnScreen",
                        "10",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Montre"
                      },
                      "parameters": [
                        "Arrow",
                        ""
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CollisionNP"
                  },
                  "parameters": [
                    "Coin",
                    "Player",
                    "",
                    "",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Create"
                  },
                  "parameters": [
                    "",
                    "CoinPickUp",
                    "Coin.CenterX()",
                    "Coin.CenterY()",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "ChangePlan"
                  },
                  "parameters": [
                    "CoinPickUp",
                    "=",
                    "5"
                  ]
                },
                {
                  "type": {
                    "value": "Delete"
                  },
                  "parameters": [
                    "Coin",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "PlaySound"
                  },
                  "parameters": [
                    "",
                    "CoinPickUP",
                    "",
                    "25",
                    "Variable(RisingPitch)"
                  ]
                },
                {
                  "type": {
                    "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                  },
                  "parameters": [
                    "RemainingText",
                    "Text",
                    "=",
                    "\"Remaining: \" + ToString(SceneInstancesCount(Coin))"
                  ]
                },
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "RisingPitch",
                    "*",
                    "1.05"
                  ]
                },
                {
                  "type": {
                    "value": "ResetTimer"
                  },
                  "parameters": [
                    "",
                    "\"RisingPitch\""
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Collect all coins"
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SceneInstancesCount"
                      },
                      "parameters": [
                        "",
                        "Coin",
                        "=",
                        "0"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetStringVariable"
                      },
                      "parameters": [
                        "GameState",
                        "=",
                        "\"GameOver\""
                      ]
                    },
                    {
                      "type": {
                        "value": "ChangeTimeScale"
                      },
                      "parameters": [
                        "",
                        "0.5"
                      ]
                    },
                    {
                      "type": {
                        "value": "Physics2::TimeScale"
                      },
                      "parameters": [
                        "Player",
                        "Physics2",
                        "0.5"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "CompareTimer"
                          },
                          "parameters": [
                            "",
                            "\"Time\"",
                            ">=",
                            "HighScore"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Wait"
                          },
                          "parameters": [
                            "1.5"
                          ]
                        },
                        {
                          "type": {
                            "value": "Scene"
                          },
                          "parameters": [
                            "",
                            "\"Game\"",
                            ""
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::Or"
                          },
                          "parameters": [],
                          "subInstructions": [
                            {
                              "type": {
                                "value": "CompareTimer"
                              },
                              "parameters": [
                                "",
                                "\"Time\"",
                                "<",
                                "HighScore"
                              ]
                            },
                            {
                              "type": {
                                "value": "NumberVariable"
                              },
                              "parameters": [
                                "HighScore",
                                "=",
                                "0"
                              ]
                            }
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "HighScore",
                            "=",
                            "TimerElapsedTime(\"Time\")"
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "Score",
                            "=",
                            "HighScore"
                          ]
                        },
                        {
                          "type": {
                            "value": "EcrireFichierExp"
                          },
                          "parameters": [
                            "\"HighScore\"",
                            "\"HighScore\"",
                            "HighScore"
                          ]
                        },
                        {
                          "type": {
                            "value": "TextObject::ChangeColor"
                          },
                          "parameters": [
                            "BestTimeText",
                            "\"248;231;28\""
                          ]
                        },
                        {
                          "type": {
                            "value": "Wait"
                          },
                          "parameters": [
                            "1.5"
                          ]
                        },
                        {
                          "type": {
                            "value": "Scene"
                          },
                          "parameters": [
                            "",
                            "\"Leaderboard\"",
                            ""
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Reset rising pitch"
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareTimer"
                  },
                  "parameters": [
                    "",
                    "\"RisingPitch\"",
                    ">=",
                    "1"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetNumberVariable"
                  },
                  "parameters": [
                    "RisingPitch",
                    "=",
                    "RandomFloatInRange(0.9,1.1)"
                  ]
                }
              ]
            }
          ],
          "parameters": []
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Collision sound effects",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "Physics2::Collision"
                  },
                  "parameters": [
                    "Player",
                    "Physics2",
                    "Hazards",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::Once"
                  },
                  "parameters": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "PlaySound"
                  },
                  "parameters": [
                    "",
                    "Collision",
                    "",
                    "50",
                    "RandomFloatInRange(0.8,1)"
                  ]
                }
              ]
            }
          ],
          "parameters": []
        }
      ],
      "layers": [
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 55,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "2d+3d",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": [
            {
              "effectType": "Scene3D::HemisphereLight",
              "name": "Effect3",
              "doubleParameters": {
                "elevation": 90,
                "intensity": 0.75,
                "rotation": 0
              },
              "stringParameters": {
                "groundColor": "177;177;177",
                "skyColor": "255;255;255",
                "top": "Z+"
              },
              "booleanParameters": {}
            },
            {
              "effectType": "Scene3D::DirectionalLight",
              "name": "Effect",
              "doubleParameters": {
                "elevation": 45,
                "intensity": 0.5,
                "rotation": 45
              },
              "stringParameters": {
                "color": "255;255;255",
                "top": "Z+"
              },
              "booleanParameters": {}
            }
          ]
        },
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "MobileControls",
          "renderingType": "2d",
          "visibility": true,
          "cameras": [],
          "effects": []
        },
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "UI",
          "renderingType": "2d",
          "visibility": true,
          "cameras": [],
          "effects": [
            {
              "effectType": "Outline",
              "name": "Effect",
              "doubleParameters": {
                "padding": 3,
                "thickness": 3
              },
              "stringParameters": {
                "color": "0;0;0"
              },
              "booleanParameters": {}
            }
          ]
        }
      ],
      "behaviorsSharedData": [
        {
          "name": "Anchor",
          "type": "AnchorBehavior::AnchorBehavior"
        },
        {
          "name": "Animation",
          "type": "AnimatableCapability::AnimatableBehavior"
        },
        {
          "name": "Effect",
          "type": "EffectCapability::EffectBehavior"
        },
        {
          "name": "Flippable",
          "type": "FlippableCapability::FlippableBehavior"
        },
        {
          "name": "InOnScreen",
          "type": "IsOnScreen::InOnScreen"
        },
        {
          "name": "Object3D",
          "type": "Scene3D::Base3DBehavior"
        },
        {
          "name": "ObjectRectangularGrid",
          "type": "ObjectRectangularGrid::ObjectRectangularGrid"
        },
        {
          "name": "ObjectStack",
          "type": "ObjectStack::ObjectStack"
        },
        {
          "name": "Opacity",
          "type": "OpacityCapability::OpacityBehavior"
        },
        {
          "name": "Physics2",
          "type": "Physics2::Physics2Behavior",
          "gravityX": 0,
          "gravityY": 9.8,
          "scaleX": 100,
          "scaleY": 100
        },
        {
          "name": "Resizable",
          "type": "ResizableCapability::ResizableBehavior"
        },
        {
          "name": "RoadTile",
          "type": "TiledRoad::RoadTile",
          "Margin": 64,
          "TileSize": 384
        },
        {
          "name": "Scale",
          "type": "ScalableCapability::ScalableBehavior"
        },
        {
          "name": "SpeedPathMovement",
          "type": "CurvedMovement::SpeedPathMovement"
        },
        {
          "name": "Sticker",
          "type": "Sticker::Sticker"
        },
        {
          "name": "Text",
          "type": "TextContainerCapability::TextContainerBehavior"
        },
        {
          "name": "TrafficCar",
          "type": "TrafficCar::TrafficCar"
        }
      ]
    },
    {
      "b": 0,
      "disableInputWhenNotFocused": true,
      "mangledName": "Leaderboard",
      "name": "Leaderboard",
      "r": 0,
      "standardSortMethod": true,
      "stopSoundsOnStartup": true,
      "title": "",
      "v": 0,
      "uiSettings": {
        "grid": true,
        "gridType": "rectangular",
        "gridWidth": 16,
        "gridHeight": 16,
        "gridOffsetX": 0,
        "gridOffsetY": 0,
        "gridColor": 16777215,
        "gridAlpha": 0.21,
        "snap": true,
        "zoomFactor": 0.6652993502634535,
        "windowMask": false
      },
      "objectsGroups": [
        {
          "name": "PanelContent",
          "objects": [
            {
              "name": "ScoreText"
            },
            {
              "name": "PlayerNameInput"
            },
            {
              "name": "SubmitButton"
            },
            {
              "name": "RestartButton"
            }
          ]
        }
      ],
      "variables": [
        {
          "name": "LeaderboardScore",
          "type": "string",
          "value": ""
        }
      ],
      "instances": [
        {
          "angle": 0,
          "customSize": true,
          "height": 64,
          "layer": "",
          "name": "Platform",
          "persistentUuid": "c2c6a11c-e8f8-4ee6-aedb-369f62303136",
          "width": 1152,
          "x": -96,
          "y": 512,
          "zOrder": 14,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "height": 896,
          "layer": "3D",
          "name": "Background",
          "persistentUuid": "968c9c47-08c4-44eb-917a-906d2ecee36b",
          "width": 1024,
          "x": -32,
          "y": -320,
          "zOrder": 15,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 67,
          "layer": "",
          "name": "ScoreText",
          "persistentUuid": "722f1233-75ba-4128-8905-4ac5dd26bc1e",
          "width": 384,
          "x": 386,
          "y": 184,
          "zOrder": 18,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "height": 96,
          "layer": "",
          "name": "PlayerNameInput",
          "persistentUuid": "a681abd2-5235-4165-a003-4a9553d79cb5",
          "width": 416,
          "x": 344,
          "y": 288,
          "zOrder": 19,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RestartButton",
          "persistentUuid": "9e303562-d182-4829-a5eb-148a1af72803",
          "width": 0,
          "x": 528,
          "y": 448,
          "zOrder": 35,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "height": 106,
          "layer": "",
          "name": "SubmitButton",
          "persistentUuid": "3aa859c1-2135-4384-a300-bfb28b424a52",
          "width": 128,
          "x": 824,
          "y": 278,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 0,
          "height": 480,
          "layer": "",
          "name": "Panel",
          "persistentUuid": "ef024407-8612-4ce2-99b1-0f3e932160eb",
          "width": 688,
          "x": 304,
          "y": 128,
          "zOrder": 1,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        }
      ],
      "objects": [
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "ScoreText",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Sticker",
              "type": "Sticker::Sticker",
              "OnlyFollowPosition": true
            }
          ],
          "string": "Score",
          "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
          "textAlignment": "",
          "characterSize": 40,
          "color": {
            "b": 79,
            "g": 72,
            "r": 72
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "Score",
            "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
            "textAlignment": "",
            "characterSize": 40,
            "color": "72;72;79"
          }
        },
        {
          "assetStoreId": "",
          "name": "PlayerNameInput",
          "type": "TextInput::TextInputObject",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Sticker",
              "type": "Sticker::Sticker",
              "OnlyFollowPosition": true
            }
          ],
          "content": {
            "initialValue": "",
            "placeholder": "PlayerName",
            "fontResourceName": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
            "fontSize": 40,
            "inputType": "text",
            "textColor": "72;72;79",
            "fillColor": "231;232;243",
            "fillOpacity": 255,
            "borderColor": "255;255;255",
            "borderOpacity": 255,
            "borderWidth": 6,
            "readOnly": false,
            "disabled": false
          }
        },
        {
          "assetStoreId": "bfab3a269992cf43081e2cb8053c28aaef11f2f9e0d0cbdc00207ea271f69c2c",
          "name": "SubmitButton",
          "type": "PanelSpriteButton::PanelSpriteButton",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Sticker",
              "type": "Sticker::Sticker",
              "OnlyFollowPosition": true
            }
          ],
          "content": {
            "LeftPadding": 16,
            "RightPadding": 16,
            "PressedLabelOffsetY": 10,
            "BottomPadding": 32,
            "TopPadding": 16,
            "HoveredFadeOutDuration": 0.25
          },
          "childrenContent": {
            "Hovered": {
              "bottomMargin": 32,
              "height": 106,
              "leftMargin": 16,
              "rightMargin": 16,
              "texture": "Yellow Button_Hovered.png",
              "tiled": true,
              "topMargin": 16,
              "width": 256
            },
            "Idle": {
              "bottomMargin": 32,
              "height": 106,
              "leftMargin": 16,
              "rightMargin": 16,
              "texture": "Yellow Button_Idle.png",
              "tiled": true,
              "topMargin": 16,
              "width": 256
            },
            "Label": {
              "bold": false,
              "italic": false,
              "smoothed": true,
              "underlined": false,
              "string": "ð¡²",
              "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
              "textAlignment": "center",
              "characterSize": 60,
              "color": {
                "b": 42,
                "g": 87,
                "r": 139
              },
              "content": {
                "bold": false,
                "isOutlineEnabled": false,
                "isShadowEnabled": false,
                "italic": false,
                "outlineColor": "255;255;255",
                "outlineThickness": 2,
                "shadowAngle": 90,
                "shadowBlurRadius": 2,
                "shadowColor": "0;0;0",
                "shadowDistance": 4,
                "shadowOpacity": 127,
                "smoothed": true,
                "underlined": false,
                "text": "ð¡²",
                "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
                "textAlignment": "center",
                "characterSize": 60,
                "color": "139;87;42"
              }
            },
            "Pressed": {
              "bottomMargin": 16,
              "height": 106,
              "leftMargin": 16,
              "rightMargin": 16,
              "texture": "Yellow Button_Pressed.png",
              "tiled": true,
              "topMargin": 32,
              "width": 256
            }
          }
        },
        {
          "assetStoreId": "bfab3a269992cf43081e2cb8053c28aaef11f2f9e0d0cbdc00207ea271f69c2c",
          "name": "RestartButton",
          "type": "PanelSpriteButton::PanelSpriteButton",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "Sticker",
              "type": "Sticker::Sticker",
              "OnlyFollowPosition": true
            }
          ],
          "content": {
            "LeftPadding": 16,
            "RightPadding": 16,
            "PressedLabelOffsetY": 10,
            "BottomPadding": 32,
            "TopPadding": 16,
            "HoveredFadeOutDuration": 0.25
          },
          "childrenContent": {
            "Hovered": {
              "bottomMargin": 32,
              "height": 106,
              "leftMargin": 16,
              "rightMargin": 16,
              "texture": "Yellow Button_Hovered.png",
              "tiled": true,
              "topMargin": 16,
              "width": 256
            },
            "Idle": {
              "bottomMargin": 32,
              "height": 106,
              "leftMargin": 16,
              "rightMargin": 16,
              "texture": "Yellow Button_Idle.png",
              "tiled": true,
              "topMargin": 16,
              "width": 256
            },
            "Label": {
              "bold": false,
              "italic": false,
              "smoothed": true,
              "underlined": false,
              "string": "Restart",
              "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
              "textAlignment": "center",
              "characterSize": 40,
              "color": {
                "b": 42,
                "g": 87,
                "r": 139
              },
              "content": {
                "bold": false,
                "isOutlineEnabled": false,
                "isShadowEnabled": false,
                "italic": false,
                "outlineColor": "255;255;255",
                "outlineThickness": 2,
                "shadowAngle": 90,
                "shadowBlurRadius": 2,
                "shadowColor": "0;0;0",
                "shadowDistance": 4,
                "shadowOpacity": 127,
                "smoothed": true,
                "underlined": false,
                "text": "Restart",
                "font": "27d4da0f7767cf3fbf14eb2c8da758dbcfc7b5038c9214d5e6ed62db6476a6e5_Chango-Regular.ttf",
                "textAlignment": "center",
                "characterSize": 40,
                "color": "139;87;42"
              }
            },
            "Pressed": {
              "bottomMargin": 16,
              "height": 106,
              "leftMargin": 16,
              "rightMargin": 16,
              "texture": "Yellow Button_Pressed.png",
              "tiled": true,
              "topMargin": 32,
              "width": 256
            }
          }
        },
        {
          "assetStoreId": "",
          "bottomMargin": 32,
          "height": 128,
          "leftMargin": 16,
          "name": "Panel",
          "rightMargin": 16,
          "texture": "assets\\Grey Button_Idle.png",
          "tiled": false,
          "topMargin": 16,
          "type": "PanelSpriteObject::PanelSprite",
          "width": 128,
          "variables": [],
          "effects": [],
          "behaviors": []
        },
        {
          "assetStoreId": "b8200f0619b25c76e3d392f1d0d16d7547bf1c96097bc23af81b68cf11e57677",
          "name": "Coin",
          "type": "Scene3D::Model3DObject",
          "variables": [
            {
              "folded": true,
              "name": "RotationX",
              "type": "number",
              "value": 0
            },
            {
              "folded": true,
              "name": "RotationY",
              "type": "number",
              "value": 0
            },
            {
              "folded": true,
              "name": "RotationZ",
              "type": "number",
              "value": 0
            }
          ],
          "effects": [],
          "behaviors": [
            {
              "name": "ScreenWrap",
              "type": "ScreenWrap::ScreenWrap",
              "HorizontalWrapping": false,
              "VerticalWrapping": true,
              "BorderTop": 0,
              "BorderLeft": 0,
              "BorderRight": 0,
              "BorderBottom": 0,
              "TriggerOffset": 500
            }
          ],
          "content": {
            "centerLocation": "ModelOrigin",
            "depth": 64,
            "height": 64,
            "keepAspectRatio": true,
            "materialType": "StandardWithoutMetalness",
            "modelResourceName": "Coin.glb",
            "originLocation": "ModelOrigin",
            "rotationX": 0,
            "rotationY": 0,
            "rotationZ": 0,
            "width": 64,
            "animations": []
          }
        }
      ],
      "objectsFolderStructure": {
        "folderName": "__ROOT",
        "children": [
          {
            "objectName": "ScoreText"
          },
          {
            "objectName": "PlayerNameInput"
          },
          {
            "objectName": "SubmitButton"
          },
          {
            "objectName": "RestartButton"
          },
          {
            "objectName": "Panel"
          },
          {
            "objectName": "Coin"
          }
        ]
      },
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "DepartScene"
              },
              "parameters": [
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "TextContainerCapability::TextContainerBehavior::SetValue"
              },
              "parameters": [
                "ScoreText",
                "Text",
                "=",
                "\"Time: \" + TimeFormatter::SecondsToHHMMSS000(GlobalVariable(Score))"
              ]
            },
            {
              "type": {
                "value": "Sticker::Sticker::Stick"
              },
              "parameters": [
                "PanelContent",
                "Sticker",
                "Panel",
                ""
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "PlayerAuthentication::DisplayAuthenticationBanner"
                  },
                  "parameters": [
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "PlayerAuthentication::IsPlayerAuthenticated"
                  },
                  "parameters": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                  },
                  "parameters": [
                    "PlayerNameInput",
                    "Text",
                    "=",
                    "PlayerAuthentication::Username()"
                  ]
                },
                {
                  "type": {
                    "value": "TextInput::TextInputObject::SetDisabled"
                  },
                  "parameters": [
                    "PlayerNameInput",
                    "yes"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "PlayerAuthentication::IsPlayerAuthenticated"
                  },
                  "parameters": []
                },
                {
                  "type": {
                    "value": "StringVariable"
                  },
                  "parameters": [
                    "PlayerName",
                    "!=",
                    "\"0\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                  },
                  "parameters": [
                    "PlayerNameInput",
                    "Text",
                    "=",
                    "GlobalVariableString(PlayerName)"
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetCenterX"
              },
              "parameters": [
                "Panel",
                "=",
                "SceneWindowWidth() / 2"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "PlayerAuthentication::HasPlayerLoggedIn"
              },
              "parameters": []
            }
          ],
          "actions": [
            {
              "type": {
                "value": "TextContainerCapability::TextContainerBehavior::SetValue"
              },
              "parameters": [
                "PlayerNameInput",
                "Text",
                "=",
                "PlayerAuthentication::Username()"
              ]
            },
            {
              "type": {
                "value": "TextInput::TextInputObject::SetDisabled"
              },
              "parameters": [
                "PlayerNameInput",
                "yes"
              ]
            },
            {
              "type": {
                "value": "PlayerAuthentication::DisplayAuthenticationBanner"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "Leaderboards::IsLeaderboardViewErrored"
              },
              "parameters": []
            }
          ],
          "actions": [
            {
              "type": {
                "value": "PlayerAuthentication::DisplayAuthenticationBanner"
              },
              "parameters": [
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "PanelSpriteButton::PanelSpriteButton::IsClicked"
              },
              "parameters": [
                "RestartButton",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "PlayerAuthentication::HideAuthenticationBanner"
              },
              "parameters": [
                ""
              ]
            },
            {
              "type": {
                "value": "Scene"
              },
              "parameters": [
                "",
                "\"Game\"",
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Handle leaderboards.\nTo create a leaderboard, make sure your game is registered in Home > Profile > Games Dashboard and then, click on \"Manage game\" > Leaderboards. When a leaderboard is created, it should be available in the actions."
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "PanelSpriteButton::PanelSpriteButton::IsClicked"
              },
              "parameters": [
                "SubmitButton",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "PlayerAuthentication::IsPlayerAuthenticated"
                  },
                  "parameters": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Leaderboards::SaveConnectedPlayerScore"
                  },
                  "parameters": [
                    "",
                    "\"0d5ac561-afa4-45dc-bf58-561d557f7954\"",
                    "Score"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "inverted": true,
                    "value": "PlayerAuthentication::IsPlayerAuthenticated"
                  },
                  "parameters": []
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "Leaderboards::SavePlayerScore"
                  },
                  "parameters": [
                    "",
                    "\"0d5ac561-afa4-45dc-bf58-561d557f7954\"",
                    "Score",
                    "PlayerNameInput.Text()"
                  ]
                },
                {
                  "type": {
                    "value": "SetStringVariable"
                  },
                  "parameters": [
                    "PlayerName",
                    "=",
                    "PlayerNameInput.Text()"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "PlayerAuthentication::HideAuthenticationBanner"
                  },
                  "parameters": [
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Leaderboards::DisplayLeaderboard"
                  },
                  "parameters": [
                    "",
                    "\"0d5ac561-afa4-45dc-bf58-561d557f7954\"",
                    "yes"
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Allow to try and submit again in case of error."
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "Leaderboards::HasPlayerJustClosedLeaderboardView"
              },
              "parameters": []
            },
            {
              "type": {
                "value": "Leaderboards::HasLastSaveSucceeded"
              },
              "parameters": [
                "\"0d5ac561-afa4-45dc-bf58-561d557f7954\""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "Scene"
              },
              "parameters": [
                "",
                "\"Game\"",
                ""
              ]
            }
          ]
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Coins animation",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "DepartScene"
                  },
                  "parameters": [
                    ""
                  ]
                }
              ],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Repeat",
                  "repeatExpression": "100",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Coin",
                        "RandomInRange(CameraBorderLeft(), CameraBorderRight())",
                        "RandomInRange(-500 + CameraBorderTop(), CameraBorderBottom() + 500)",
                        "\"3D\""
                      ]
                    },
                    {
                      "type": {
                        "value": "SetNumberObjectVariable"
                      },
                      "parameters": [
                        "Coin",
                        "RotationX",
                        "=",
                        "RandomFloatInRange(20, 45)"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetNumberObjectVariable"
                      },
                      "parameters": [
                        "Coin",
                        "RotationY",
                        "=",
                        "RandomFloatInRange(20, 45)"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetNumberObjectVariable"
                      },
                      "parameters": [
                        "Coin",
                        "RotationZ",
                        "=",
                        "RandomFloatInRange(20, 45)"
                      ]
                    },
                    {
                      "type": {
                        "value": "AddForceXY"
                      },
                      "parameters": [
                        "Coin",
                        "0",
                        "200",
                        "1"
                      ]
                    },
                    {
                      "type": {
                        "value": "Scene3D::Base3DBehavior::SetZ"
                      },
                      "parameters": [
                        "Coin",
                        "Object3D",
                        "=",
                        "RandomFloatInRange(-1000, -32)"
                      ]
                    },
                    {
                      "type": {
                        "value": "Scene3D::Base3DBehavior::SetRotationX"
                      },
                      "parameters": [
                        "Coin",
                        "Object3D",
                        "=",
                        "RandomFloat(360)"
                      ]
                    },
                    {
                      "type": {
                        "value": "Scene3D::Base3DBehavior::SetRotationY"
                      },
                      "parameters": [
                        "Coin",
                        "Object3D",
                        "=",
                        "RandomFloat(360)"
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "Scene3D::Base3DBehavior::SetRotationX"
                  },
                  "parameters": [
                    "Coin",
                    "Object3D",
                    "+",
                    "Coin.RotationX * TimeDelta()"
                  ]
                },
                {
                  "type": {
                    "value": "Scene3D::Base3DBehavior::SetRotationY"
                  },
                  "parameters": [
                    "Coin",
                    "Object3D",
                    "+",
                    "Coin.RotationY * TimeDelta()"
                  ]
                },
                {
                  "type": {
                    "value": "SetAngle"
                  },
                  "parameters": [
                    "Coin",
                    "+",
                    "Coin.RotationZ * TimeDelta()"
                  ]
                }
              ]
            }
          ],
          "parameters": []
        }
      ],
      "layers": [
        {
          "ambientLightColorB": 167797870,
          "ambientLightColorG": 6032144,
          "ambientLightColorR": 8563600,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "3D",
          "renderingType": "3d",
          "visibility": true,
          "cameras": [],
          "effects": [
            {
              "effectType": "Scene3D::HemisphereLight",
              "name": "Light",
              "doubleParameters": {
                "elevation": 90,
                "intensity": 0.5,
                "rotation": 0
              },
              "stringParameters": {
                "groundColor": "127;127;127",
                "skyColor": "255;255;255",
                "top": "Y-"
              },
              "booleanParameters": {}
            }
          ]
        },
        {
          "ambientLightColorB": 3,
          "ambientLightColorG": 134217728,
          "ambientLightColorR": 1597197633,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "2d",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": []
        }
      ],
      "behaviorsSharedData": [
        {
          "name": "ScreenWrap",
          "type": "ScreenWrap::ScreenWrap"
        },
        {
          "name": "Sticker",
          "type": "Sticker::Sticker"
        }
      ]
    },
    {
      "b": 209,
      "disableInputWhenNotFocused": true,
      "mangledName": "Start",
      "name": "Start",
      "r": 209,
      "standardSortMethod": true,
      "stopSoundsOnStartup": true,
      "title": "",
      "v": 209,
      "uiSettings": {
        "grid": false,
        "gridType": "rectangular",
        "gridWidth": 32,
        "gridHeight": 32,
        "gridOffsetX": 0,
        "gridOffsetY": 0,
        "gridColor": 10401023,
        "gridAlpha": 0.8,
        "snap": false,
        "zoomFactor": 0.546875,
        "windowMask": false
      },
      "objectsGroups": [],
      "variables": [],
      "instances": [],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      },
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "KeyReleased"
              },
              "parameters": [
                "",
                "Space"
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "Scene"
              },
              "parameters": [
                "",
                "\"Game\"",
                ""
              ]
            }
          ]
        }
      ],
      "layers": [
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 3,
          "cameraType": "",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": [
            {
              "effectType": "Scene3D::HemisphereLight",
              "name": "3D Light",
              "doubleParameters": {
                "elevation": 45,
                "intensity": 1,
                "rotation": 0
              },
              "stringParameters": {
                "groundColor": "64;64;64",
                "skyColor": "255;255;255",
                "top": "Y-"
              },
              "booleanParameters": {}
            }
          ]
        }
      ],
      "behaviorsSharedData": []
    }
  ],
  "externalEvents": [],
  "eventsFunctionsExtensions": [
    {
      "author": "",
      "category": "User interface",
      "extensionNamespace": "",
      "fullName": "3D text",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWZvcm1hdC10ZXh0IiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTE4LjUsNEwxOS42Niw4LjM1TDE4LjcsOC42MUMxOC4yNSw3Ljc0IDE3Ljc5LDYuODcgMTcuMjYsNi40M0MxNi43Myw2IDE2LjExLDYgMTUuNSw2SDEzVjE2LjVDMTMsMTcgMTMsMTcuNSAxMy4zMywxNy43NUMxMy42NywxOCAxNC4zMywxOCAxNSwxOFYxOUg5VjE4QzkuNjcsMTggMTAuMzMsMTggMTAuNjcsMTcuNzVDMTEsMTcuNSAxMSwxNyAxMSwxNi41VjZIOC41QzcuODksNiA3LjI3LDYgNi43NCw2LjQzQzYuMjEsNi44NyA1Ljc1LDcuNzQgNS4zLDguNjFMNC4zNCw4LjM1TDUuNSw0SDE4LjVaIiAvPjwvc3ZnPg==",
      "name": "Text3D",
      "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/0b4ef00ba832f327e84d09b036d18f3fc8d4805e3020f95b034a23f558e17a6c_format-text.svg",
      "shortDescription": "Display texts in 3D scenes.",
      "version": "0.1.0",
      "description": "Display texts with 3D position and rotation.",
      "origin": {
        "identifier": "Text3D",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "3d"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__text3DExtension) {",
                "    return;",
                "}",
                "",
                "class Text3DRenderer extends gdjs.CustomRuntimeObject3DRenderer {",
                "    constructor(",
                "      object,",
                "      instanceContainer,",
                "      parent",
                "    ) {",
                "        super(object, instanceContainer, parent);",
                "    }",
                "",
                "    _updateThreeGroup() {",
                "      this._object.setScaleX(1);",
                "      this._object.setScaleY(1);",
                "      this._object.setScaleZ(1);",
                "",
                "      super._updateThreeGroup();",
                "    }",
                "}",
                "",
                "",
                "// troika-THREE-text 0.49.0",
                "// https://github.com/protectwise/troika/tree/main/packages/troika-THREE-text",
                "",
                "  /**",
                "   * Main content for the worker that handles the loading and execution of",
                "   * modules within it.",
                "   */",
                "  function workerBootstrap() {",
                "    var modules = Object.create(null);",
                "",
                "    // Handle messages for registering a module",
                "    function registerModule(ref, callback) {",
                "      var id = ref.id;",
                "      var name = ref.name;",
                "      var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];",
                "      var init = ref.init; if ( init === void 0 ) init = function(){};",
                "      var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;",
                "",
                "      // Only register once",
                "      if (modules[id]) { return }",
                "",
                "      try {",
                "        // If any dependencies are modules, ensure they're registered and grab their value",
                "        dependencies = dependencies.map(function (dep) {",
                "          if (dep && dep.isWorkerModule) {",
                "            registerModule(dep, function (depResult) {",
                "              if (depResult instanceof Error) { throw depResult }",
                "            });",
                "            dep = modules[dep.id].value;",
                "          }",
                "          return dep",
                "        });",
                "",
                "        // Rehydrate functions",
                "        init = rehydrate((\"<\" + name + \">.init\"), init);",
                "        if (getTransferables) {",
                "          getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);",
                "        }",
                "",
                "        // Initialize the module and store its value",
                "        var value = null;",
                "        if (typeof init === 'function') {",
                "          value = init.apply(void 0, dependencies);",
                "        } else {",
                "          console.error('worker module init function failed to rehydrate');",
                "        }",
                "        modules[id] = {",
                "          id: id,",
                "          value: value,",
                "          getTransferables: getTransferables",
                "        };",
                "        callback(value);",
                "      } catch(err) {",
                "        if (!(err && err.noLog)) {",
                "          console.error(err);",
                "        }",
                "        callback(err);",
                "      }",
                "    }",
                "",
                "    // Handle messages for calling a registered module's result function",
                "    function callModule(ref, callback) {",
                "      var ref$1;",
                "",
                "      var id = ref.id;",
                "      var args = ref.args;",
                "      if (!modules[id] || typeof modules[id].value !== 'function') {",
                "        callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));",
                "      }",
                "      try {",
                "        var result = (ref$1 = modules[id]).value.apply(ref$1, args);",
                "        if (result && typeof result.then === 'function') {",
                "          result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });",
                "        } else {",
                "          handleResult(result);",
                "        }",
                "      } catch(err) {",
                "        callback(err);",
                "      }",
                "      function handleResult(result) {",
                "        try {",
                "          var tx = modules[id].getTransferables && modules[id].getTransferables(result);",
                "          if (!tx || !Array.isArray(tx) || !tx.length) {",
                "            tx = undefined; //postMessage is very picky about not passing null or empty transferables",
                "          }",
                "          callback(result, tx);",
                "        } catch(err) {",
                "          console.error(err);",
                "          callback(err);",
                "        }",
                "      }",
                "    }",
                "",
                "    function rehydrate(name, str) {",
                "      var result = void 0;",
                "      self.troikaDefine = function (r) { return result = r; };",
                "      var url = URL.createObjectURL(",
                "        new Blob(",
                "          [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],",
                "          {type: 'application/javascript'}",
                "        )",
                "      );",
                "      try {",
                "        importScripts(url);",
                "      } catch(err) {",
                "        console.error(err);",
                "      }",
                "      URL.revokeObjectURL(url);",
                "      delete self.troikaDefine;",
                "      return result",
                "    }",
                "",
                "    // Handler for all messages within the worker",
                "    self.addEventListener('message', function (e) {",
                "      var ref = e.data;",
                "      var messageId = ref.messageId;",
                "      var action = ref.action;",
                "      var data = ref.data;",
                "      try {",
                "        // Module registration",
                "        if (action === 'registerModule') {",
                "          registerModule(data, function (result) {",
                "            if (result instanceof Error) {",
                "              postMessage({",
                "                messageId: messageId,",
                "                success: false,",
                "                error: result.message",
                "              });",
                "            } else {",
                "              postMessage({",
                "                messageId: messageId,",
                "                success: true,",
                "                result: {isCallable: typeof result === 'function'}",
                "              });",
                "            }",
                "          });",
                "        }",
                "        // Invocation",
                "        if (action === 'callModule') {",
                "          callModule(data, function (result, transferables) {",
                "            if (result instanceof Error) {",
                "              postMessage({",
                "                messageId: messageId,",
                "                success: false,",
                "                error: result.message",
                "              });",
                "            } else {",
                "              postMessage({",
                "                messageId: messageId,",
                "                success: true,",
                "                result: result",
                "              }, transferables || undefined);",
                "            }",
                "          });",
                "        }",
                "      } catch(err) {",
                "        postMessage({",
                "          messageId: messageId,",
                "          success: false,",
                "          error: err.stack",
                "        });",
                "      }",
                "    });",
                "  }",
                "",
                "  /**",
                "   * Fallback for `defineWorkerModule` that behaves identically but runs in the main",
                "   * thread, for when the execution environment doesn't support web workers or they",
                "   * are disallowed due to e.g. CSP security restrictions.",
                "   */",
                "  function defineMainThreadModule(options) {",
                "    var moduleFunc = function() {",
                "      var args = [], len = arguments.length;",
                "      while ( len-- ) args[ len ] = arguments[ len ];",
                "",
                "      return moduleFunc._getInitResult().then(function (initResult) {",
                "        if (typeof initResult === 'function') {",
                "          return initResult.apply(void 0, args)",
                "        } else {",
                "          throw new Error('Worker module function was called but `init` did not return a callable function')",
                "        }",
                "      })",
                "    };",
                "    moduleFunc._getInitResult = function() {",
                "      // We can ignore getTransferables in main thread. TODO workerId?",
                "      var dependencies = options.dependencies;",
                "      var init = options.init;",
                "",
                "      // Resolve dependencies",
                "      dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }",
                "      ) : [];",
                "",
                "      // Invoke init with the resolved dependencies",
                "      var initPromise = Promise.all(dependencies).then(function (deps) {",
                "        return init.apply(null, deps)",
                "      });",
                "",
                "      // Cache the resolved promise for subsequent calls",
                "      moduleFunc._getInitResult = function () { return initPromise; };",
                "",
                "      return initPromise",
                "    };",
                "    return moduleFunc",
                "  }",
                "",
                "  var supportsWorkers = function () {",
                "    var supported = false;",
                "",
                "    // Only attempt worker initialization in browsers; elsewhere it would just be",
                "    // noise e.g. loading into a Node environment for SSR.",
                "    if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {",
                "      try {",
                "        // TODO additional checks for things like importScripts within the worker?",
                "        //  Would need to be an async check.",
                "        var worker = new Worker(",
                "          URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))",
                "        );",
                "        worker.terminate();",
                "        supported = true;",
                "      } catch (err) {",
                "        if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') ; else {",
                "          console.log(",
                "            (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")",
                "          );",
                "        }",
                "      }",
                "    }",
                "",
                "    // Cached result",
                "    supportsWorkers = function () { return supported; };",
                "    return supported",
                "  };",
                "",
                "  var _workerModuleId = 0;",
                "  var _messageId = 0;",
                "  var _allowInitAsString = false;",
                "  var workers = Object.create(null);",
                "  var registeredModules = Object.create(null); //workerId -> Set<unregisterFn>",
                "  var openRequests = Object.create(null);",
                "",
                "",
                "  /**",
                "   * Define a module of code that will be executed with a web worker. This provides a simple",
                "   * interface for moving chunks of logic off the main thread, and managing their dependencies",
                "   * among one another.",
                "   *",
                "   * @param {object} options",
                "   * @param {function} options.init",
                "   * @param {array} [options.dependencies]",
                "   * @param {function} [options.getTransferables]",
                "   * @param {string} [options.name]",
                "   * @param {string} [options.workerId]",
                "   * @return {function(...[*]): {then}}",
                "   */",
                "  function defineWorkerModule(options) {",
                "    if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {",
                "      throw new Error('requires `options.init` function')",
                "    }",
                "    var dependencies = options.dependencies;",
                "    var init = options.init;",
                "    var getTransferables = options.getTransferables;",
                "    var workerId = options.workerId;",
                "",
                "    if (!supportsWorkers()) {",
                "      return defineMainThreadModule(options)",
                "    }",
                "",
                "    if (workerId == null) {",
                "      workerId = '#default';",
                "    }",
                "    var id = \"workerModule\" + (++_workerModuleId);",
                "    var name = options.name || id;",
                "    var registrationPromise = null;",
                "",
                "    dependencies = dependencies && dependencies.map(function (dep) {",
                "      // Wrap raw functions as worker modules with no dependencies",
                "      if (typeof dep === 'function' && !dep.workerModuleData) {",
                "        _allowInitAsString = true;",
                "        dep = defineWorkerModule({",
                "          workerId: workerId,",
                "          name: (\"<\" + name + \"> function dependency: \" + (dep.name)),",
                "          init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")",
                "        });",
                "        _allowInitAsString = false;",
                "      }",
                "      // Grab postable data for worker modules",
                "      if (dep && dep.workerModuleData) {",
                "        dep = dep.workerModuleData;",
                "      }",
                "      return dep",
                "    });",
                "",
                "    function moduleFunc() {",
                "      var args = [], len = arguments.length;",
                "      while ( len-- ) args[ len ] = arguments[ len ];",
                "",
                "      // Register this module if needed",
                "      if (!registrationPromise) {",
                "        registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);",
                "        var unregister = function () {",
                "          registrationPromise = null;",
                "          registeredModules[workerId].delete(unregister);",
                "        }",
                "        ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);",
                "      }",
                "",
                "      // Invoke the module, returning a promise",
                "      return registrationPromise.then(function (ref) {",
                "        var isCallable = ref.isCallable;",
                "",
                "        if (isCallable) {",
                "          return callWorker(workerId,'callModule', {id: id, args: args})",
                "        } else {",
                "          throw new Error('Worker module function was called but `init` did not return a callable function')",
                "        }",
                "      })",
                "    }",
                "    moduleFunc.workerModuleData = {",
                "      isWorkerModule: true,",
                "      id: id,",
                "      name: name,",
                "      dependencies: dependencies,",
                "      init: stringifyFunction(init),",
                "      getTransferables: getTransferables && stringifyFunction(getTransferables)",
                "    };",
                "    return moduleFunc",
                "  }",
                "",
                "  /**",
                "   * Terminate an active Worker by a workerId that was passed to defineWorkerModule.",
                "   * This only terminates the Worker itself; the worker module will remain available",
                "   * and if you call it again its Worker will be respawned.",
                "   * @param {string} workerId",
                "   */",
                "  function terminateWorker(workerId) {",
                "    // Unregister all modules that were registered in that worker",
                "    if (registeredModules[workerId]) {",
                "      registeredModules[workerId].forEach(function (unregister) {",
                "        unregister();",
                "      });",
                "    }",
                "    // Terminate the Worker object",
                "    if (workers[workerId]) {",
                "      workers[workerId].terminate();",
                "      delete workers[workerId];",
                "    }",
                "  }",
                "",
                "  /**",
                "   * Stringifies a function into a form that can be deserialized in the worker",
                "   * @param fn",
                "   */",
                "  function stringifyFunction(fn) {",
                "    var str = fn.toString();",
                "    // If it was defined in object method/property format, it needs to be modified",
                "    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {",
                "      str = 'function ' + str;",
                "    }",
                "    return str",
                "  }",
                "",
                "",
                "  function getWorker(workerId) {",
                "    var worker = workers[workerId];",
                "    if (!worker) {",
                "      // Bootstrap the worker's content",
                "      var bootstrap = stringifyFunction(workerBootstrap);",
                "",
                "      // Create the worker from the bootstrap function content",
                "      worker = workers[workerId] = new Worker(",
                "        URL.createObjectURL(",
                "          new Blob(",
                "            [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],",
                "            {type: 'application/javascript'}",
                "          )",
                "        )",
                "      );",
                "",
                "      // Single handler for response messages from the worker",
                "      worker.onmessage = function (e) {",
                "        var response = e.data;",
                "        var msgId = response.messageId;",
                "        var callback = openRequests[msgId];",
                "        if (!callback) {",
                "          throw new Error('WorkerModule response with empty or unknown messageId')",
                "        }",
                "        delete openRequests[msgId];",
                "        callback(response);",
                "      };",
                "    }",
                "    return worker",
                "  }",
                "",
                "  // Issue a call to the worker with a callback to handle the response",
                "  function callWorker(workerId, action, data) {",
                "    return new Promise(function (resolve, reject) {",
                "      var messageId = ++_messageId;",
                "      openRequests[messageId] = function (response) {",
                "        if (response.success) {",
                "          resolve(response.result);",
                "        } else {",
                "          reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));",
                "        }",
                "      };",
                "      getWorker(workerId).postMessage({",
                "        messageId: messageId,",
                "        action: action,",
                "        data: data",
                "      });",
                "    })",
                "  }",
                "",
                "  /*!",
                "  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.",
                "  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE",
                "  */",
                "  function typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GDEF\",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},d=0;d<o;d++){var f=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[f]={offset:u,length:l};}for(d=0;d<s.length;d++){var v=s[d];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var d=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return d}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var d=s.readUshort(r,t);t+=2;var f=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+d),i.featureList=e._lctf.readFeatureList(r,h+f),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=n.readUshort(r,t);t+=2;var f=e._lctf.readLookupTable(r,o+d,a);s.push(f);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,d=0;d<i;d++){var f=n.readUshort(r,t);t+=2;var u=a(r,h,o+f,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var d=a.readUshort(r,t);t+=2;for(h=0;h<d;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2;var f=e._lctf.readFeatureTable(r,n+d);f.tag=h.trim(),o.push(f);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+d);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.default=e._lctf.readLangSysTable(r,n+s));var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[d.trim()]=e._lctf.readLangSysTable(r,n+f);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var d=[];for(i=0;i<h.length-1;i++)d.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var f=d[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,f),f.CharStrings){t=f.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));f.CharStrings=v;}if(f.ROS){t=f.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),f.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),f.FDArray.push(p);}t+=c[c.length-1],t=f.FDSelect,f.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)f.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(r,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(r,f.charset,f.CharStrings.length)),e.CFF._readFDict(r,f,l),f},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var d=0;1==s?(d=r[t],t++):(d=n.readUshort(r,t),t+=2);for(i=0;i<=d;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,d=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(d=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(d=o-139,i=1),247<=o&&o<=250&&(d=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(d=256*-(o-251)-s-108,i=2),255==o&&(d=n.readInt(r,t+1)/65535,i=5),a.val=null!=d?d:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;i<=20&&(f=i,d=1),12==i&&(f=100*i+h,d=2),19!=i&&20!=i||(f=i,d=2),21<=i&&i<=27&&(f=i,d=1),28==i&&(u=o.readShort(r,t+1),d=3),29<=i&&i<=31&&(f=i,d=1),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i&&(u=o.readInt(r,t+1)/65535,d=5),s.push(null!=u?u:\"o\"+f),t+=d;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;if(28==i&&(u=n.readShort(r,t+1),d=3),29==i&&(u=n.readInt(r,t+1),d=5),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i)throw u=n.readInt(r,t+1)/65535,d=5,\"unknown number\";if(30==i){var l=[];for(d=1;;){var v=r[t+d];d++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(f=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],d=1,12==i)f=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],d=2;null!=f?(o[f]=1==s.length?s[0]:s,s=[]):s.push(u),t+=d;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var d=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+d+\"e\"+f,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,d,f,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var d=0;d<h;d++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),d=a.readUint(r,i+4),f=a.readUint(r,i+8);n.groups.push([h,d,f]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var d=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<d;i++){var f=n[o];if(o++,s.flags.push(f),0!=(8&f)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(f),i++;}}s.xs=[];for(i=0;i<d;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<d;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<d;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GDEF={},e.GDEF.parse=function(r,t,a,n){var o=t;t+=4;var s=e._bin.readUshort(r,t);return {glyphClassDef:0===s?null:e._lctf.readClassDef(r,o+s)}},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var d=o.readUshort(r,a);a+=2,0!=d&&(i.pos=e.GPOS.readValueRecord(r,a,d));}else if(2==t&&i.fmt>=1&&i.fmt<=2){d=o.readUshort(r,a);a+=2;var f=o.readUshort(r,a);a+=2;var u=e._lctf.numOfOnes(d),l=e._lctf.numOfOnes(f);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=d&&(P=e.GPOS.readValueRecord(r,p,d),p+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*l),g.push({gid2:m,val1:P,val2:x});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var C=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var _=[];for(S=0;S<C;S++){var P=null,x=null;0!=d&&(P=e.GPOS.readValueRecord(r,a,d),a+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*l),_.push({val1:P,val2:x});}i.matrix.push(_);}}}else if(4==t&&1==i.fmt)i.markCoverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.baseCoverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.markArray=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.baseArray=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else if(6==t&&1==i.fmt)i.mark1Coverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.mark2Coverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.mark1Array=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.mark2Array=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GPOS.readBaseArray=function(r,t,a){var n=e._bin,o=[],s=t,i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){for(var d=[],f=0;f<a;f++)d.push(e.GPOS.readAnchorRecord(r,s+n.readUshort(r,t))),t+=2;o.push(d);}return o},e.GPOS.readMarkArray=function(r,t){var a=e._bin,n=[],o=t,s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=e.GPOS.readAnchorRecord(r,a.readUshort(r,t+2)+o);h.markClass=a.readUshort(r,t),n.push(h),t+=4;}return n},e.GPOS.readAnchorRecord=function(r,t){var a=e._bin,n={};return n.fmt=a.readUshort(r,t),n.x=a.readShort(r,t+2),n.y=a.readShort(r,t+4),n},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&2!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||2==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var d=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,d),a+=2*i.newg.length;}}else if(2==t&&1==i.fmt){d=o.readUshort(r,a);a+=2,i.seqs=[];for(var f=0;f<d;f++){var u=o.readUshort(r,a)+s;a+=2;var l=o.readUshort(r,u);i.seqs.push(o.readUshorts(r,u+2,l));}}else if(4==t){i.vals=[];d=o.readUshort(r,a);a+=2;for(f=0;f<d;f++){var v=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+v));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var c=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+c),i.scset=[];var p=o.readUshort(r,a);a+=2;for(f=0;f<p;f++){var U=o.readUshort(r,a);a+=2,i.scset.push(0==U?null:e.GSUB.readSubClassSet(r,s+U));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(f=0;f<3;f++){d=o.readUshort(r,a);a+=2;for(var g=[],S=0;S<d;S++)g.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*S)));a+=2*d,0==f&&(i.backCvg=g),1==f&&(i.inptCvg=g),2==f&&(i.ahedCvg=g);}d=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,d);}}else {if(7==t&&1==i.fmt){var m=o.readUshort(r,a);a+=2;var b=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=m;else if(n.ltype!=m)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+b)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,d=0;d<n.maxp.numGlyphs;d++)d<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},d=0;d<i;d++){t+=2;a=o.readUshort(r,t);t+=2;var f=o.readUshort(r,t);t+=2;var u=f>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var d=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var f=d>>>8;if(0!=(f&=15))throw \"unknown kern table format: \"+f;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var f=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(d),u.vals.push(f),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var d=0;d<h;d++)s.push(o.readUshort(r,t+(d<<1))<<1);if(1==i)for(d=0;d<h;d++)s.push(o.readUint(r,t+(d<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],d=t+=2,f=0;f<s;f++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=d+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,d=1&r.flags[s],f=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(d){if(!f){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else f?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);d?f&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var d=o.crds[h],f=o.crds[h+1];a.crds.push(d*i.a+f*i.b+i.tx),a.crds.push(d*i.c+f*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var d=h.vals[i],f=0;f<d.length;f++){var u=d[f],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var C=b.substLookupRecords;for(f=0;f<C.length;f+=2)C[f],C[f+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var _=h.lookupRec;for(m=0;m<_.length;m+=2){U=_[m];var P=n[_[m+1]];e.U._applySubs(r,t+U,P,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,d=e.U.glyphToPath(r,i),f=0;f<d.crds.length;f+=2)n.crds.push(d.crds[f]+o),n.crds.push(d.crds[f+1]);a&&n.cmds.push(a);for(f=0;f<d.cmds.length;f++)n.cmds.push(d.cmds[f]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,C=0,_={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,_);var P=_.val;if(u+=_.size,\"o1\"==P||\"o18\"==P)s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==P||\"o23\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),f&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),f=!0;else if(\"o5\"==P)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==P||\"o7\"==P)for(var x=s.length,I=\"o6\"==P,w=0;w<x;w++){var k=s.shift();I?l+=k:v+=k,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==P||\"o24\"==P){x=s.length;for(var G=0;G+6<=x;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),G+=6;\"o24\"==P&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==P)break;if(\"o1234\"==P||\"o1235\"==P||\"o1236\"==P||\"o1237\"==P)\"o1234\"==P&&(p=v,U=(c=l+s.shift())+s.shift(),C=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),C=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==P){if(s.length>0&&!h&&(d=s.shift()+a.nominalWidthX,h=!0),4==s.length){var O=s.shift(),T=s.shift(),D=s.shift(),B=s.shift(),A=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[A],t,a,n,o),t.x=O,t.y=T,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}f&&(e.U.P.closePath(o),f=!1);}else if(\"o19\"==P||\"o20\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==P)s.length>2&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o22\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o25\"==P){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==P)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==P)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==P||\"o29\"==P){var L=\"o10\"==P?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=L.Subrs[W+L.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open;}}else if(\"o30\"==P||\"o31\"==P){var V=s.length,E=(G=0,\"o31\"==P);for(G+=V-(x=-3&V);G<x;)E?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),x-G==5?(l=U+s.shift(),G++):l=U,E=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),x-G==5?(v=g+s.shift(),G++):v=g,E=!0),e.U.P.curveTo(o,c,p,U,g,l,v),G+=4;}else {if(\"o\"==(P+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+P,r),P;s.push(P);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}",
                "",
                "  /*!",
                "  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate",
                "  (https://github.com/101arrowz/fflate) for use in Troika text rendering. ",
                "  Original licenses apply: ",
                "  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)",
                "  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)",
                "  */",
                "  function woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}",
                "",
                "  /**",
                "   * A factory wrapper parsing a font file using Typr.",
                "   * Also adds support for WOFF files (not WOFF2).",
                "   */",
                "",
                "  /**",
                "   * @typedef ParsedFont",
                "   * @property {number} ascender",
                "   * @property {number} descender",
                "   * @property {number} xHeight",
                "   * @property {(number) => boolean} supportsCodePoint",
                "   * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph",
                "   * @property {number} lineGap",
                "   * @property {number} capHeight",
                "   * @property {number} unitsPerEm",
                "   */",
                "",
                "  /**",
                "   * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser",
                "   */",
                "",
                "  /**",
                "   * @returns {FontParser}",
                "   */",
                "  function parserFactory(Typr, woff2otf) {",
                "    const cmdArgLengths = {",
                "      M: 2,",
                "      L: 2,",
                "      Q: 4,",
                "      C: 6,",
                "      Z: 0",
                "    };",
                "",
                "    // {joinType: \"skip+step,...\"}",
                "    const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};",
                "",
                "    const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.",
                "      JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.",
                "      JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.",
                "      JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.",
                "      JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.",
                "      JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,",
                "",
                "    let joiningTypeMap;",
                "    function getCharJoiningType(ch) {",
                "      if (!joiningTypeMap) {",
                "        const m = {",
                "          R: JT_RIGHT,",
                "          L: JT_LEFT,",
                "          D: JT_DUAL,",
                "          C: JT_JOIN_CAUSING,",
                "          U: JT_NON_JOINING,",
                "          T: JT_TRANSPARENT",
                "        };",
                "        joiningTypeMap = new Map();",
                "        for (let type in joiningTypeRawData) {",
                "          let lastCode = 0;",
                "          joiningTypeRawData[type].split(',').forEach(range => {",
                "            let [skip, step] = range.split('+');",
                "            skip = parseInt(skip,36);",
                "            step = step ? parseInt(step, 36) : 0;",
                "            joiningTypeMap.set(lastCode += skip, m[type]);",
                "            for (let i = step; i--;) {",
                "              joiningTypeMap.set(++lastCode, m[type]);",
                "            }",
                "          });",
                "        }",
                "      }",
                "      return joiningTypeMap.get(ch) || JT_NON_JOINING",
                "    }",
                "",
                "    const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;",
                "    const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];",
                "",
                "    function detectJoiningForms(str) {",
                "      // This implements the algorithm described here:",
                "      // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md",
                "      const joiningForms = new Uint8Array(str.length);",
                "      let prevJoiningType = JT_NON_JOINING;",
                "      let prevForm = ISOL;",
                "      let prevIndex = -1;",
                "      for (let i = 0; i < str.length; i++) {",
                "        const code = str.codePointAt(i);",
                "        let joiningType = getCharJoiningType(code) | 0;",
                "        let form = ISOL;",
                "        if (joiningType & JT_TRANSPARENT) {",
                "          continue",
                "        }",
                "        if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {",
                "          if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {",
                "            form = FINA;",
                "            // isol->init, fina->medi",
                "            if (prevForm === ISOL || prevForm === FINA) {",
                "              joiningForms[prevIndex]++;",
                "            }",
                "          }",
                "          else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {",
                "            // medi->fina, init->isol",
                "            if (prevForm === INIT || prevForm === MEDI) {",
                "              joiningForms[prevIndex]--;",
                "            }",
                "          }",
                "        }",
                "        else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {",
                "          // medi->fina, init->isol",
                "          if (prevForm === INIT || prevForm === MEDI) {",
                "            joiningForms[prevIndex]--;",
                "          }",
                "        }",
                "        prevForm = joiningForms[i] = form;",
                "        prevJoiningType = joiningType;",
                "        prevIndex = i;",
                "        if (code > 0xffff) i++;",
                "      }",
                "      // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))",
                "      // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))",
                "      // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))",
                "      return joiningForms",
                "    }",
                "",
                "    function stringToGlyphs (font, str) {",
                "      const glyphIds = [];",
                "      for (let i = 0; i < str.length; i++) {",
                "        const cc = str.codePointAt(i);",
                "        if (cc > 0xffff) i++;",
                "        glyphIds.push(Typr.U.codeToGlyph(font, cc));",
                "      }",
                "",
                "      const gsub = font['GSUB'];",
                "      if (gsub) {",
                "        const {lookupList, featureList} = gsub;",
                "        let joiningForms;",
                "        const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;",
                "        const usedLookups = [];",
                "        featureList.forEach(feature => {",
                "          if (supportedFeatures.test(feature.tag)) {",
                "            for (let ti = 0; ti < feature.tab.length; ti++) {",
                "              if (usedLookups[feature.tab[ti]]) continue",
                "              usedLookups[feature.tab[ti]] = true;",
                "              const tab = lookupList[feature.tab[ti]];",
                "              const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);",
                "              if (isJoiningFeature && !joiningForms) { //lazy",
                "                joiningForms = detectJoiningForms(str);",
                "              }",
                "              for (let ci = 0; ci < glyphIds.length; ci++) {",
                "                if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {",
                "                  Typr.U._applySubs(glyphIds, ci, tab, lookupList);",
                "                }",
                "              }",
                "            }",
                "          }",
                "        });",
                "      }",
                "",
                "      return glyphIds",
                "    }",
                "",
                "    // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark",
                "    // attachments. This is a more complete version of Typr.U.getPairAdjustment",
                "    // and should become an upstream replacement eventually.",
                "    function calcGlyphPositions(font, glyphIds) {",
                "      const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]",
                "      let glyphIndex = 0;",
                "      for (; glyphIndex < glyphIds.length; glyphIndex++) {",
                "        const glyphId = glyphIds[glyphIndex];",
                "        if (glyphId === -1) continue;",
                "",
                "        positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.",
                "",
                "        const gpos = font.GPOS;",
                "        if (gpos) {",
                "          const llist = gpos.lookupList;",
                "          for (let i = 0; i < llist.length; i++) {",
                "            const lookup = llist[i];",
                "            for (let j = 0; j < lookup.tabs.length; j++) {",
                "              const tab = lookup.tabs[j];",
                "              // Single char placement",
                "              if (lookup.ltype === 1) {",
                "                const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);",
                "                if (ind !== -1 && tab.pos) {",
                "                  applyValueRecord(tab.pos, glyphIndex);",
                "                  break",
                "                }",
                "              }",
                "              // Pairs (kerning)",
                "              else if (lookup.ltype === 2) {",
                "                let adj = null;",
                "                let prevGlyphIndex = getPrevGlyphIndex();",
                "                if (prevGlyphIndex !== -1) {",
                "                  const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);",
                "                  if (coverageIndex !== -1) {",
                "                    if (tab.fmt === 1) {",
                "                      const right = tab.pairsets[coverageIndex];",
                "                      for (let k = 0; k < right.length; k++) {",
                "                        if (right[k].gid2 === glyphId) adj = right[k];",
                "                      }",
                "                    } else if (tab.fmt === 2) {",
                "                      const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);",
                "                      const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);",
                "                      adj = tab.matrix[c1][c2];",
                "                    }",
                "                    if (adj) {",
                "                      if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);",
                "                      if (adj.val2) applyValueRecord(adj.val2, glyphIndex);",
                "                      break",
                "                    }",
                "                  }",
                "                }",
                "              }",
                "              // Mark to base",
                "              else if (lookup.ltype === 4) {",
                "                const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);",
                "                if (markArrIndex !== -1) {",
                "                  const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);",
                "                  const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);",
                "                  if (baseArrIndex !== -1) {",
                "                    const markRecord = tab.markArray[markArrIndex];",
                "                    const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];",
                "                    positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];",
                "                    positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];",
                "                    break;",
                "                  }",
                "                }",
                "              }",
                "              // Mark to mark",
                "              else if (lookup.ltype === 6) {",
                "                const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);",
                "                if (mark1ArrIndex !== -1) {",
                "                  const prevGlyphIndex = getPrevGlyphIndex();",
                "                  if (prevGlyphIndex !== -1) {",
                "                    const prevGlyphId = glyphIds[prevGlyphIndex];",
                "                    if (getGlyphClass(font, prevGlyphId) === 3) { // only check mark glyphs",
                "                      const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);",
                "                      if (mark2ArrIndex !== -1) {",
                "                        const mark1Record = tab.mark1Array[mark1ArrIndex];",
                "                        const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];",
                "                        positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];",
                "                        positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];",
                "                        break;",
                "                      }",
                "                    }",
                "                  }",
                "                }",
                "              }",
                "            }",
                "          }",
                "        }",
                "        // Check kern table if no GPOS",
                "        else if (font.kern && !font.cff) {",
                "          const prevGlyphIndex = getPrevGlyphIndex();",
                "          if (prevGlyphIndex !== -1) {",
                "            const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);",
                "            if (ind1 !== -1) {",
                "              const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);",
                "              if (ind2 !== -1) {",
                "                positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];",
                "              }",
                "            }",
                "          }",
                "        }",
                "      }",
                "",
                "      return positions;",
                "",
                "      function getPrevGlyphIndex(filter) {",
                "        for (let i = glyphIndex - 1; i >=0; i--) {",
                "          if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {",
                "            return i",
                "          }",
                "        }",
                "        return -1;",
                "      }",
                "",
                "      function isBaseGlyph(glyphId) {",
                "        return getGlyphClass(font, glyphId) === 1;",
                "      }",
                "",
                "      function applyValueRecord(source, gi) {",
                "        for (let i = 0; i < 3; i++) {",
                "          positions[gi * 3 + i] += source[i] || 0;",
                "        }",
                "      }",
                "    }",
                "",
                "    function getGlyphClass(font, glyphId) {",
                "      const classDef = font.GDEF && font.GDEF.glyphClassDef;",
                "      return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;",
                "    }",
                "",
                "    function firstNum(...args) {",
                "      for (let i = 0; i < args.length; i++) {",
                "        if (typeof args[i] === 'number') {",
                "          return args[i]",
                "        }",
                "      }",
                "    }",
                "",
                "    /**",
                "     * @returns ParsedFont",
                "     */",
                "    function wrapFontObj(typrFont) {",
                "      const glyphMap = Object.create(null);",
                "",
                "      const os2 = typrFont['OS/2'];",
                "      const hhea = typrFont.hhea;",
                "      const unitsPerEm = typrFont.head.unitsPerEm;",
                "      const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);",
                "",
                "      /** @type ParsedFont */",
                "      const fontObj = {",
                "        unitsPerEm,",
                "        ascender,",
                "        descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),",
                "        capHeight: firstNum(os2 && os2.sCapHeight, ascender),",
                "        xHeight: firstNum(os2 && os2.sxHeight, ascender),",
                "        lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),",
                "        supportsCodePoint(code) {",
                "          return Typr.U.codeToGlyph(typrFont, code) > 0",
                "        },",
                "        forEachGlyph(text, fontSize, letterSpacing, callback) {",
                "          let penX = 0;",
                "          const fontScale = 1 / fontObj.unitsPerEm * fontSize;",
                "",
                "          const glyphIds = stringToGlyphs(typrFont, text);",
                "          let charIndex = 0;",
                "          const positions = calcGlyphPositions(typrFont, glyphIds);",
                "",
                "          glyphIds.forEach((glyphId, i) => {",
                "            // Typr returns a glyph index per string codepoint, with -1s in place of those that",
                "            // were omitted due to ligature substitution. So we can track original index in the",
                "            // string via simple increment, and skip everything else when seeing a -1.",
                "            if (glyphId !== -1) {",
                "              let glyphObj = glyphMap[glyphId];",
                "              if (!glyphObj) {",
                "                const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphId);",
                "",
                "                // Build path string",
                "                let path = '';",
                "                let crdsIdx = 0;",
                "                for (let i = 0, len = cmds.length; i < len; i++) {",
                "                  const numArgs = cmdArgLengths[cmds[i]];",
                "                  path += cmds[i];",
                "                  for (let j = 1; j <= numArgs; j++) {",
                "                    path += (j > 1 ? ',' : '') + crds[crdsIdx++];",
                "                  }",
                "                }",
                "",
                "                // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't",
                "                // normalize the two, so it's simplest just to iterate ourselves.",
                "                let xMin, yMin, xMax, yMax;",
                "                if (crds.length) {",
                "                  xMin = yMin = Infinity;",
                "                  xMax = yMax = -Infinity;",
                "                  for (let i = 0, len = crds.length; i < len; i += 2) {",
                "                    let x = crds[i];",
                "                    let y = crds[i + 1];",
                "                    if (x < xMin) xMin = x;",
                "                    if (y < yMin) yMin = y;",
                "                    if (x > xMax) xMax = x;",
                "                    if (y > yMax) yMax = y;",
                "                  }",
                "                } else {",
                "                  xMin = xMax = yMin = yMax = 0;",
                "                }",
                "",
                "                glyphObj = glyphMap[glyphId] = {",
                "                  index: glyphId,",
                "                  advanceWidth: typrFont.hmtx.aWidth[glyphId],",
                "                  xMin,",
                "                  yMin,",
                "                  xMax,",
                "                  yMax,",
                "                  path,",
                "                };",
                "              }",
                "",
                "              callback.call(",
                "                null,",
                "                glyphObj,",
                "                penX + positions[i * 3] * fontScale,",
                "                positions[i * 3 + 1] * fontScale,",
                "                charIndex",
                "              );",
                "",
                "              penX += positions[i * 3 + 2] * fontScale;",
                "              if (letterSpacing) {",
                "                penX += letterSpacing * fontSize;",
                "              }",
                "            }",
                "            charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);",
                "          });",
                "",
                "          return penX",
                "        }",
                "      };",
                "",
                "      return fontObj",
                "    }",
                "",
                "    /**",
                "     * @type FontParser",
                "     */",
                "    return function parse(buffer) {",
                "      // Look to see if we have a WOFF file and convert it if so:",
                "      const peek = new Uint8Array(buffer, 0, 4);",
                "      const tag = Typr._bin.readASCII(peek, 0, 4);",
                "      if (tag === 'wOFF') {",
                "        buffer = woff2otf(buffer);",
                "      } else if (tag === 'wOF2') {",
                "        throw new Error('woff2 fonts not supported')",
                "      }",
                "      return wrapFontObj(Typr.parse(buffer)[0])",
                "    }",
                "  }",
                "",
                "",
                "  const workerModule = /*#__PURE__*/defineWorkerModule({",
                "    name: 'Typr Font Parser',",
                "    dependencies: [typrFactory, woff2otfFactory, parserFactory],",
                "    init(typrFactory, woff2otfFactory, parserFactory) {",
                "      const Typr = typrFactory();",
                "      const woff2otf = woff2otfFactory();",
                "      return parserFactory(Typr, woff2otf)",
                "    }",
                "  });",
                "",
                "  /*!",
                "  Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)",
                "  for use in Troika text rendering. ",
                "  Original MIT license applies",
                "  */",
                "  function unicodeFontResolverClientFactory(){return function(t){var n=function(){this.buckets=new Map;};n.prototype.add=function(t){var n=t>>5;this.buckets.set(n,(this.buckets.get(n)||0)|1<<(31&t));},n.prototype.has=function(t){var n=this.buckets.get(t>>5);return void 0!==n&&0!=(n&1<<(31&t))},n.prototype.serialize=function(){var t=[];return this.buckets.forEach((function(n,r){t.push((+r).toString(36)+\":\"+n.toString(36));})),t.join(\",\")},n.prototype.deserialize=function(t){var n=this;this.buckets.clear(),t.split(\",\").forEach((function(t){var r=t.split(\":\");n.buckets.set(parseInt(r[0],36),parseInt(r[1],36));}));};var r=Math.pow(2,8),e=r-1,o=~e;function a(t){var n=function(t){return t&o}(t).toString(16),e=function(t){return (t&o)+r-1}(t).toString(16);return \"codepoint-index/plane\"+(t>>16)+\"/\"+n+\"-\"+e+\".json\"}function i(t,n){var r=t&e,o=n.codePointAt(r/6|0);return 0!=((o=(o||48)-48)&1<<r%6)}function u(t,n){var r;(r=t,r.replace(/U\\+/gi,\"\").replace(/^,+|,+$/g,\"\").split(/,+/).map((function(t){return t.split(\"-\").map((function(t){return parseInt(t.trim(),16)}))}))).forEach((function(t){var r=t[0],e=t[1];void 0===e&&(e=r),n(r,e);}));}function c(t,n){u(t,(function(t,r){for(var e=t;e<=r;e++)n(e);}));}var s={},f={},l=new WeakMap,v=\"https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data\";function d(t){var r=l.get(t);return r||(r=new n,c(t.ranges,(function(t){return r.add(t)})),l.set(t,r)),r}var h,p=new Map;function g(t,n,r){return t[n]?n:t[r]?r:function(t){for(var n in t)return n}(t)}function w(t,n){var r=n;if(!t.includes(r)){r=1/0;for(var e=0;e<t.length;e++)Math.abs(t[e]-n)<Math.abs(r-n)&&(r=t[e]);}return r}function k(t){return h||(h=new Set,c(\"9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000\",(function(t){h.add(t);}))),h.has(t)}return t.CodePointSet=n,t.clearCache=function(){s={},f={};},t.getFontsForString=function(t,n){void 0===n&&(n={});var r,e=n.lang;void 0===e&&(e=/\\p{Script=Hangul}/u.test(r=t)?\"ko\":/\\p{Script=Hiragana}|\\p{Script=Katakana}/u.test(r)?\"ja\":\"en\");var o=n.category;void 0===o&&(o=\"sans-serif\");var u=n.style;void 0===u&&(u=\"normal\");var c=n.weight;void 0===c&&(c=400);var l=(n.dataUrl||v).replace(/\\/$/g,\"\"),h=new Map,y=new Uint8Array(t.length),b={},m={},A=new Array(t.length),S=new Map,j=!1;function M(t){var n=p.get(t);return n||(n=fetch(l+\"/\"+t).then((function(t){if(!t.ok)throw new Error(t.statusText);return t.json().then((function(t){if(!Array.isArray(t)||1!==t[0])throw new Error(\"Incorrect schema version; need 1, got \"+t[0]);return t[1]}))})).catch((function(n){if(l!==v)return j||(console.error('unicode-font-resolver: Failed loading from dataUrl \"'+l+'\", trying default CDN. '+n.message),j=!0),l=v,p.delete(t),M(t);throw n})),p.set(t,n)),n}for(var P=function(n){var r=t.codePointAt(n),e=a(r);A[n]=e,s[e]||S.has(e)||S.set(e,M(e).then((function(t){s[e]=t;}))),r>65535&&(n++,E=n);},E=0;E<t.length;E++)P(E);return Promise.all(S.values()).then((function(){S.clear();for(var n=function(n){var o=t.codePointAt(n),a=null,u=s[A[n]],c=void 0;for(var l in u){var v=m[l];if(void 0===v&&(v=m[l]=new RegExp(l).test(e||\"en\")),v){for(var d in c=l,u[l])if(i(o,u[l][d])){a=d;break}break}}if(!a)t:for(var h in u)if(h!==c)for(var p in u[h])if(i(o,u[h][p])){a=p;break t}a||(console.debug(\"No font coverage for U+\"+o.toString(16)),a=\"latin\"),A[n]=a,f[a]||S.has(a)||S.set(a,M(\"font-meta/\"+a+\".json\").then((function(t){f[a]=t;}))),o>65535&&(n++,r=n);},r=0;r<t.length;r++)n(r);return Promise.all(S.values())})).then((function(){for(var n,r=null,e=0;e<t.length;e++){var a=t.codePointAt(e);if(r&&(k(a)||d(r).has(a)))y[e]=y[e-1];else {r=f[A[e]];var i=b[r.id];if(!i){var s=r.typeforms,v=g(s,o,\"sans-serif\"),p=g(s[v],u,\"normal\"),m=w(null===(n=s[v])||void 0===n?void 0:n[p],c);i=b[r.id]=l+\"/font-files/\"+r.id+\"/\"+v+\".\"+p+\".\"+m+\".woff\";}var S=h.get(i);null==S&&(S=h.size,h.set(i,S)),y[e]=S;}a>65535&&(e++,y[e]=y[e-1]);}return {fontUrls:Array.from(h.keys()),chars:y}}))},Object.defineProperty(t,\"__esModule\",{value:!0}),t}({})}",
                "",
                "  /**",
                "   * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont",
                "   */",
                "",
                "  /**",
                "   * @typedef {ClientOptions} FontResolverOptions",
                "   * @property {Array<UserFont>|UserFont} [fonts]",
                "   * @property {'normal'|'italic'} [style]",
                "   * @property {'normal'|'bold'|number} [style]",
                "   * @property {string} [unicodeFontsURL]",
                "   */",
                "",
                "  /**",
                "   * @typedef {Object} FontResolverResult",
                "   * @property {Uint8Array} chars",
                "   * @property {Array<ParsedFont & {src:string}>} fonts",
                "   */",
                "",
                "  /**",
                "   * @typedef {function} FontResolver",
                "   * @param {string} text",
                "   * @param {(FontResolverResult) => void} callback",
                "   * @param {FontResolverOptions} [options]",
                "   */",
                "",
                "  /**",
                "   * Factory for the FontResolver function.",
                "   * @param {FontParser} fontParser",
                "   * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient",
                "   * @return {FontResolver}",
                "   */",
                "  function createFontResolver(fontParser, unicodeFontResolverClient) {",
                "    /**",
                "     * @type {Record<string, ParsedFont>}",
                "     */",
                "    const parsedFonts = Object.create(null);",
                "",
                "    /**",
                "     * @type {Record<string, Array<(ParsedFont) => void>>}",
                "     */",
                "    const loadingFonts = Object.create(null);",
                "",
                "    /**",
                "     * Load a given font url",
                "     */",
                "    function doLoadFont(url, callback) {",
                "      const onError = err => {",
                "        console.error(`Failure loading font ${url}`, err);",
                "      };",
                "      try {",
                "        const request = new XMLHttpRequest();",
                "        request.open('get', url, true);",
                "        request.responseType = 'arraybuffer';",
                "        request.onload = function () {",
                "          if (request.status >= 400) {",
                "            onError(new Error(request.statusText));",
                "          }",
                "          else if (request.status > 0) {",
                "            try {",
                "              const fontObj = fontParser(request.response);",
                "              fontObj.src = url;",
                "              callback(fontObj);",
                "            } catch (e) {",
                "              onError(e);",
                "            }",
                "          }",
                "        };",
                "        request.onerror = onError;",
                "        request.send();",
                "      } catch(err) {",
                "        onError(err);",
                "      }",
                "    }",
                "",
                "",
                "    /**",
                "     * Load a given font url if needed, invoking a callback when it's loaded. If already",
                "     * loaded, the callback will be called synchronously.",
                "     * @param {string} fontUrl",
                "     * @param {(font: ParsedFont) => void} callback",
                "     */",
                "    function loadFont(fontUrl, callback) {",
                "      let font = parsedFonts[fontUrl];",
                "      if (font) {",
                "        callback(font);",
                "      } else if (loadingFonts[fontUrl]) {",
                "        loadingFonts[fontUrl].push(callback);",
                "      } else {",
                "        loadingFonts[fontUrl] = [callback];",
                "        doLoadFont(fontUrl, fontObj => {",
                "          fontObj.src = fontUrl;",
                "          parsedFonts[fontUrl] = fontObj;",
                "          loadingFonts[fontUrl].forEach(cb => cb(fontObj));",
                "          delete loadingFonts[fontUrl];",
                "        });",
                "      }",
                "    }",
                "",
                "    /**",
                "     * For a given string of text, determine which fonts are required to fully render it and",
                "     * ensure those fonts are loaded.",
                "     */",
                "    return function (text, callback, {",
                "      lang,",
                "      fonts: userFonts = [],",
                "      style = 'normal',",
                "      weight = 'normal',",
                "      unicodeFontsURL",
                "    } = {}) {",
                "      const charResolutions = new Uint8Array(text.length);",
                "      const fontResolutions = [];",
                "      if (!text.length) {",
                "        allDone();",
                "      }",
                "",
                "      const fontIndices = new Map();",
                "      const fallbackRanges = []; // [[start, end], ...]",
                "",
                "      if (style !== 'italic') style = 'normal';",
                "      if (typeof weight !== 'number') {",
                "        weight = weight === 'bold' ? 700 : 400;",
                "      }",
                "",
                "      if (userFonts && !Array.isArray(userFonts)) {",
                "        userFonts = [userFonts];",
                "      }",
                "      userFonts = userFonts.slice()",
                "        // filter by language",
                "        .filter(def => !def.lang || def.lang.test(lang))",
                "        // switch order for easier iteration",
                "        .reverse();",
                "      if (userFonts.length) {",
                "        const UNKNOWN = 0;",
                "        const RESOLVED = 1;",
                "        const NEEDS_FALLBACK = 2;",
                "        let prevCharResult = UNKNOWN",
                "",
                "        ;(function resolveUserFonts (startIndex = 0) {",
                "          for (let i = startIndex, iLen = text.length; i < iLen; i++) {",
                "            const codePoint = text.codePointAt(i);",
                "            // Carry previous character's result forward if:",
                "            // - it resolved to a font that also covers this character",
                "            // - this character is whitespace",
                "            if (",
                "              (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint)) ||",
                "              /\\s/.test(text[i])",
                "            ) {",
                "              charResolutions[i] = charResolutions[i - 1];",
                "              if (prevCharResult === NEEDS_FALLBACK) {",
                "                fallbackRanges[fallbackRanges.length - 1][1] = i;",
                "              }",
                "            }  else {",
                "              for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {",
                "                if (j === jLen) {",
                "                  // none of the user fonts matched; needs fallback",
                "                  const range = prevCharResult === NEEDS_FALLBACK ?",
                "                    fallbackRanges[fallbackRanges.length - 1] :",
                "                    (fallbackRanges[fallbackRanges.length] = [i, i]);",
                "                  range[1] = i;",
                "                  prevCharResult = NEEDS_FALLBACK;",
                "                } else {",
                "                  charResolutions[i] = j;",
                "                  const { src, unicodeRange } = userFonts[j];",
                "                  // filter by optional explicit unicode ranges",
                "                  if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {",
                "                    const fontObj = parsedFonts[src];",
                "                    // font not yet loaded, load it and resume",
                "                    if (!fontObj) {",
                "                      loadFont(src, () => {",
                "                        resolveUserFonts(i);",
                "                      });",
                "                      return;",
                "                    }",
                "                    // if the font actually contains a glyph for this char, lock it in",
                "                    if (fontObj.supportsCodePoint(codePoint)) {",
                "                      let fontIndex = fontIndices.get(fontObj);",
                "                      if (typeof fontIndex !== 'number') {",
                "                        fontIndex = fontResolutions.length;",
                "                        fontResolutions.push(fontObj);",
                "                        fontIndices.set(fontObj, fontIndex);",
                "                      }",
                "                      charResolutions[i] = fontIndex;",
                "                      prevCharResult = RESOLVED;",
                "                      break;",
                "                    }",
                "                  }",
                "                }",
                "              }",
                "            }",
                "",
                "            if (codePoint > 0xffff && i + 1 < iLen) {",
                "              charResolutions[i + 1] = charResolutions[i];",
                "              i++;",
                "              if (prevCharResult === NEEDS_FALLBACK) {",
                "                fallbackRanges[fallbackRanges.length - 1][1] = i;",
                "              }",
                "            }",
                "          }",
                "          resolveFallbacks();",
                "        })();",
                "      } else {",
                "        fallbackRanges.push([0, text.length - 1]);",
                "        resolveFallbacks();",
                "      }",
                "",
                "      function resolveFallbacks() {",
                "        if (fallbackRanges.length) {",
                "          // Combine all fallback substrings into a single string for querying",
                "          const fallbackString = fallbackRanges.map(range => text.substring(range[0], range[1] + 1)).join('\\n');",
                "          unicodeFontResolverClient.getFontsForString(fallbackString, {",
                "            lang: lang || undefined,",
                "            style,",
                "            weight,",
                "            dataUrl: unicodeFontsURL",
                "          }).then(({fontUrls, chars}) => {",
                "            // Extract results and put them back in the main array",
                "            const fontIndexOffset = fontResolutions.length;",
                "            let charIdx = 0;",
                "            fallbackRanges.forEach(range => {",
                "              for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {",
                "                charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;",
                "              }",
                "              charIdx++; //skip segment separator",
                "            });",
                "",
                "            // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker",
                "            let loadedCount = 0;",
                "            fontUrls.forEach((url, i) => {",
                "              loadFont(url, fontObj => {",
                "                fontResolutions[i + fontIndexOffset] = fontObj;",
                "                if (++loadedCount === fontUrls.length) {",
                "                  allDone();",
                "                }",
                "              });",
                "            });",
                "          });",
                "        } else {",
                "          allDone();",
                "        }",
                "      }",
                "",
                "      function allDone() {",
                "        callback({",
                "          chars: charResolutions,",
                "          fonts: fontResolutions",
                "        });",
                "      }",
                "",
                "      function isCodeInRanges(code, ranges) {",
                "        // todo optimize search - CodePointSet from unicode-font-resolver?",
                "        for (let k = 0; k < ranges.length; k++) {",
                "          const [start, end = start] = ranges[k];",
                "          if (start <= code && code <= end) {",
                "            return true",
                "          }",
                "        }",
                "        return false",
                "      }",
                "    }",
                "  }",
                "",
                "  const fontResolverWorkerModule = /*#__PURE__*/defineWorkerModule({",
                "    name: 'FontResolver',",
                "    dependencies: [",
                "      createFontResolver,",
                "      workerModule,",
                "      unicodeFontResolverClientFactory,",
                "    ],",
                "    init(createFontResolver, fontParser, unicodeFontResolverClientFactory) {",
                "      return createFontResolver(fontParser, unicodeFontResolverClientFactory());",
                "    }",
                "  });",
                "",
                "  /**",
                "   * @typedef {number|'left'|'center'|'right'} AnchorXValue",
                "   */",
                "  /**",
                "   * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue",
                "   */",
                "",
                "  /**",
                "   * @typedef {object} TypesetParams",
                "   * @property {string} text",
                "   * @property {UserFont|UserFont[]} [font]",
                "   * @property {string} [lang]",
                "   * @property {number} [sdfGlyphSize=64]",
                "   * @property {number} [fontSize=1]",
                "   * @property {number|'normal'|'bold'} [fontWeight='normal']",
                "   * @property {'normal'|'italic'} [fontStyle='normal']",
                "   * @property {number} [letterSpacing=0]",
                "   * @property {'normal'|number} [lineHeight='normal']",
                "   * @property {number} [maxWidth]",
                "   * @property {'ltr'|'rtl'} [direction='ltr']",
                "   * @property {string} [textAlign='left']",
                "   * @property {number} [textIndent=0]",
                "   * @property {'normal'|'nowrap'} [whiteSpace='normal']",
                "   * @property {'normal'|'break-word'} [overflowWrap='normal']",
                "   * @property {AnchorXValue} [anchorX=0]",
                "   * @property {AnchorYValue} [anchorY=0]",
                "   * @property {boolean} [metricsOnly=false]",
                "   * @property {string} [unicodeFontsURL]",
                "   * @property {FontResolverResult} [preResolvedFonts]",
                "   * @property {boolean} [includeCaretPositions=false]",
                "   * @property {number} [chunkedBoundsSize=8192]",
                "   * @property {{[rangeStartIndex]: number}} [colorRanges]",
                "   */",
                "",
                "  /**",
                "   * @typedef {object} TypesetResult",
                "   * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font",
                "   * @property {Uint8Array} glyphFontIndices index into fontData for each glyph",
                "   * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout",
                "   * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text",
                "   * @property {TypesetFontData[]} fontData data about each font used in the text",
                "   * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char",
                "   * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied",
                "   *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs",
                "   *         fontSize, //calculated em height",
                "   *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline",
                "   *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight",
                "   *           anchorXOffset,",
                "   *           anchorYOffset - totalHeight,",
                "   *           anchorXOffset + maxLineWidth,",
                "   *           anchorYOffset",
                "   *         ],",
                "   *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds",
                "   *         timings",
                "   */",
                "",
                "  /**",
                "   * @typedef {object} TypesetFontData",
                "   * @property src",
                "   * @property unitsPerEm",
                "   * @property ascender",
                "   * @property descender",
                "   * @property lineHeight",
                "   * @property capHeight",
                "   * @property xHeight",
                "   */",
                "",
                "  /**",
                "   * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.",
                "   * @param {TypesetParams} params",
                "   * @param {(TypesetResult) => void} callback - function called when typesetting is complete.",
                "   *    If the params included `preResolvedFonts`, this will be called synchronously.",
                "   */",
                "",
                "  /**",
                "   * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.",
                "   * @param {TypesetParams} params",
                "   * @param {(width:number, height:number) => void} callback - function called when measurement is complete.",
                "   *    If the params included `preResolvedFonts`, this will be called synchronously.",
                "   */",
                "",
                "",
                "  /**",
                "   * Factory function that creates a self-contained environment for processing text typesetting requests.",
                "   *",
                "   * It is important that this function has no closure dependencies, so that it can be easily injected",
                "   * into the source for a Worker without requiring a build step or complex dependency loading. All its",
                "   * dependencies must be passed in at initialization.",
                "   *",
                "   * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts",
                "   * @param {object} bidi - the bidi.js implementation object",
                "   * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}",
                "   */",
                "  function createTypesetter(resolveFonts, bidi) {",
                "    const INF = Infinity;",
                "",
                "    // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs",
                "    // eslint-disable-next-line no-misleading-character-class",
                "    const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;",
                "",
                "    // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces",
                "    const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;",
                "",
                "    // Incomplete set of characters that allow line breaking after them",
                "    // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14",
                "    const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);",
                "",
                "    /**",
                "     * Load and parse all the necessary fonts to render a given string of text, then group",
                "     * them into consecutive runs of characters sharing a font.",
                "     */",
                "    function calculateFontRuns({text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL}, onDone) {",
                "      const onResolved = ({chars, fonts: parsedFonts}) => {",
                "        let curRun, prevVal;",
                "        const runs = [];",
                "        for (let i = 0; i < chars.length; i++) {",
                "          if (chars[i] !== prevVal) {",
                "            prevVal = chars[i];",
                "            runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]]});",
                "          } else {",
                "            curRun.end = i;",
                "          }",
                "        }",
                "        onDone(runs);",
                "      };",
                "      if (preResolvedFonts) {",
                "        onResolved(preResolvedFonts);",
                "      } else {",
                "        resolveFonts(",
                "          text,",
                "          onResolved,",
                "          { lang, fonts, style, weight, unicodeFontsURL }",
                "        );",
                "      }",
                "    }",
                "",
                "    /**",
                "     * Main entry point.",
                "     * Process a text string with given font and formatting parameters, and return all info",
                "     * necessary to render all its glyphs.",
                "     * @type TypesetterTypesetFunction",
                "     */",
                "    function typeset(",
                "      {",
                "        text='',",
                "        font,",
                "        lang,",
                "        sdfGlyphSize=64,",
                "        fontSize=400,",
                "        fontWeight=1,",
                "        fontStyle='normal',",
                "        letterSpacing=0,",
                "        lineHeight='normal',",
                "        maxWidth=INF,",
                "        direction,",
                "        textAlign='left',",
                "        textIndent=0,",
                "        whiteSpace='normal',",
                "        overflowWrap='normal',",
                "        anchorX = 0,",
                "        anchorY = 0,",
                "        metricsOnly=false,",
                "        unicodeFontsURL,",
                "        preResolvedFonts=null,",
                "        includeCaretPositions=false,",
                "        chunkedBoundsSize=8192,",
                "        colorRanges=null",
                "      },",
                "      callback",
                "    ) {",
                "      const mainStart = now();",
                "      const timings = {fontLoad: 0, typesetting: 0};",
                "",
                "      // Ensure newlines are normalized",
                "      if (text.indexOf('\\r') > -1) {",
                "        console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');",
                "        text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');",
                "      }",
                "",
                "      // Ensure we've got numbers not strings",
                "      fontSize = +fontSize;",
                "      letterSpacing = +letterSpacing;",
                "      maxWidth = +maxWidth;",
                "      lineHeight = lineHeight || 'normal';",
                "      textIndent = +textIndent;",
                "",
                "      calculateFontRuns({",
                "        text,",
                "        lang,",
                "        style: fontStyle,",
                "        weight: fontWeight,",
                "        fonts: typeof font === 'string' ? [{src: font}] : font,",
                "        unicodeFontsURL,",
                "        preResolvedFonts",
                "      }, runs => {",
                "        timings.fontLoad = now() - mainStart;",
                "        const hasMaxWidth = isFinite(maxWidth);",
                "        let glyphIds = null;",
                "        let glyphFontIndices = null;",
                "        let glyphPositions = null;",
                "        let glyphData = null;",
                "        let glyphColors = null;",
                "        let caretPositions = null;",
                "        let visibleBounds = null;",
                "        let chunkedBounds = null;",
                "        let maxLineWidth = 0;",
                "        let renderableGlyphCount = 0;",
                "        let canWrap = whiteSpace !== 'nowrap';",
                "        const metricsByFont = new Map(); // fontObj -> metrics",
                "        const typesetStart = now();",
                "",
                "        // Distribute glyphs into lines based on wrapping",
                "        let lineXOffset = textIndent;",
                "        let prevRunEndX = 0;",
                "        let currentLine = new TextLine();",
                "        const lines = [currentLine];",
                "        runs.forEach(run => {",
                "          const { fontObj } = run;",
                "          const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;",
                "",
                "          // Calculate metrics for each font used",
                "          let fontData = metricsByFont.get(fontObj);",
                "          if (!fontData) {",
                "            // Find conversion between native font units and fontSize units",
                "            const fontSizeMult = fontSize / unitsPerEm;",
                "",
                "            // Determine appropriate value for 'normal' line height based on the font's actual metrics",
                "            // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?",
                "            const calcLineHeight = lineHeight === 'normal' ?",
                "              (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;",
                "",
                "            // Determine line height and leading adjustments",
                "            const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;",
                "            const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);",
                "            const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;",
                "            fontData = {",
                "              index: metricsByFont.size,",
                "              src: fontObj.src,",
                "              fontObj,",
                "              fontSizeMult,",
                "              unitsPerEm,",
                "              ascender: ascender * fontSizeMult,",
                "              descender: descender * fontSizeMult,",
                "              capHeight: capHeight * fontSizeMult,",
                "              xHeight: xHeight * fontSizeMult,",
                "              lineHeight: calcLineHeight,",
                "              baseline: -halfLeading - ascender * fontSizeMult, // baseline offset from top of line height",
                "              // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height",
                "              // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height",
                "              caretTop: (ascender + descender) / 2 * fontSizeMult + caretHeight / 2,",
                "              caretBottom: caretTop - caretHeight",
                "            };",
                "            metricsByFont.set(fontObj, fontData);",
                "          }",
                "          const { fontSizeMult } = fontData;",
                "",
                "          const runText = text.slice(run.start, run.end + 1);",
                "          let prevGlyphX, prevGlyphObj;",
                "          fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {",
                "            glyphX += prevRunEndX;",
                "            charIndex += run.start;",
                "            prevGlyphX = glyphX;",
                "            prevGlyphObj = glyphObj;",
                "            const char = text.charAt(charIndex);",
                "            const glyphWidth = glyphObj.advanceWidth * fontSizeMult;",
                "            const curLineCount = currentLine.count;",
                "            let nextLine;",
                "",
                "            // Calc isWhitespace and isEmpty once per glyphObj",
                "            if (!('isEmpty' in glyphObj)) {",
                "              glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);",
                "              glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);",
                "              glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);",
                "            }",
                "            if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {",
                "              renderableGlyphCount++;",
                "            }",
                "",
                "            // If a non-whitespace character overflows the max width, we need to soft-wrap",
                "            if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {",
                "              // If it's the first char after a whitespace, start a new line",
                "              if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {",
                "                nextLine = new TextLine();",
                "                lineXOffset = -glyphX;",
                "              } else {",
                "                // Back up looking for a whitespace character to wrap at",
                "                for (let i = curLineCount; i--;) {",
                "                  // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'",
                "                  if (i === 0 && overflowWrap === 'break-word') {",
                "                    nextLine = new TextLine();",
                "                    lineXOffset = -glyphX;",
                "                    break",
                "                  }",
                "                  // Found a soft break point; move all chars since it to a new line",
                "                  else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {",
                "                    nextLine = currentLine.splitAt(i + 1);",
                "                    const adjustX = nextLine.glyphAt(0).x;",
                "                    lineXOffset -= adjustX;",
                "                    for (let j = nextLine.count; j--;) {",
                "                      nextLine.glyphAt(j).x -= adjustX;",
                "                    }",
                "                    break",
                "                  }",
                "                }",
                "              }",
                "              if (nextLine) {",
                "                currentLine.isSoftWrapped = true;",
                "                currentLine = nextLine;",
                "                lines.push(currentLine);",
                "                maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width",
                "              }",
                "            }",
                "",
                "            let fly = currentLine.glyphAt(currentLine.count);",
                "            fly.glyphObj = glyphObj;",
                "            fly.x = glyphX + lineXOffset;",
                "            fly.y = glyphY;",
                "            fly.width = glyphWidth;",
                "            fly.charIndex = charIndex;",
                "            fly.fontData = fontData;",
                "",
                "            // Handle hard line breaks",
                "            if (char === '\\n') {",
                "              currentLine = new TextLine();",
                "              lines.push(currentLine);",
                "              lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;",
                "            }",
                "          });",
                "          // At the end of a run we must capture the x position as the starting point for the next run",
                "          prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;",
                "        });",
                "",
                "        // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width",
                "        let totalHeight = 0;",
                "        lines.forEach(line => {",
                "          let isTrailingWhitespace = true;",
                "          for (let i = line.count; i--;) {",
                "            const glyphInfo = line.glyphAt(i);",
                "            // omit trailing whitespace from width calculation",
                "            if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {",
                "              line.width = glyphInfo.x + glyphInfo.width;",
                "              if (line.width > maxLineWidth) {",
                "                maxLineWidth = line.width;",
                "              }",
                "              isTrailingWhitespace = false;",
                "            }",
                "            // use the tallest line height, lowest baseline, and highest cap/ex",
                "            let {lineHeight, capHeight, xHeight, baseline} = glyphInfo.fontData;",
                "            if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;",
                "            const baselineDiff = baseline - line.baseline;",
                "            if (baselineDiff < 0) { //shift all metrics down",
                "              line.baseline += baselineDiff;",
                "              line.cap += baselineDiff;",
                "              line.ex += baselineDiff;",
                "            }",
                "            // compare cap/ex based on new lowest baseline",
                "            line.cap = Math.max(line.cap, line.baseline + capHeight);",
                "            line.ex = Math.max(line.ex, line.baseline + xHeight);",
                "          }",
                "          line.baseline -= totalHeight;",
                "          line.cap -= totalHeight;",
                "          line.ex -= totalHeight;",
                "          totalHeight += line.lineHeight;",
                "        });",
                "",
                "        // Find overall position adjustments for anchoring",
                "        let anchorXOffset = 0;",
                "        let anchorYOffset = 0;",
                "        if (anchorX) {",
                "          if (typeof anchorX === 'number') {",
                "            anchorXOffset = -anchorX;",
                "          }",
                "          else if (typeof anchorX === 'string') {",
                "            anchorXOffset = -maxLineWidth * (",
                "              anchorX === 'left' ? 0 :",
                "              anchorX === 'center' ? 0.5 :",
                "              anchorX === 'right' ? 1 :",
                "              parsePercent(anchorX)",
                "            );",
                "          }",
                "        }",
                "        if (anchorY) {",
                "          if (typeof anchorY === 'number') {",
                "            anchorYOffset = -anchorY;",
                "          }",
                "          else if (typeof anchorY === 'string') {",
                "            anchorYOffset = anchorY === 'top' ? 0 :",
                "              anchorY === 'top-baseline' ? -lines[0].baseline :",
                "              anchorY === 'top-cap' ? -lines[0].cap :",
                "              anchorY === 'top-ex' ? -lines[0].ex :",
                "              anchorY === 'middle' ? totalHeight / 2 :",
                "              anchorY === 'bottom' ? totalHeight :",
                "              anchorY === 'bottom-baseline' ? lines[lines.length - 1].baseline :",
                "              parsePercent(anchorY) * totalHeight;",
                "          }",
                "        }",
                "",
                "        if (!metricsOnly) {",
                "          // Resolve bidi levels",
                "          const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);",
                "",
                "          // Process each line, applying alignment offsets, adding each glyph to the atlas, and",
                "          // collecting all renderable glyphs into a single collection.",
                "          glyphIds = new Uint16Array(renderableGlyphCount);",
                "          glyphFontIndices = new Uint8Array(renderableGlyphCount);",
                "          glyphPositions = new Float32Array(renderableGlyphCount * 2);",
                "          glyphData = {};",
                "          visibleBounds = [INF, INF, -INF, -INF];",
                "          chunkedBounds = [];",
                "          if (includeCaretPositions) {",
                "            caretPositions = new Float32Array(text.length * 4);",
                "          }",
                "          if (colorRanges) {",
                "            glyphColors = new Uint8Array(renderableGlyphCount * 3);",
                "          }",
                "          let renderableGlyphIndex = 0;",
                "          let prevCharIndex = -1;",
                "          let colorCharIndex = -1;",
                "          let chunk;",
                "          let currentColor;",
                "          lines.forEach((line, lineIndex) => {",
                "            let {count:lineGlyphCount, width:lineWidth} = line;",
                "",
                "            // Ignore empty lines",
                "            if (lineGlyphCount > 0) {",
                "              // Count trailing whitespaces, we want to ignore these for certain things",
                "              let trailingWhitespaceCount = 0;",
                "              for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {",
                "                trailingWhitespaceCount++;",
                "              }",
                "",
                "              // Apply horizontal alignment adjustments",
                "              let lineXOffset = 0;",
                "              let justifyAdjust = 0;",
                "              if (textAlign === 'center') {",
                "                lineXOffset = (maxLineWidth - lineWidth) / 2;",
                "              } else if (textAlign === 'right') {",
                "                lineXOffset = maxLineWidth - lineWidth;",
                "              } else if (textAlign === 'justify' && line.isSoftWrapped) {",
                "                // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop",
                "                let whitespaceCount = 0;",
                "                for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {",
                "                  if (line.glyphAt(i).glyphObj.isWhitespace) {",
                "                    whitespaceCount++;",
                "                  }",
                "                }",
                "                justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;",
                "              }",
                "              if (justifyAdjust || lineXOffset) {",
                "                let justifyOffset = 0;",
                "                for (let i = 0; i < lineGlyphCount; i++) {",
                "                  let glyphInfo = line.glyphAt(i);",
                "                  const glyphObj = glyphInfo.glyphObj;",
                "                  glyphInfo.x += lineXOffset + justifyOffset;",
                "                  // Expand non-trailing whitespaces for justify alignment",
                "                  if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {",
                "                    justifyOffset += justifyAdjust;",
                "                    glyphInfo.width += justifyAdjust;",
                "                  }",
                "                }",
                "              }",
                "",
                "              // Perform bidi range flipping",
                "              const flips = bidi.getReorderSegments(",
                "                text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex",
                "              );",
                "              for (let fi = 0; fi < flips.length; fi++) {",
                "                const [start, end] = flips[fi];",
                "                // Map start/end string indices to indices in the line",
                "                let left = Infinity, right = -Infinity;",
                "                for (let i = 0; i < lineGlyphCount; i++) {",
                "                  if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters",
                "                    let startInLine = i, endInLine = i;",
                "                    for (; endInLine < lineGlyphCount; endInLine++) {",
                "                      let info = line.glyphAt(endInLine);",
                "                      if (info.charIndex > end) {",
                "                        break",
                "                      }",
                "                      if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width",
                "                        left = Math.min(left, info.x);",
                "                        right = Math.max(right, info.x + info.width);",
                "                      }",
                "                    }",
                "                    for (let j = startInLine; j < endInLine; j++) {",
                "                      const glyphInfo = line.glyphAt(j);",
                "                      glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);",
                "                    }",
                "                    break",
                "                  }",
                "                }",
                "              }",
                "",
                "              // Assemble final data arrays",
                "              let glyphObj;",
                "              const setGlyphObj = g => glyphObj = g;",
                "              for (let i = 0; i < lineGlyphCount; i++) {",
                "                const glyphInfo = line.glyphAt(i);",
                "                glyphObj = glyphInfo.glyphObj;",
                "                const glyphId = glyphObj.index;",
                "",
                "                // Replace mirrored characters in rtl",
                "                const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl",
                "                if (rtl) {",
                "                  const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);",
                "                  if (mirrored) {",
                "                    glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);",
                "                  }",
                "                }",
                "",
                "                // Add caret positions",
                "                if (includeCaretPositions) {",
                "                  const {charIndex, fontData} = glyphInfo;",
                "                  const caretLeft = glyphInfo.x + anchorXOffset;",
                "                  const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;",
                "                  caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x",
                "                  caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x",
                "                  caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y",
                "                  caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y",
                "",
                "                  // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret",
                "                  // positions for those missing char indices; currently this uses a best-guess by dividing",
                "                  // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList",
                "                  // table to get better interior caret positions.",
                "                  const ligCount = charIndex - prevCharIndex;",
                "                  if (ligCount > 1) {",
                "                    fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);",
                "                  }",
                "                  prevCharIndex = charIndex;",
                "                }",
                "",
                "                // Track current color range",
                "                if (colorRanges) {",
                "                  const {charIndex} = glyphInfo;",
                "                  while(charIndex > colorCharIndex) {",
                "                    colorCharIndex++;",
                "                    if (colorRanges.hasOwnProperty(colorCharIndex)) {",
                "                      currentColor = colorRanges[colorCharIndex];",
                "                    }",
                "                  }",
                "                }",
                "",
                "                // Get atlas data for renderable glyphs",
                "                if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {",
                "                  const idx = renderableGlyphIndex++;",
                "                  const {fontSizeMult, src: fontSrc, index: fontIndex} = glyphInfo.fontData;",
                "",
                "                  // Add this glyph's path data",
                "                  const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});",
                "                  if (!fontGlyphData[glyphId]) {",
                "                    fontGlyphData[glyphId] = {",
                "                      path: glyphObj.path,",
                "                      pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]",
                "                    };",
                "                  }",
                "",
                "                  // Determine final glyph position and add to glyphPositions array",
                "                  const glyphX = glyphInfo.x + anchorXOffset;",
                "                  const glyphY = glyphInfo.y + line.baseline + anchorYOffset;",
                "                  glyphPositions[idx * 2] = glyphX;",
                "                  glyphPositions[idx * 2 + 1] = glyphY;",
                "",
                "                  // Track total visible bounds",
                "                  const visX0 = glyphX + glyphObj.xMin * fontSizeMult;",
                "                  const visY0 = glyphY + glyphObj.yMin * fontSizeMult;",
                "                  const visX1 = glyphX + glyphObj.xMax * fontSizeMult;",
                "                  const visY1 = glyphY + glyphObj.yMax * fontSizeMult;",
                "                  if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;",
                "                  if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;",
                "                  if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;",
                "                  if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;",
                "",
                "                  // Track bounding rects for each chunk of N glyphs",
                "                  if (idx % chunkedBoundsSize === 0) {",
                "                    chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};",
                "                    chunkedBounds.push(chunk);",
                "                  }",
                "                  chunk.end++;",
                "                  const chunkRect = chunk.rect;",
                "                  if (visX0 < chunkRect[0]) chunkRect[0] = visX0;",
                "                  if (visY0 < chunkRect[1]) chunkRect[1] = visY0;",
                "                  if (visX1 > chunkRect[2]) chunkRect[2] = visX1;",
                "                  if (visY1 > chunkRect[3]) chunkRect[3] = visY1;",
                "",
                "                  // Add to glyph ids and font indices arrays",
                "                  glyphIds[idx] = glyphId;",
                "                  glyphFontIndices[idx] = fontIndex;",
                "",
                "                  // Add colors",
                "                  if (colorRanges) {",
                "                    const start = idx * 3;",
                "                    glyphColors[start] = currentColor >> 16 & 255;",
                "                    glyphColors[start + 1] = currentColor >> 8 & 255;",
                "                    glyphColors[start + 2] = currentColor & 255;",
                "                  }",
                "                }",
                "              }",
                "            }",
                "          });",
                "",
                "          // Fill in remaining caret positions in case the final character was a ligature",
                "          if (caretPositions) {",
                "            const ligCount = text.length - prevCharIndex;",
                "            if (ligCount > 1) {",
                "              fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);",
                "            }",
                "          }",
                "        }",
                "",
                "        // Assemble final data about each font used",
                "        const fontData = [];",
                "        metricsByFont.forEach(({index, src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight}) => {",
                "          fontData[index] = {src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight};",
                "        });",
                "",
                "        // Timing stats",
                "        timings.typesetting = now() - typesetStart;",
                "",
                "        callback({",
                "          glyphIds, //id for each glyph, specific to that glyph's font",
                "          glyphFontIndices, //index into fontData for each glyph",
                "          glyphPositions, //x,y of each glyph's origin in layout",
                "          glyphData, //dict holding data about each glyph appearing in the text",
                "          fontData, //data about each font used in the text",
                "          caretPositions, //startX,endX,bottomY caret positions for each char",
                "          // caretHeight, //height of cursor from bottom to top - todo per glyph?",
                "          glyphColors, //color for each glyph, if color ranges supplied",
                "          chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs",
                "          fontSize, //calculated em height",
                "          topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline",
                "          blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight",
                "            anchorXOffset,",
                "            anchorYOffset - totalHeight,",
                "            anchorXOffset + maxLineWidth,",
                "            anchorYOffset",
                "          ],",
                "          visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds",
                "          timings",
                "        });",
                "      });",
                "    }",
                "",
                "",
                "    /**",
                "     * For a given text string and font parameters, determine the resulting block dimensions",
                "     * after wrapping for the given maxWidth.",
                "     * @param args",
                "     * @param callback",
                "     */",
                "    function measure(args, callback) {",
                "      typeset({...args, metricsOnly: true}, (result) => {",
                "        const [x0, y0, x1, y1] = result.blockBounds;",
                "        callback({",
                "          width: x1 - x0,",
                "          height: y1 - y0",
                "        });",
                "      });",
                "    }",
                "",
                "    function parsePercent(str) {",
                "      let match = str.match(/^([\\d.]+)%$/);",
                "      let pct = match ? parseFloat(match[1]) : NaN;",
                "      return isNaN(pct) ? 0 : pct / 100",
                "    }",
                "",
                "    function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {",
                "      const ligStartX = caretPositions[ligStartIndex * 4];",
                "      const ligEndX = caretPositions[ligStartIndex * 4 + 1];",
                "      const ligBottom = caretPositions[ligStartIndex * 4 + 2];",
                "      const ligTop = caretPositions[ligStartIndex * 4 + 3];",
                "      const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;",
                "      for (let i = 0; i < ligCount; i++) {",
                "        const startIndex = (ligStartIndex + i) * 4;",
                "        caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;",
                "        caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);",
                "        caretPositions[startIndex + 2] = ligBottom;",
                "        caretPositions[startIndex + 3] = ligTop;",
                "      }",
                "    }",
                "",
                "    function now() {",
                "      return (self.performance || Date).now()",
                "    }",
                "",
                "    // Array-backed structure for a single line's glyphs data",
                "    function TextLine() {",
                "      this.data = [];",
                "    }",
                "    const textLineProps = ['glyphObj', 'x', 'y', 'width', 'charIndex', 'fontData'];",
                "    TextLine.prototype = {",
                "      width: 0,",
                "      lineHeight: 0,",
                "      baseline: 0,",
                "      cap: 0,",
                "      ex: 0,",
                "      isSoftWrapped: false,",
                "      get count() {",
                "        return Math.ceil(this.data.length / textLineProps.length)",
                "      },",
                "      glyphAt(i) {",
                "        let fly = TextLine.flyweight;",
                "        fly.data = this.data;",
                "        fly.index = i;",
                "        return fly",
                "      },",
                "      splitAt(i) {",
                "        let newLine = new TextLine();",
                "        newLine.data = this.data.splice(i * textLineProps.length);",
                "        return newLine",
                "      }",
                "    };",
                "    TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {",
                "      Object.defineProperty(obj, prop, {",
                "        get() {",
                "          return this.data[this.index * textLineProps.length + i]",
                "        },",
                "        set(val) {",
                "          this.data[this.index * textLineProps.length + i] = val;",
                "        }",
                "      });",
                "      return obj",
                "    }, {data: null, index: 0});",
                "",
                "",
                "    return {",
                "      typeset,",
                "      measure,",
                "    }",
                "  }",
                "",
                "  function SDFGenerator() {",
                "  var exports = (function (exports) {",
                "",
                "    /**",
                "     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]",
                "     */",
                "    function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {",
                "      var t2 = 1 - t;",
                "      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;",
                "      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;",
                "    }",
                "",
                "    /**",
                "     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]",
                "     */",
                "    function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {",
                "      var t2 = 1 - t;",
                "      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;",
                "      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;",
                "    }",
                "",
                "    /**",
                "     * Parse a path string into its constituent line/curve commands, invoking a callback for each.",
                "     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z",
                "     * @param {function(",
                "     *   command: 'L'|'Q'|'C',",
                "     *   startX: number,",
                "     *   startY: number,",
                "     *   endX: number,",
                "     *   endY: number,",
                "     *   ctrl1X?: number,",
                "     *   ctrl1Y?: number,",
                "     *   ctrl2X?: number,",
                "     *   ctrl2Y?: number",
                "     * )} commandCallback - A callback function that will be called once for each parsed path command, passing the",
                "     *                      command identifier (only L/Q/C commands) and its numeric arguments.",
                "     */",
                "    function forEachPathCommand(pathString, commandCallback) {",
                "      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;",
                "      var match, firstX, firstY, prevX, prevY;",
                "      while ((match = segmentRE.exec(pathString))) {",
                "        var args = match[2]",
                "          .replace(/^\\s*|\\s*$/g, '')",
                "          .split(/[,\\s]+/)",
                "          .map(function (v) { return parseFloat(v); });",
                "        switch (match[1]) {",
                "          case 'M':",
                "            prevX = firstX = args[0];",
                "            prevY = firstY = args[1];",
                "            break",
                "          case 'L':",
                "            if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands",
                "              commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));",
                "            }",
                "            break",
                "          case 'Q': {",
                "            commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);",
                "            break",
                "          }",
                "          case 'C': {",
                "            commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);",
                "            break",
                "          }",
                "          case 'Z':",
                "            if (prevX !== firstX || prevY !== firstY) {",
                "              commandCallback('L', prevX, prevY, firstX, firstY);",
                "            }",
                "            break",
                "        }",
                "      }",
                "    }",
                "",
                "    /**",
                "     * Convert a path string to a series of straight line segments",
                "     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z",
                "     * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback",
                "     *        function that will be called once for every line segment",
                "     * @param {number} [curvePoints] - How many straight line segments to use when approximating a",
                "     *        bezier curve in the path. Defaults to 16.",
                "     */",
                "    function pathToLineSegments (pathString, segmentCallback, curvePoints) {",
                "      if ( curvePoints === void 0 ) curvePoints = 16;",
                "",
                "      var tempPoint = { x: 0, y: 0 };",
                "      forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {",
                "        switch (command) {",
                "          case 'L':",
                "            segmentCallback(startX, startY, endX, endY);",
                "            break",
                "          case 'Q': {",
                "            var prevCurveX = startX;",
                "            var prevCurveY = startY;",
                "            for (var i = 1; i < curvePoints; i++) {",
                "              pointOnQuadraticBezier(",
                "                startX, startY,",
                "                ctrl1X, ctrl1Y,",
                "                endX, endY,",
                "                i / (curvePoints - 1),",
                "                tempPoint",
                "              );",
                "              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);",
                "              prevCurveX = tempPoint.x;",
                "              prevCurveY = tempPoint.y;",
                "            }",
                "            break",
                "          }",
                "          case 'C': {",
                "            var prevCurveX$1 = startX;",
                "            var prevCurveY$1 = startY;",
                "            for (var i$1 = 1; i$1 < curvePoints; i$1++) {",
                "              pointOnCubicBezier(",
                "                startX, startY,",
                "                ctrl1X, ctrl1Y,",
                "                ctrl2X, ctrl2Y,",
                "                endX, endY,",
                "                i$1 / (curvePoints - 1),",
                "                tempPoint",
                "              );",
                "              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);",
                "              prevCurveX$1 = tempPoint.x;",
                "              prevCurveY$1 = tempPoint.y;",
                "            }",
                "            break",
                "          }",
                "        }",
                "      });",
                "    }",
                "",
                "    var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";",
                "",
                "    var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";",
                "",
                "    var cache = new WeakMap();",
                "",
                "    var glContextParams = {",
                "      premultipliedAlpha: false,",
                "      preserveDrawingBuffer: true,",
                "      antialias: false,",
                "      depth: false,",
                "    };",
                "",
                "    /**",
                "     * This is a little helper library for WebGL. It assists with state management for a GL context.",
                "     * It's pretty tightly wrapped to the needs of this package, not very general-purpose.",
                "     *",
                "     * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap",
                "     * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback",
                "     */",
                "    function withWebGLContext (glOrCanvas, callback) {",
                "      var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;",
                "      var wrapper = cache.get(gl);",
                "      if (!wrapper) {",
                "        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;",
                "        var extensions = {};",
                "        var programs = {};",
                "        var textures = {};",
                "        var textureUnit = -1;",
                "        var framebufferStack = [];",
                "",
                "        gl.canvas.addEventListener('webglcontextlost', function (e) {",
                "          handleContextLoss();",
                "          e.preventDefault();",
                "        }, false);",
                "",
                "        function getExtension (name) {",
                "          var ext = extensions[name];",
                "          if (!ext) {",
                "            ext = extensions[name] = gl.getExtension(name);",
                "            if (!ext) {",
                "              throw new Error((name + \" not supported\"))",
                "            }",
                "          }",
                "          return ext",
                "        }",
                "",
                "        function compileShader (src, type) {",
                "          var shader = gl.createShader(type);",
                "          gl.shaderSource(shader, src);",
                "          gl.compileShader(shader);",
                "          // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)",
                "          // if (!status && !gl.isContextLost()) {",
                "          //   throw new Error(gl.getShaderInfoLog(shader).trim())",
                "          // }",
                "          return shader",
                "        }",
                "",
                "        function withProgram (name, vert, frag, func) {",
                "          if (!programs[name]) {",
                "            var attributes = {};",
                "            var uniforms = {};",
                "            var program = gl.createProgram();",
                "            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));",
                "            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));",
                "            gl.linkProgram(program);",
                "",
                "            programs[name] = {",
                "              program: program,",
                "              transaction: function transaction (func) {",
                "                gl.useProgram(program);",
                "                func({",
                "                  setUniform: function setUniform (type, name) {",
                "                    var values = [], len = arguments.length - 2;",
                "                    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];",
                "",
                "                    var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));",
                "                    gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));",
                "                  },",
                "",
                "                  setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {",
                "                    var attr = attributes[name];",
                "                    if (!attr) {",
                "                      attr = attributes[name] = {",
                "                        buf: gl.createBuffer(), // TODO should we destroy our buffers?",
                "                        loc: gl.getAttribLocation(program, name),",
                "                        data: null",
                "                      };",
                "                    }",
                "                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);",
                "                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);",
                "                    gl.enableVertexAttribArray(attr.loc);",
                "                    if (isWebGL2) {",
                "                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);",
                "                    } else {",
                "                      getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);",
                "                    }",
                "                    if (data !== attr.data) {",
                "                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);",
                "                      attr.data = data;",
                "                    }",
                "                  }",
                "                });",
                "              }",
                "            };",
                "          }",
                "",
                "          programs[name].transaction(func);",
                "        }",
                "",
                "        function withTexture (name, func) {",
                "          textureUnit++;",
                "          try {",
                "            gl.activeTexture(gl.TEXTURE0 + textureUnit);",
                "            var texture = textures[name];",
                "            if (!texture) {",
                "              texture = textures[name] = gl.createTexture();",
                "              gl.bindTexture(gl.TEXTURE_2D, texture);",
                "              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);",
                "              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);",
                "            }",
                "            gl.bindTexture(gl.TEXTURE_2D, texture);",
                "            func(texture, textureUnit);",
                "          } finally {",
                "            textureUnit--;",
                "          }",
                "        }",
                "",
                "        function withTextureFramebuffer (texture, textureUnit, func) {",
                "          var framebuffer = gl.createFramebuffer();",
                "          framebufferStack.push(framebuffer);",
                "          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);",
                "          gl.activeTexture(gl.TEXTURE0 + textureUnit);",
                "          gl.bindTexture(gl.TEXTURE_2D, texture);",
                "          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);",
                "          try {",
                "            func(framebuffer);",
                "          } finally {",
                "            gl.deleteFramebuffer(framebuffer);",
                "            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);",
                "          }",
                "        }",
                "",
                "        function handleContextLoss () {",
                "          extensions = {};",
                "          programs = {};",
                "          textures = {};",
                "          textureUnit = -1;",
                "          framebufferStack.length = 0;",
                "        }",
                "",
                "        cache.set(gl, wrapper = {",
                "          gl: gl,",
                "          isWebGL2: isWebGL2,",
                "          getExtension: getExtension,",
                "          withProgram: withProgram,",
                "          withTexture: withTexture,",
                "          withTextureFramebuffer: withTextureFramebuffer,",
                "          handleContextLoss: handleContextLoss,",
                "        });",
                "      }",
                "      callback(wrapper);",
                "    }",
                "",
                "",
                "    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {",
                "      if ( channels === void 0 ) channels = 15;",
                "      if ( framebuffer === void 0 ) framebuffer = null;",
                "",
                "      withWebGLContext(glOrCanvas, function (ref) {",
                "        var gl = ref.gl;",
                "        var withProgram = ref.withProgram;",
                "        var withTexture = ref.withTexture;",
                "",
                "        withTexture('copy', function (tex, texUnit) {",
                "          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);",
                "          withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {",
                "            var setUniform = ref.setUniform;",
                "            var setAttribute = ref.setAttribute;",
                "",
                "            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));",
                "            setUniform('1i', 'image', texUnit);",
                "            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);",
                "            gl.disable(gl.BLEND);",
                "            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);",
                "            gl.viewport(x, y, width, height);",
                "            gl.scissor(x, y, width, height);",
                "            gl.drawArrays(gl.TRIANGLES, 0, 3);",
                "          });",
                "        });",
                "      });",
                "    }",
                "",
                "    /**",
                "     * Resizing a canvas clears its contents; this utility copies the previous contents over.",
                "     * @param canvas",
                "     * @param newWidth",
                "     * @param newHeight",
                "     */",
                "    function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {",
                "      var width = canvas.width;",
                "      var height = canvas.height;",
                "      withWebGLContext(canvas, function (ref) {",
                "        var gl = ref.gl;",
                "",
                "        var data = new Uint8Array(width * height * 4);",
                "        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);",
                "        canvas.width = newWidth;",
                "        canvas.height = newHeight;",
                "        renderImageData(gl, data, 0, 0, width, height);",
                "      });",
                "    }",
                "",
                "    var webglUtils = /*#__PURE__*/Object.freeze({",
                "      __proto__: null,",
                "      withWebGLContext: withWebGLContext,",
                "      renderImageData: renderImageData,",
                "      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing",
                "    });",
                "",
                "    function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "",
                "      var textureData = new Uint8Array(sdfWidth * sdfHeight);",
                "",
                "      var viewBoxWidth = viewBox[2] - viewBox[0];",
                "      var viewBoxHeight = viewBox[3] - viewBox[1];",
                "",
                "      // Decompose all paths into straight line segments and add them to an index",
                "      var segments = [];",
                "      pathToLineSegments(path, function (x1, y1, x2, y2) {",
                "        segments.push({",
                "          x1: x1, y1: y1, x2: x2, y2: y2,",
                "          minX: Math.min(x1, x2),",
                "          minY: Math.min(y1, y2),",
                "          maxX: Math.max(x1, x2),",
                "          maxY: Math.max(y1, y2)",
                "        });",
                "      });",
                "",
                "      // Sort segments by maxX, this will let us short-circuit some loops below",
                "      segments.sort(function (a, b) { return a.maxX - b.maxX; });",
                "",
                "      // For each target SDF texel, find the distance from its center to its nearest line segment,",
                "      // map that distance to an alpha value, and write that alpha to the texel",
                "      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {",
                "        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {",
                "          var signedDist = findNearestSignedDistance(",
                "            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,",
                "            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight",
                "          );",
                "",
                "          // Use an exponential scale to ensure the texels very near the glyph path have adequate",
                "          // precision, while allowing the distance field to cover the entire texture, given that",
                "          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam",
                "          var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;",
                "          if (signedDist < 0) {",
                "            alpha = 1 - alpha;",
                "          }",
                "",
                "          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp",
                "          textureData[sdfY * sdfWidth + sdfX] = alpha;",
                "        }",
                "      }",
                "",
                "      return textureData",
                "",
                "      /**",
                "       * For a given x/y, search the index for the closest line segment and return",
                "       * its signed distance. Negative = inside, positive = outside, zero = on edge",
                "       * @param x",
                "       * @param y",
                "       * @returns {number}",
                "       */",
                "      function findNearestSignedDistance (x, y) {",
                "        var closestDistSq = Infinity;",
                "        var closestDist = Infinity;",
                "",
                "        for (var i = segments.length; i--;) {",
                "          var seg = segments[i];",
                "          if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit",
                "          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {",
                "            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);",
                "            if (distSq < closestDistSq) {",
                "              closestDistSq = distSq;",
                "              closestDist = Math.sqrt(closestDistSq);",
                "            }",
                "          }",
                "        }",
                "",
                "        // Flip to negative distance if inside the poly",
                "        if (isPointInPoly(x, y)) {",
                "          closestDist = -closestDist;",
                "        }",
                "        return closestDist",
                "      }",
                "",
                "      /**",
                "       * Determine whether the given point lies inside or outside the glyph. Uses a simple",
                "       * winding-number ray casting algorithm using a ray pointing east from the point.",
                "       */",
                "      function isPointInPoly (x, y) {",
                "        var winding = 0;",
                "        for (var i = segments.length; i--;) {",
                "          var seg = segments[i];",
                "          if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit",
                "          var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);",
                "          if (intersects) {",
                "            winding += seg.y1 < seg.y2 ? 1 : -1;",
                "          }",
                "        }",
                "        return winding !== 0",
                "      }",
                "    }",
                "",
                "    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "      if ( x === void 0 ) x = 0;",
                "      if ( y === void 0 ) y = 0;",
                "      if ( channel === void 0 ) channel = 0;",
                "",
                "      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);",
                "    }",
                "",
                "    function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "      if ( x === void 0 ) x = 0;",
                "      if ( y === void 0 ) y = 0;",
                "      if ( channel === void 0 ) channel = 0;",
                "",
                "      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);",
                "      // Expand single-channel data to rbga",
                "      var rgbaData = new Uint8Array(data.length * 4);",
                "      for (var i = 0; i < data.length; i++) {",
                "        rgbaData[i * 4 + channel] = data[i];",
                "      }",
                "      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);",
                "    }",
                "",
                "    /**",
                "     * Find the absolute distance from a point to a line segment at closest approach",
                "     */",
                "    function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {",
                "      var ldx = lineX1 - lineX0;",
                "      var ldy = lineY1 - lineY0;",
                "      var lengthSq = ldx * ldx + ldy * ldy;",
                "      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;",
                "      var dx = x - (lineX0 + t * ldx);",
                "      var dy = y - (lineY0 + t * ldy);",
                "      return dx * dx + dy * dy",
                "    }",
                "",
                "    var javascript = /*#__PURE__*/Object.freeze({",
                "      __proto__: null,",
                "      generate: generate$2,",
                "      generateIntoCanvas: generateIntoCanvas$2,",
                "      generateIntoFramebuffer: generateIntoFramebuffer$1",
                "    });",
                "",
                "    var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";",
                "",
                "    var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";",
                "",
                "    var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";",
                "",
                "    // Single triangle covering viewport",
                "    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);",
                "",
                "    var implicitContext = null;",
                "    var isTestingSupport = false;",
                "    var NULL_OBJECT = {};",
                "    var supportByCanvas = new WeakMap(); // canvas -> bool",
                "",
                "    function validateSupport (glOrCanvas) {",
                "      if (!isTestingSupport && !isSupported(glOrCanvas)) {",
                "        throw new Error('WebGL generation not supported')",
                "      }",
                "    }",
                "",
                "    function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "      if ( glOrCanvas === void 0 ) glOrCanvas = null;",
                "",
                "      if (!glOrCanvas) {",
                "        glOrCanvas = implicitContext;",
                "        if (!glOrCanvas) {",
                "          var canvas = typeof OffscreenCanvas === 'function'",
                "            ? new OffscreenCanvas(1, 1)",
                "            : typeof document !== 'undefined'",
                "              ? document.createElement('canvas')",
                "              : null;",
                "          if (!canvas) {",
                "            throw new Error('OffscreenCanvas or DOM canvas not supported')",
                "          }",
                "          glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });",
                "        }",
                "      }",
                "",
                "      validateSupport(glOrCanvas);",
                "",
                "      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari",
                "",
                "      // Render into a background texture framebuffer",
                "      withWebGLContext(glOrCanvas, function (ref) {",
                "        var gl = ref.gl;",
                "        var withTexture = ref.withTexture;",
                "        var withTextureFramebuffer = ref.withTextureFramebuffer;",
                "",
                "        withTexture('readable', function (texture, textureUnit) {",
                "          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);",
                "",
                "          withTextureFramebuffer(texture, textureUnit, function (framebuffer) {",
                "            generateIntoFramebuffer(",
                "              sdfWidth,",
                "              sdfHeight,",
                "              path,",
                "              viewBox,",
                "              maxDistance,",
                "              sdfExponent,",
                "              gl,",
                "              framebuffer,",
                "              0,",
                "              0,",
                "              0 // red channel",
                "            );",
                "            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);",
                "          });",
                "        });",
                "      });",
                "",
                "      // Throw away all but the red channel",
                "      var data = new Uint8Array(sdfWidth * sdfHeight);",
                "      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {",
                "        data[j++] = rgbaData[i];",
                "      }",
                "",
                "      return data",
                "    }",
                "",
                "    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "      if ( x === void 0 ) x = 0;",
                "      if ( y === void 0 ) y = 0;",
                "      if ( channel === void 0 ) channel = 0;",
                "",
                "      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);",
                "    }",
                "",
                "    function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "      if ( x === void 0 ) x = 0;",
                "      if ( y === void 0 ) y = 0;",
                "      if ( channel === void 0 ) channel = 0;",
                "",
                "      // Verify support",
                "      validateSupport(glOrCanvas);",
                "",
                "      // Compute path segments",
                "      var lineSegmentCoords = [];",
                "      pathToLineSegments(path, function (x1, y1, x2, y2) {",
                "        lineSegmentCoords.push(x1, y1, x2, y2);",
                "      });",
                "      lineSegmentCoords = new Float32Array(lineSegmentCoords);",
                "",
                "      withWebGLContext(glOrCanvas, function (ref) {",
                "        var gl = ref.gl;",
                "        var isWebGL2 = ref.isWebGL2;",
                "        var getExtension = ref.getExtension;",
                "        var withProgram = ref.withProgram;",
                "        var withTexture = ref.withTexture;",
                "        var withTextureFramebuffer = ref.withTextureFramebuffer;",
                "        var handleContextLoss = ref.handleContextLoss;",
                "",
                "        withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {",
                "          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {",
                "            gl.texImage2D(",
                "              gl.TEXTURE_2D, 0, gl.RGBA,",
                "              intermediateTexture._lastWidth = sdfWidth,",
                "              intermediateTexture._lastHeight = sdfHeight,",
                "              0, gl.RGBA, gl.UNSIGNED_BYTE, null",
                "            );",
                "          }",
                "",
                "          // Unsigned distance pass",
                "          withProgram('main', mainVertex, mainFragment, function (ref) {",
                "            var setAttribute = ref.setAttribute;",
                "            var setUniform = ref.setUniform;",
                "",
                "            // Init extensions",
                "            var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');",
                "            var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');",
                "",
                "            // Init/update attributes",
                "            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);",
                "            setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);",
                "",
                "            // Init/update uniforms",
                "            setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));",
                "            setUniform('1f', 'uMaxDistance', maxDistance);",
                "            setUniform('1f', 'uExponent', sdfExponent);",
                "",
                "            // Render initial unsigned distance / winding number info to a texture",
                "            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {",
                "              gl.enable(gl.BLEND);",
                "              gl.colorMask(true, true, true, true);",
                "              gl.viewport(0, 0, sdfWidth, sdfHeight);",
                "              gl.scissor(0, 0, sdfWidth, sdfHeight);",
                "              gl.blendFunc(gl.ONE, gl.ONE);",
                "              // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".",
                "              // Alpha holds the closest (MAX) unsigned distance.",
                "              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);",
                "              gl.clear(gl.COLOR_BUFFER_BIT);",
                "              if (isWebGL2) {",
                "                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);",
                "              } else {",
                "                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);",
                "              }",
                "              // Debug",
                "              // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)",
                "              // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)",
                "              // console.log('intermediate texture data: ', debug)",
                "            });",
                "          });",
                "",
                "          // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.",
                "          withProgram('post', viewportQuadVertex, postFragment, function (program) {",
                "            program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);",
                "            program.setUniform('1i', 'tex', intermediateTextureUnit);",
                "            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);",
                "            gl.disable(gl.BLEND);",
                "            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);",
                "            gl.viewport(x, y, sdfWidth, sdfHeight);",
                "            gl.scissor(x, y, sdfWidth, sdfHeight);",
                "            gl.drawArrays(gl.TRIANGLES, 0, 3);",
                "          });",
                "        });",
                "",
                "        // Handle context loss occurring during any of the above calls",
                "        if (gl.isContextLost()) {",
                "          handleContextLoss();",
                "          throw new Error('webgl context lost')",
                "        }",
                "      });",
                "    }",
                "",
                "    function isSupported (glOrCanvas) {",
                "      var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);",
                "      var supported = supportByCanvas.get(key);",
                "      if (supported === undefined) {",
                "        isTestingSupport = true;",
                "        var failReason = null;",
                "        try {",
                "          // Since we can't detect all failure modes up front, let's just do a trial run of a",
                "          // simple path and compare what we get back to the correct expected result. This will",
                "          // also serve to prime the shader compilation.",
                "          var expectedResult = [",
                "            97, 106, 97, 61,",
                "            99, 137, 118, 80,",
                "            80, 118, 137, 99,",
                "            61, 97, 106, 97",
                "          ];",
                "          var testResult = generate$1(",
                "            4,",
                "            4,",
                "            'M8,8L16,8L24,24L16,24Z',",
                "            [0, 0, 32, 32],",
                "            24,",
                "            1,",
                "            glOrCanvas",
                "          );",
                "          supported = testResult && expectedResult.length === testResult.length &&",
                "            testResult.every(function (val, i) { return val === expectedResult[i]; });",
                "          if (!supported) {",
                "            failReason = 'bad trial run results';",
                "            console.info(expectedResult, testResult);",
                "          }",
                "        } catch (err) {",
                "          // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?",
                "          supported = false;",
                "          failReason = err.message;",
                "        }",
                "        if (failReason) {",
                "          console.warn('WebGL SDF generation not supported:', failReason);",
                "        }",
                "        isTestingSupport = false;",
                "        supportByCanvas.set(key, supported);",
                "      }",
                "      return supported",
                "    }",
                "",
                "    var webgl = /*#__PURE__*/Object.freeze({",
                "      __proto__: null,",
                "      generate: generate$1,",
                "      generateIntoCanvas: generateIntoCanvas$1,",
                "      generateIntoFramebuffer: generateIntoFramebuffer,",
                "      isSupported: isSupported",
                "    });",
                "",
                "    /**",
                "     * Generate an SDF texture image for a 2D path.",
                "     *",
                "     * @param {number} sdfWidth - width of the SDF output image in pixels.",
                "     * @param {number} sdfHeight - height of the SDF output image in pixels.",
                "     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.",
                "     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.",
                "     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults",
                "     *        to half the maximum viewBox dimension.",
                "     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents",
                "     *        will give greater precision nearer the glyph's path.",
                "     * @return {Uint8Array}",
                "     */",
                "    function generate(",
                "      sdfWidth,",
                "      sdfHeight,",
                "      path,",
                "      viewBox,",
                "      maxDistance,",
                "      sdfExponent",
                "    ) {",
                "      if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "",
                "      try {",
                "        return generate$1.apply(webgl, arguments)",
                "      } catch(e) {",
                "        console.info('WebGL SDF generation failed, falling back to JS', e);",
                "        return generate$2.apply(javascript, arguments)",
                "      }",
                "    }",
                "",
                "    /**",
                "     * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position",
                "     * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels",
                "     * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.",
                "     *",
                "     * @param {number} sdfWidth - width of the SDF output image in pixels.",
                "     * @param {number} sdfHeight - height of the SDF output image in pixels.",
                "     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.",
                "     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.",
                "     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults",
                "     *        to half the maximum viewBox dimension.",
                "     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents",
                "     *        will give greater precision nearer the glyph's path.",
                "     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.",
                "     *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results",
                "     *        due to shared GL context state, this canvas should be dedicated to use by this library alone.",
                "     * @param {number} x - the x position at which to render the SDF.",
                "     * @param {number} y - the y position at which to render the SDF.",
                "     * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.",
                "     * @return {Uint8Array}",
                "     */",
                "    function generateIntoCanvas(",
                "      sdfWidth,",
                "      sdfHeight,",
                "      path,",
                "      viewBox,",
                "      maxDistance,",
                "      sdfExponent,",
                "      canvas,",
                "      x,",
                "      y,",
                "      channel",
                "    ) {",
                "      if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;",
                "      if ( sdfExponent === void 0 ) sdfExponent = 1;",
                "      if ( x === void 0 ) x = 0;",
                "      if ( y === void 0 ) y = 0;",
                "      if ( channel === void 0 ) channel = 0;",
                "",
                "      try {",
                "        return generateIntoCanvas$1.apply(webgl, arguments)",
                "      } catch(e) {",
                "        console.info('WebGL SDF generation failed, falling back to JS', e);",
                "        return generateIntoCanvas$2.apply(javascript, arguments)",
                "      }",
                "    }",
                "",
                "    exports.forEachPathCommand = forEachPathCommand;",
                "    exports.generate = generate;",
                "    exports.generateIntoCanvas = generateIntoCanvas;",
                "    exports.javascript = javascript;",
                "    exports.pathToLineSegments = pathToLineSegments;",
                "    exports.webgl = webgl;",
                "    exports.webglUtils = webglUtils;",
                "",
                "    Object.defineProperty(exports, '__esModule', { value: true });",
                "",
                "    return exports;",
                "",
                "  }({}));",
                "  return exports",
                "  }",
                "",
                "  const now = () => (self.performance || Date).now();",
                "",
                "  const mainThreadGenerator = /*#__PURE__*/ SDFGenerator();",
                "",
                "  let warned;",
                "",
                "  /**",
                "   * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a",
                "   * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF",
                "   * generation when supported.",
                "   */",
                "  function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {",
                "    // Allow opt-out",
                "    if (!useWebGL) {",
                "      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)",
                "    }",
                "",
                "    // Attempt GPU-accelerated generation first",
                "    return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(",
                "      null,",
                "      err => {",
                "        // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers",
                "        if (!warned) {",
                "          console.warn(`WebGL SDF generation failed, falling back to JS`, err);",
                "          warned = true;",
                "        }",
                "        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)",
                "      }",
                "    )",
                "  }",
                "",
                "  const queue = [];",
                "  const chunkTimeBudget = 5; // ms",
                "  let timer = 0;",
                "",
                "  function nextChunk() {",
                "    const start = now();",
                "    while (queue.length && now() - start < chunkTimeBudget) {",
                "      queue.shift()();",
                "    }",
                "    timer = queue.length ? setTimeout(nextChunk, 0) : 0;",
                "  }",
                "",
                "  /**",
                "   * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded",
                "   * macrotask chunks to allow render frames to execute in between.",
                "   */",
                "  const generateSDF_GL = (...args) => {",
                "    return new Promise((resolve, reject) => {",
                "      queue.push(() => {",
                "        const start = now();",
                "        try {",
                "          mainThreadGenerator.webgl.generateIntoCanvas(...args);",
                "          resolve({ timing: now() - start });",
                "        } catch (err) {",
                "          reject(err);",
                "        }",
                "      });",
                "      if (!timer) {",
                "        timer = setTimeout(nextChunk, 0);",
                "      }",
                "    })",
                "  };",
                "",
                "  const threadCount = 4; // how many workers to spawn",
                "  const idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds",
                "  const threads = {};",
                "  let callNum = 0;",
                "",
                "  /**",
                "   * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism",
                "   */",
                "  function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {",
                "    const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);",
                "    let thread = threads[workerId];",
                "    if (!thread) {",
                "      thread = threads[workerId] = {",
                "        workerModule: defineWorkerModule({",
                "          name: workerId,",
                "          workerId,",
                "          dependencies: [",
                "            SDFGenerator,",
                "            now",
                "          ],",
                "          init(_createSDFGenerator, now) {",
                "            const generate = _createSDFGenerator().javascript.generate;",
                "            return function (...args) {",
                "              const start = now();",
                "              const textureData = generate(...args);",
                "              return {",
                "                textureData,",
                "                timing: now() - start",
                "              }",
                "            }",
                "          },",
                "          getTransferables(result) {",
                "            return [result.textureData.buffer]",
                "          }",
                "        }),",
                "        requests: 0,",
                "        idleTimer: null",
                "      };",
                "    }",
                "",
                "    thread.requests++;",
                "    clearTimeout(thread.idleTimer);",
                "    return thread.workerModule(width, height, path, viewBox, distance, exponent)",
                "      .then(({ textureData, timing }) => {",
                "        // copy result data into the canvas",
                "        const start = now();",
                "        // expand single-channel data into rgba",
                "        const imageData = new Uint8Array(textureData.length * 4);",
                "        for (let i = 0; i < textureData.length; i++) {",
                "          imageData[i * 4 + channel] = textureData[i];",
                "        }",
                "        mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));",
                "        timing += now() - start;",
                "",
                "        // clean up workers after a while",
                "        if (--thread.requests === 0) {",
                "          thread.idleTimer = setTimeout(() => { terminateWorker(workerId); }, idleTimeout);",
                "        }",
                "        return { timing }",
                "      })",
                "  }",
                "",
                "  function warmUpSDFCanvas(canvas) {",
                "    if (!canvas._warm) {",
                "      mainThreadGenerator.webgl.isSupported(canvas);",
                "      canvas._warm = true;",
                "    }",
                "  }",
                "",
                "  const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;",
                "",
                "  function bidiFactory() {",
                "  var bidi = (function (exports) {",
                "",
                "    // Bidi character types data, auto generated",
                "    var DATA = {",
                "      \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",",
                "      \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",",
                "      \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",",
                "      \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",",
                "      \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",",
                "      \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",",
                "      \"B\": \"a,3,f+2,2v,690\",",
                "      \"S\": \"9,2,k\",",
                "      \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",",
                "      \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",",
                "      \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",",
                "      \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",",
                "      \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",",
                "      \"LRO\": \"6ct\",",
                "      \"RLO\": \"6cu\",",
                "      \"LRE\": \"6cq\",",
                "      \"RLE\": \"6cr\",",
                "      \"PDF\": \"6cs\",",
                "      \"LRI\": \"6ee\",",
                "      \"RLI\": \"6ef\",",
                "      \"FSI\": \"6eg\",",
                "      \"PDI\": \"6eh\"",
                "    };",
                "",
                "    var TYPES = {};",
                "    var TYPES_TO_NAMES = {};",
                "    TYPES.L = 1; //L is the default",
                "    TYPES_TO_NAMES[1] = 'L';",
                "    Object.keys(DATA).forEach(function (type, i) {",
                "      TYPES[type] = 1 << (i + 1);",
                "      TYPES_TO_NAMES[TYPES[type]] = type;",
                "    });",
                "    Object.freeze(TYPES);",
                "",
                "    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;",
                "    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;",
                "    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;",
                "    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;",
                "    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;",
                "",
                "    var map = null;",
                "",
                "    function parseData () {",
                "      if (!map) {",
                "        //const start = performance.now()",
                "        map = new Map();",
                "        var loop = function ( type ) {",
                "          if (DATA.hasOwnProperty(type)) {",
                "            var lastCode = 0;",
                "            DATA[type].split(',').forEach(function (range) {",
                "              var ref = range.split('+');",
                "              var skip = ref[0];",
                "              var step = ref[1];",
                "              skip = parseInt(skip, 36);",
                "              step = step ? parseInt(step, 36) : 0;",
                "              map.set(lastCode += skip, TYPES[type]);",
                "              for (var i = 0; i < step; i++) {",
                "                map.set(++lastCode, TYPES[type]);",
                "              }",
                "            });",
                "          }",
                "        };",
                "",
                "        for (var type in DATA) loop( type );",
                "        //console.log(`char types parsed in ${performance.now() - start}ms`)",
                "      }",
                "    }",
                "",
                "    /**",
                "     * @param {string} char",
                "     * @return {number}",
                "     */",
                "    function getBidiCharType (char) {",
                "      parseData();",
                "      return map.get(char.codePointAt(0)) || TYPES.L",
                "    }",
                "",
                "    function getBidiCharTypeName(char) {",
                "      return TYPES_TO_NAMES[getBidiCharType(char)]",
                "    }",
                "",
                "    // Bidi bracket pairs data, auto generated",
                "    var data$1 = {",
                "      \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",",
                "      \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"",
                "    };",
                "",
                "    /**",
                "     * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or",
                "     * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object",
                "     * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.",
                "     * @param {string} encodedString",
                "     * @param {boolean} includeReverse - true if you want reverseMap in the output",
                "     * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}",
                "     */",
                "    function parseCharacterMap (encodedString, includeReverse) {",
                "      var radix = 36;",
                "      var lastCode = 0;",
                "      var map = new Map();",
                "      var reverseMap = includeReverse && new Map();",
                "      var prevPair;",
                "      encodedString.split(',').forEach(function visit(entry) {",
                "        if (entry.indexOf('+') !== -1) {",
                "          for (var i = +entry; i--;) {",
                "            visit(prevPair);",
                "          }",
                "        } else {",
                "          prevPair = entry;",
                "          var ref = entry.split('>');",
                "          var a = ref[0];",
                "          var b = ref[1];",
                "          a = String.fromCodePoint(lastCode += parseInt(a, radix));",
                "          b = String.fromCodePoint(lastCode += parseInt(b, radix));",
                "          map.set(a, b);",
                "          includeReverse && reverseMap.set(b, a);",
                "        }",
                "      });",
                "      return { map: map, reverseMap: reverseMap }",
                "    }",
                "",
                "    var openToClose, closeToOpen, canonical;",
                "",
                "    function parse$1 () {",
                "      if (!openToClose) {",
                "        //const start = performance.now()",
                "        var ref = parseCharacterMap(data$1.pairs, true);",
                "        var map = ref.map;",
                "        var reverseMap = ref.reverseMap;",
                "        openToClose = map;",
                "        closeToOpen = reverseMap;",
                "        canonical = parseCharacterMap(data$1.canonical, false).map;",
                "        //console.log(`brackets parsed in ${performance.now() - start}ms`)",
                "      }",
                "    }",
                "",
                "    function openingToClosingBracket (char) {",
                "      parse$1();",
                "      return openToClose.get(char) || null",
                "    }",
                "",
                "    function closingToOpeningBracket (char) {",
                "      parse$1();",
                "      return closeToOpen.get(char) || null",
                "    }",
                "",
                "    function getCanonicalBracket (char) {",
                "      parse$1();",
                "      return canonical.get(char) || null",
                "    }",
                "",
                "    // Local type aliases",
                "    var TYPE_L = TYPES.L;",
                "    var TYPE_R = TYPES.R;",
                "    var TYPE_EN = TYPES.EN;",
                "    var TYPE_ES = TYPES.ES;",
                "    var TYPE_ET = TYPES.ET;",
                "    var TYPE_AN = TYPES.AN;",
                "    var TYPE_CS = TYPES.CS;",
                "    var TYPE_B = TYPES.B;",
                "    var TYPE_S = TYPES.S;",
                "    var TYPE_ON = TYPES.ON;",
                "    var TYPE_BN = TYPES.BN;",
                "    var TYPE_NSM = TYPES.NSM;",
                "    var TYPE_AL = TYPES.AL;",
                "    var TYPE_LRO = TYPES.LRO;",
                "    var TYPE_RLO = TYPES.RLO;",
                "    var TYPE_LRE = TYPES.LRE;",
                "    var TYPE_RLE = TYPES.RLE;",
                "    var TYPE_PDF = TYPES.PDF;",
                "    var TYPE_LRI = TYPES.LRI;",
                "    var TYPE_RLI = TYPES.RLI;",
                "    var TYPE_FSI = TYPES.FSI;",
                "    var TYPE_PDI = TYPES.PDI;",
                "",
                "    /**",
                "     * @typedef {object} GetEmbeddingLevelsResult",
                "     * @property {{start, end, level}[]} paragraphs",
                "     * @property {Uint8Array} levels",
                "     */",
                "",
                "    /**",
                "     * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels",
                "     * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved",
                "     * base embedding level.",
                "     *",
                "     * @param {string} string - The input string",
                "     * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,",
                "     *        otherwise a direction will be chosen automatically from each paragraph's contents.",
                "     * @return {GetEmbeddingLevelsResult}",
                "     */",
                "    function getEmbeddingLevels (string, baseDirection) {",
                "      var MAX_DEPTH = 125;",
                "",
                "      // Start by mapping all characters to their unicode type, as a bitmask integer",
                "      var charTypes = new Uint32Array(string.length);",
                "      for (var i = 0; i < string.length; i++) {",
                "        charTypes[i] = getBidiCharType(string[i]);",
                "      }",
                "",
                "      var charTypeCounts = new Map(); //will be cleared at start of each paragraph",
                "      function changeCharType(i, type) {",
                "        var oldType = charTypes[i];",
                "        charTypes[i] = type;",
                "        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);",
                "        if (oldType & NEUTRAL_ISOLATE_TYPES) {",
                "          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);",
                "        }",
                "        charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);",
                "        if (type & NEUTRAL_ISOLATE_TYPES) {",
                "          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);",
                "        }",
                "      }",
                "",
                "      var embedLevels = new Uint8Array(string.length);",
                "      var isolationPairs = new Map(); //init->pdi and pdi->init",
                "",
                "      // === 3.3.1 The Paragraph Level ===",
                "      // 3.3.1 P1: Split the text into paragraphs",
                "      var paragraphs = []; // [{start, end, level}, ...]",
                "      var paragraph = null;",
                "      for (var i$1 = 0; i$1 < string.length; i$1++) {",
                "        if (!paragraph) {",
                "          paragraphs.push(paragraph = {",
                "            start: i$1,",
                "            end: string.length - 1,",
                "            // 3.3.1 P2-P3: Determine the paragraph level",
                "            level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)",
                "          });",
                "        }",
                "        if (charTypes[i$1] & TYPE_B) {",
                "          paragraph.end = i$1;",
                "          paragraph = null;",
                "        }",
                "      }",
                "",
                "      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;",
                "      var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };",
                "      var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };",
                "",
                "      // Everything from here on will operate per paragraph.",
                "      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {",
                "        paragraph = paragraphs[paraIdx];",
                "        var statusStack = [{",
                "          _level: paragraph.level,",
                "          _override: 0, //0=neutral, 1=L, 2=R",
                "          _isolate: 0 //bool",
                "        }];",
                "        var stackTop = (void 0);",
                "        var overflowIsolateCount = 0;",
                "        var overflowEmbeddingCount = 0;",
                "        var validIsolateCount = 0;",
                "        charTypeCounts.clear();",
                "",
                "        // === 3.3.2 Explicit Levels and Directions ===",
                "        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {",
                "          var charType = charTypes[i$2];",
                "          stackTop = statusStack[statusStack.length - 1];",
                "",
                "          // Set initial counts",
                "          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);",
                "          if (charType & NEUTRAL_ISOLATE_TYPES) {",
                "            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);",
                "          }",
                "",
                "          // Explicit Embeddings: 3.3.2 X2 - X3",
                "          if (charType & FORMATTING_TYPES) { //prefilter all formatters",
                "            if (charType & (TYPE_RLE | TYPE_LRE)) {",
                "              embedLevels[i$2] = stackTop._level; // 5.2",
                "              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);",
                "              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {",
                "                statusStack.push({",
                "                  _level: level,",
                "                  _override: 0,",
                "                  _isolate: 0",
                "                });",
                "              } else if (!overflowIsolateCount) {",
                "                overflowEmbeddingCount++;",
                "              }",
                "            }",
                "",
                "            // Explicit Overrides: 3.3.2 X4 - X5",
                "            else if (charType & (TYPE_RLO | TYPE_LRO)) {",
                "              embedLevels[i$2] = stackTop._level; // 5.2",
                "              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);",
                "              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {",
                "                statusStack.push({",
                "                  _level: level$1,",
                "                  _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,",
                "                  _isolate: 0",
                "                });",
                "              } else if (!overflowIsolateCount) {",
                "                overflowEmbeddingCount++;",
                "              }",
                "            }",
                "",
                "            // Isolates: 3.3.2 X5a - X5c",
                "            else if (charType & ISOLATE_INIT_TYPES) {",
                "              // X5c - FSI becomes either RLI or LRI",
                "              if (charType & TYPE_FSI) {",
                "                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;",
                "              }",
                "",
                "              embedLevels[i$2] = stackTop._level;",
                "              if (stackTop._override) {",
                "                changeCharType(i$2, stackTop._override);",
                "              }",
                "              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);",
                "              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {",
                "                validIsolateCount++;",
                "                statusStack.push({",
                "                  _level: level$2,",
                "                  _override: 0,",
                "                  _isolate: 1,",
                "                  _isolInitIndex: i$2",
                "                });",
                "              } else {",
                "                overflowIsolateCount++;",
                "              }",
                "            }",
                "",
                "            // Terminating Isolates: 3.3.2 X6a",
                "            else if (charType & TYPE_PDI) {",
                "              if (overflowIsolateCount > 0) {",
                "                overflowIsolateCount--;",
                "              } else if (validIsolateCount > 0) {",
                "                overflowEmbeddingCount = 0;",
                "                while (!statusStack[statusStack.length - 1]._isolate) {",
                "                  statusStack.pop();",
                "                }",
                "                // Add to isolation pairs bidirectional mapping:",
                "                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;",
                "                if (isolInitIndex != null) {",
                "                  isolationPairs.set(isolInitIndex, i$2);",
                "                  isolationPairs.set(i$2, isolInitIndex);",
                "                }",
                "                statusStack.pop();",
                "                validIsolateCount--;",
                "              }",
                "              stackTop = statusStack[statusStack.length - 1];",
                "              embedLevels[i$2] = stackTop._level;",
                "              if (stackTop._override) {",
                "                changeCharType(i$2, stackTop._override);",
                "              }",
                "            }",
                "",
                "",
                "            // Terminating Embeddings and Overrides: 3.3.2 X7",
                "            else if (charType & TYPE_PDF) {",
                "              if (overflowIsolateCount === 0) {",
                "                if (overflowEmbeddingCount > 0) {",
                "                  overflowEmbeddingCount--;",
                "                } else if (!stackTop._isolate && statusStack.length > 1) {",
                "                  statusStack.pop();",
                "                  stackTop = statusStack[statusStack.length - 1];",
                "                }",
                "              }",
                "              embedLevels[i$2] = stackTop._level; // 5.2",
                "            }",
                "",
                "            // End of Paragraph: 3.3.2 X8",
                "            else if (charType & TYPE_B) {",
                "              embedLevels[i$2] = paragraph.level;",
                "            }",
                "          }",
                "",
                "          // Non-formatting characters: 3.3.2 X6",
                "          else {",
                "            embedLevels[i$2] = stackTop._level;",
                "            // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage",
                "            if (stackTop._override && charType !== TYPE_BN) {",
                "              changeCharType(i$2, stackTop._override);",
                "            }",
                "          }",
                "        }",
                "",
                "        // === 3.3.3 Preparations for Implicit Processing ===",
                "",
                "        // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9",
                "        // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to",
                "        // easily ignore them all from here on out.",
                "",
                "        // 3.3.3 X10",
                "        // Compute the set of isolating run sequences as specified by BD13",
                "        var levelRuns = [];",
                "        var currentRun = null;",
                "        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {",
                "          var charType$1 = charTypes[i$3];",
                "          if (!(charType$1 & BN_LIKE_TYPES)) {",
                "            var lvl = embedLevels[i$3];",
                "            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;",
                "            var isPDI = charType$1 === TYPE_PDI;",
                "            if (currentRun && lvl === currentRun._level) {",
                "              currentRun._end = i$3;",
                "              currentRun._endsWithIsolInit = isIsolInit;",
                "            } else {",
                "              levelRuns.push(currentRun = {",
                "                _start: i$3,",
                "                _end: i$3,",
                "                _level: lvl,",
                "                _startsWithPDI: isPDI,",
                "                _endsWithIsolInit: isIsolInit",
                "              });",
                "            }",
                "          }",
                "        }",
                "        var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]",
                "        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {",
                "          var run = levelRuns[runIdx];",
                "          if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {",
                "            var seqRuns = [currentRun = run];",
                "            for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {",
                "              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {",
                "                if (levelRuns[i$4]._start === pdiIndex) {",
                "                  seqRuns.push(currentRun = levelRuns[i$4]);",
                "                  break",
                "                }",
                "              }",
                "            }",
                "            // build flat list of indices across all runs:",
                "            var seqIndices = [];",
                "            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {",
                "              var run$1 = seqRuns[i$5];",
                "              for (var j = run$1._start; j <= run$1._end; j++) {",
                "                seqIndices.push(j);",
                "              }",
                "            }",
                "            // determine the sos/eos types:",
                "            var firstLevel = embedLevels[seqIndices[0]];",
                "            var prevLevel = paragraph.level;",
                "            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {",
                "              if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2",
                "                prevLevel = embedLevels[i$6];",
                "                break",
                "              }",
                "            }",
                "            var lastIndex = seqIndices[seqIndices.length - 1];",
                "            var lastLevel = embedLevels[lastIndex];",
                "            var nextLevel = paragraph.level;",
                "            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {",
                "              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {",
                "                if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2",
                "                  nextLevel = embedLevels[i$7];",
                "                  break",
                "                }",
                "              }",
                "            }",
                "            isolatingRunSeqs.push({",
                "              _seqIndices: seqIndices,",
                "              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,",
                "              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L",
                "            });",
                "          }",
                "        }",
                "",
                "        // The next steps are done per isolating run sequence",
                "        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {",
                "          var ref = isolatingRunSeqs[seqIdx];",
                "          var seqIndices$1 = ref._seqIndices;",
                "          var sosType = ref._sosType;",
                "          var eosType = ref._eosType;",
                "          /**",
                "           * All the level runs in an isolating run sequence have the same embedding level.",
                "           * ",
                "           * DO NOT change any `embedLevels[i]` within the current scope.",
                "           */",
                "          var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;",
                "",
                "          // === 3.3.4 Resolving Weak Types ===",
                "",
                "          // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose",
                "          // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its",
                "          // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.",
                "          if (charTypeCounts.get(TYPE_NSM)) {",
                "            for (var si = 0; si < seqIndices$1.length; si++) {",
                "              var i$8 = seqIndices$1[si];",
                "              if (charTypes[i$8] & TYPE_NSM) {",
                "                var prevType = sosType;",
                "                for (var sj = si - 1; sj >= 0; sj--) {",
                "                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN",
                "                    prevType = charTypes[seqIndices$1[sj]];",
                "                    break",
                "                  }",
                "                }",
                "                changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);",
                "              }",
                "            }",
                "          }",
                "",
                "          // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)",
                "          // is found. If an AL is found, change the type of the European number to Arabic number.",
                "          if (charTypeCounts.get(TYPE_EN)) {",
                "            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {",
                "              var i$9 = seqIndices$1[si$1];",
                "              if (charTypes[i$9] & TYPE_EN) {",
                "                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {",
                "                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];",
                "                  if (prevCharType & STRONG_TYPES) {",
                "                    if (prevCharType === TYPE_AL) {",
                "                      changeCharType(i$9, TYPE_AN);",
                "                    }",
                "                    break",
                "                  }",
                "                }",
                "              }",
                "            }",
                "          }",
                "",
                "          // W3. Change all ALs to R",
                "          if (charTypeCounts.get(TYPE_AL)) {",
                "            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {",
                "              var i$10 = seqIndices$1[si$2];",
                "              if (charTypes[i$10] & TYPE_AL) {",
                "                changeCharType(i$10, TYPE_R);",
                "              }",
                "            }",
                "          }",
                "",
                "          // W4. A single European separator between two European numbers changes to a European number. A single common",
                "          // separator between two numbers of the same type changes to that type.",
                "          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {",
                "            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {",
                "              var i$11 = seqIndices$1[si$3];",
                "              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {",
                "                var prevType$1 = 0, nextType = 0;",
                "                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {",
                "                  prevType$1 = charTypes[seqIndices$1[sj$2]];",
                "                  if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2",
                "                    break",
                "                  }",
                "                }",
                "                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {",
                "                  nextType = charTypes[seqIndices$1[sj$3]];",
                "                  if (!(nextType & BN_LIKE_TYPES)) { //5.2",
                "                    break",
                "                  }",
                "                }",
                "                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {",
                "                  changeCharType(i$11, prevType$1);",
                "                }",
                "              }",
                "            }",
                "          }",
                "",
                "          // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.",
                "          if (charTypeCounts.get(TYPE_EN)) {",
                "            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {",
                "              var i$12 = seqIndices$1[si$4];",
                "              if (charTypes[i$12] & TYPE_EN) {",
                "                for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {",
                "                  changeCharType(seqIndices$1[sj$4], TYPE_EN);",
                "                }",
                "                for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {",
                "                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {",
                "                    changeCharType(seqIndices$1[si$4], TYPE_EN);",
                "                  }",
                "                }",
                "              }",
                "            }",
                "          }",
                "",
                "          // W6. Otherwise, separators and terminators change to Other Neutral.",
                "          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {",
                "            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {",
                "              var i$13 = seqIndices$1[si$5];",
                "              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {",
                "                changeCharType(i$13, TYPE_ON);",
                "                // 5.2 transform adjacent BNs too:",
                "                for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {",
                "                  changeCharType(seqIndices$1[sj$5], TYPE_ON);",
                "                }",
                "                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {",
                "                  changeCharType(seqIndices$1[sj$6], TYPE_ON);",
                "                }",
                "              }",
                "            }",
                "          }",
                "",
                "          // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)",
                "          // is found. If an L is found, then change the type of the European number to L.",
                "          // NOTE: implemented in single forward pass for efficiency",
                "          if (charTypeCounts.get(TYPE_EN)) {",
                "            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {",
                "              var i$14 = seqIndices$1[si$6];",
                "              var type = charTypes[i$14];",
                "              if (type & TYPE_EN) {",
                "                if (prevStrongType === TYPE_L) {",
                "                  changeCharType(i$14, TYPE_L);",
                "                }",
                "              } else if (type & STRONG_TYPES) {",
                "                prevStrongType = type;",
                "              }",
                "            }",
                "          }",
                "",
                "          // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===",
                "",
                "          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {",
                "            // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text",
                "            // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional",
                "            // types EN and AN are treated as R.",
                "            var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);",
                "            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;",
                "",
                "            // * Identify the bracket pairs in the current isolating run sequence according to BD16.",
                "            var bracketPairs = [];",
                "            {",
                "              var openerStack = [];",
                "              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {",
                "                // NOTE: for any potential bracket character we also test that it still carries a NI",
                "                // type, as that may have been changed earlier. This doesn't seem to be explicitly",
                "                // called out in the spec, but is required for passage of certain tests.",
                "                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {",
                "                  var char = string[seqIndices$1[si$7]];",
                "                  var oppositeBracket = (void 0);",
                "                  // Opening bracket",
                "                  if (openingToClosingBracket(char) !== null) {",
                "                    if (openerStack.length < 63) {",
                "                      openerStack.push({ char: char, seqIndex: si$7 });",
                "                    } else {",
                "                      break",
                "                    }",
                "                  }",
                "                  // Closing bracket",
                "                  else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {",
                "                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {",
                "                      var stackChar = openerStack[stackIdx].char;",
                "                      if (stackChar === oppositeBracket ||",
                "                        stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||",
                "                        openingToClosingBracket(getCanonicalBracket(stackChar)) === char",
                "                      ) {",
                "                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);",
                "                        openerStack.length = stackIdx; //pop the matching bracket and all following",
                "                        break",
                "                      }",
                "                    }",
                "                  }",
                "                }",
                "              }",
                "              bracketPairs.sort(function (a, b) { return a[0] - b[0]; });",
                "            }",
                "            // * For each bracket-pair element in the list of pairs of text positions",
                "            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {",
                "              var ref$1 = bracketPairs[pairIdx];",
                "              var openSeqIdx = ref$1[0];",
                "              var closeSeqIdx = ref$1[1];",
                "              // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.",
                "              // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both",
                "              // brackets in the pair to match the embedding direction.",
                "              var foundStrongType = false;",
                "              var useStrongType = 0;",
                "              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {",
                "                var i$15 = seqIndices$1[si$8];",
                "                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {",
                "                  foundStrongType = true;",
                "                  var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;",
                "                  if (lr === embedDirection) {",
                "                    useStrongType = lr;",
                "                    break",
                "                  }",
                "                }",
                "              }",
                "              // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test",
                "              // for an established context with a preceding strong type by checking backwards before the opening paired",
                "              // bracket until the first strong type (L, R, or sos) is found.",
                "              //    1. If the preceding strong type is also opposite the embedding direction, context is established, so",
                "              //    set the type for both brackets in the pair to that direction.",
                "              //    2. Otherwise set the type for both brackets in the pair to the embedding direction.",
                "              if (foundStrongType && !useStrongType) {",
                "                useStrongType = sosType;",
                "                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {",
                "                  var i$16 = seqIndices$1[si$9];",
                "                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {",
                "                    var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;",
                "                    if (lr$1 !== embedDirection) {",
                "                      useStrongType = lr$1;",
                "                    } else {",
                "                      useStrongType = embedDirection;",
                "                    }",
                "                    break",
                "                  }",
                "                }",
                "              }",
                "              if (useStrongType) {",
                "                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;",
                "                // * Any number of characters that had original bidirectional character type NSM prior to the application",
                "                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match",
                "                // the type of their preceding bracket.",
                "                if (useStrongType !== embedDirection) {",
                "                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {",
                "                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {",
                "                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {",
                "                        charTypes[seqIndices$1[si$10]] = useStrongType;",
                "                      }",
                "                      break",
                "                    }",
                "                  }",
                "                }",
                "                if (useStrongType !== embedDirection) {",
                "                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {",
                "                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {",
                "                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {",
                "                        charTypes[seqIndices$1[si$11]] = useStrongType;",
                "                      }",
                "                      break",
                "                    }",
                "                  }",
                "                }",
                "              }",
                "            }",
                "",
                "            // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the",
                "            // same direction.",
                "            // N2. Any remaining NIs take the embedding direction.",
                "            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {",
                "              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {",
                "                var niRunStart = si$12, niRunEnd = si$12;",
                "                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L",
                "                for (var si2 = si$12 - 1; si2 >= 0; si2--) {",
                "                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {",
                "                    niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs",
                "                  } else {",
                "                    prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;",
                "                    break",
                "                  }",
                "                }",
                "                var nextType$1 = eosType;",
                "                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {",
                "                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {",
                "                    niRunEnd = si2$1;",
                "                  } else {",
                "                    nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;",
                "                    break",
                "                  }",
                "                }",
                "                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {",
                "                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;",
                "                }",
                "                si$12 = niRunEnd;",
                "              }",
                "            }",
                "          }",
                "        }",
                "",
                "        // === 3.3.6 Resolving Implicit Levels ===",
                "",
                "        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {",
                "          var level$3 = embedLevels[i$17];",
                "          var type$1 = charTypes[i$17];",
                "          // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.",
                "          if (level$3 & 1) {",
                "            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {",
                "              embedLevels[i$17]++;",
                "            }",
                "          }",
                "            // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level",
                "          // and those of type AN or EN go up two levels.",
                "          else {",
                "            if (type$1 & TYPE_R) {",
                "              embedLevels[i$17]++;",
                "            } else if (type$1 & (TYPE_AN | TYPE_EN)) {",
                "              embedLevels[i$17] += 2;",
                "            }",
                "          }",
                "",
                "          // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,",
                "          // and otherwise to the base level.",
                "          if (type$1 & BN_LIKE_TYPES) {",
                "            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];",
                "          }",
                "",
                "          // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or",
                "          // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.",
                "          // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.",
                "          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {",
                "            for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {",
                "              embedLevels[j$1] = paragraph.level;",
                "            }",
                "          }",
                "        }",
                "      }",
                "",
                "      // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters",
                "      // according to section 3.4 Reordering Resolved Levels",
                "      return {",
                "        levels: embedLevels,",
                "        paragraphs: paragraphs",
                "      }",
                "",
                "      function determineAutoEmbedLevel (start, isFSI) {",
                "        // 3.3.1 P2 - P3",
                "        for (var i = start; i < string.length; i++) {",
                "          var charType = charTypes[i];",
                "          if (charType & (TYPE_R | TYPE_AL)) {",
                "            return 1",
                "          }",
                "          if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {",
                "            return 0",
                "          }",
                "          if (charType & ISOLATE_INIT_TYPES) {",
                "            var pdi = indexOfMatchingPDI(i);",
                "            i = pdi === -1 ? string.length : pdi;",
                "          }",
                "        }",
                "        return 0",
                "      }",
                "",
                "      function indexOfMatchingPDI (isolateStart) {",
                "        // 3.1.2 BD9",
                "        var isolationLevel = 1;",
                "        for (var i = isolateStart + 1; i < string.length; i++) {",
                "          var charType = charTypes[i];",
                "          if (charType & TYPE_B) {",
                "            break",
                "          }",
                "          if (charType & TYPE_PDI) {",
                "            if (--isolationLevel === 0) {",
                "              return i",
                "            }",
                "          } else if (charType & ISOLATE_INIT_TYPES) {",
                "            isolationLevel++;",
                "          }",
                "        }",
                "        return -1",
                "      }",
                "    }",
                "",
                "    // Bidi mirrored chars data, auto generated",
                "    var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";",
                "",
                "    var mirrorMap;",
                "",
                "    function parse () {",
                "      if (!mirrorMap) {",
                "        //const start = performance.now()",
                "        var ref = parseCharacterMap(data, true);",
                "        var map = ref.map;",
                "        var reverseMap = ref.reverseMap;",
                "        // Combine both maps into one",
                "        reverseMap.forEach(function (value, key) {",
                "          map.set(key, value);",
                "        });",
                "        mirrorMap = map;",
                "        //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)",
                "      }",
                "    }",
                "",
                "    function getMirroredCharacter (char) {",
                "      parse();",
                "      return mirrorMap.get(char) || null",
                "    }",
                "",
                "    /**",
                "     * Given a string and its resolved embedding levels, build a map of indices to replacement chars",
                "     * for any characters in right-to-left segments that have defined mirrored characters.",
                "     * @param string",
                "     * @param embeddingLevels",
                "     * @param [start]",
                "     * @param [end]",
                "     * @return {Map<number, string>}",
                "     */",
                "    function getMirroredCharactersMap(string, embeddingLevels, start, end) {",
                "      var strLen = string.length;",
                "      start = Math.max(0, start == null ? 0 : +start);",
                "      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);",
                "",
                "      var map = new Map();",
                "      for (var i = start; i <= end; i++) {",
                "        if (embeddingLevels[i] & 1) { //only odd (rtl) levels",
                "          var mirror = getMirroredCharacter(string[i]);",
                "          if (mirror !== null) {",
                "            map.set(i, mirror);",
                "          }",
                "        }",
                "      }",
                "      return map",
                "    }",
                "",
                "    /**",
                "     * Given a start and end denoting a single line within a string, and a set of precalculated",
                "     * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.",
                "     * @param {string} string - the full input string",
                "     * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels",
                "     * @param {number} [start] - first character in a subset of the full string",
                "     * @param {number} [end] - last character in a subset of the full string",
                "     * @return {number[][]} - the list of start/end segments that should be flipped, in order.",
                "     */",
                "    function getReorderSegments(string, embeddingLevelsResult, start, end) {",
                "      var strLen = string.length;",
                "      start = Math.max(0, start == null ? 0 : +start);",
                "      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);",
                "",
                "      var segments = [];",
                "      embeddingLevelsResult.paragraphs.forEach(function (paragraph) {",
                "        var lineStart = Math.max(start, paragraph.start);",
                "        var lineEnd = Math.min(end, paragraph.end);",
                "        if (lineStart < lineEnd) {",
                "          // Local slice for mutation",
                "          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);",
                "",
                "          // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the",
                "          // end of the line to the paragraph level.",
                "          for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {",
                "            lineLevels[i] = paragraph.level;",
                "          }",
                "",
                "          // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels",
                "          // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.",
                "          var maxLevel = paragraph.level;",
                "          var minOddLevel = Infinity;",
                "          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {",
                "            var level = lineLevels[i$1];",
                "            if (level > maxLevel) { maxLevel = level; }",
                "            if (level < minOddLevel) { minOddLevel = level | 1; }",
                "          }",
                "          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {",
                "            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {",
                "              if (lineLevels[i$2] >= lvl) {",
                "                var segStart = i$2;",
                "                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {",
                "                  i$2++;",
                "                }",
                "                if (i$2 > segStart) {",
                "                  segments.push([segStart + lineStart, i$2 + lineStart]);",
                "                }",
                "              }",
                "            }",
                "          }",
                "        }",
                "      });",
                "      return segments",
                "    }",
                "",
                "    /**",
                "     * @param {string} string",
                "     * @param {GetEmbeddingLevelsResult} embedLevelsResult",
                "     * @param {number} [start]",
                "     * @param {number} [end]",
                "     * @return {string} the new string with bidi segments reordered",
                "     */",
                "    function getReorderedString(string, embedLevelsResult, start, end) {",
                "      var indices = getReorderedIndices(string, embedLevelsResult, start, end);",
                "      var chars = [].concat( string );",
                "      indices.forEach(function (charIndex, i) {",
                "        chars[i] = (",
                "          (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null",
                "        ) || string[charIndex];",
                "      });",
                "      return chars.join('')",
                "    }",
                "",
                "    /**",
                "     * @param {string} string",
                "     * @param {GetEmbeddingLevelsResult} embedLevelsResult",
                "     * @param {number} [start]",
                "     * @param {number} [end]",
                "     * @return {number[]} an array with character indices in their new bidi order",
                "     */",
                "    function getReorderedIndices(string, embedLevelsResult, start, end) {",
                "      var segments = getReorderSegments(string, embedLevelsResult, start, end);",
                "      // Fill an array with indices",
                "      var indices = [];",
                "      for (var i = 0; i < string.length; i++) {",
                "        indices[i] = i;",
                "      }",
                "      // Reverse each segment in order",
                "      segments.forEach(function (ref) {",
                "        var start = ref[0];",
                "        var end = ref[1];",
                "",
                "        var slice = indices.slice(start, end + 1);",
                "        for (var i = slice.length; i--;) {",
                "          indices[end - i] = slice[i];",
                "        }",
                "      });",
                "      return indices",
                "    }",
                "",
                "    exports.closingToOpeningBracket = closingToOpeningBracket;",
                "    exports.getBidiCharType = getBidiCharType;",
                "    exports.getBidiCharTypeName = getBidiCharTypeName;",
                "    exports.getCanonicalBracket = getCanonicalBracket;",
                "    exports.getEmbeddingLevels = getEmbeddingLevels;",
                "    exports.getMirroredCharacter = getMirroredCharacter;",
                "    exports.getMirroredCharactersMap = getMirroredCharactersMap;",
                "    exports.getReorderSegments = getReorderSegments;",
                "    exports.getReorderedIndices = getReorderedIndices;",
                "    exports.getReorderedString = getReorderedString;",
                "    exports.openingToClosingBracket = openingToClosingBracket;",
                "",
                "    Object.defineProperty(exports, '__esModule', { value: true });",
                "",
                "    return exports;",
                "",
                "  }({}));",
                "  return bidi}",
                "",
                "  const CONFIG = {",
                "    defaultFontURL: null,",
                "    unicodeFontsURL: null,",
                "    sdfGlyphSize: 64,",
                "    sdfMargin: 1 / 16,",
                "    sdfExponent: 9,",
                "    textureWidth: 2048,",
                "  };",
                "  const tempColor = /*#__PURE__*/new THREE.Color();",
                "  let hasRequested = false;",
                "",
                "  function now$1() {",
                "    return (self.performance || Date).now()",
                "  }",
                "",
                "  /**",
                "   * Customizes the text builder configuration. This must be called prior to the first font processing",
                "   * request, and applies to all fonts.",
                "   *",
                "   * @param {String} config.defaultFontURL - The URL of the default font to use for text processing",
                "   *                 requests, in case none is specified or the specifiede font fails to load or parse.",
                "   *                 Defaults to \"Roboto Regular\" from Google Fonts.",
                "   * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver",
                "   *                 data and font files, if you don't want to use the default CDN. See",
                "   *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be",
                "   *                 configured per text instance, but this lets you do it once globally.",
                "   * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)",
                "   *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,",
                "   *                 but note that this can also be overridden per call to `getTextRenderInfo()`.",
                "   *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness",
                "   *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults",
                "   *                 to 64 which is generally a good balance of size and quality.",
                "   * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent",
                "   *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer",
                "   *                 the glyph's path, with lower precision further away. Defaults to 9.",
                "   * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's",
                "   *                 path, as a percentage of the SDF width. A larger margin increases the quality of",
                "   *                 extruded glyph outlines, but decreases the precision available for the glyph itself.",
                "   *                 Defaults to 1/16th of the glyph size.",
                "   * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to",
                "   *                 2048 which is a safe maximum texture dimension according to the stats at",
                "   *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a",
                "   *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of",
                "   *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to",
                "   *                 increase the glyph size and/or have an extraordinary number of glyphs.",
                "   */",
                "  function configureTextBuilder(config) {",
                "    if (hasRequested) {",
                "      console.warn('configureTextBuilder called after first font request; will be ignored.');",
                "    } else {",
                "      assign(CONFIG, config);",
                "    }",
                "  }",
                "",
                "  /**",
                "   * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for",
                "   * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.",
                "   *",
                "   *   {",
                "   *     [sdfGlyphSize]: {",
                "   *       glyphCount: number,",
                "   *       sdfGlyphSize: number,",
                "   *       sdfTexture: Texture,",
                "   *       sdfCanvas: HTMLCanvasElement,",
                "   *       contextLost: boolean,",
                "   *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>",
                "   *     }",
                "   *   }",
                "   */",
                "  const atlases = Object.create(null);",
                "",
                "  /**",
                "   * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.",
                "   * @property {TypesetParams} parameters - The normalized input arguments to the render call.",
                "   * @property {Texture} sdfTexture - The SDF atlas texture.",
                "   * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.",
                "   * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.",
                "   * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.",
                "   * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.",
                "   * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.",
                "   * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is",
                "   *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.",
                "   * @property {number} [caretHeight] - An appropriate height for all selection carets.",
                "   * @property {number} ascender - The font's ascender metric.",
                "   * @property {number} descender - The font's descender metric.",
                "   * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.",
                "   * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.",
                "   * @property {number} lineHeight - The final computed lineHeight measurement.",
                "   * @property {number} topBaseline - The y position of the top line's baseline.",
                "   * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;",
                "   *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is",
                "   *           equivalent to the dimensions of a block-level text element in CSS.",
                "   * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;",
                "   *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.",
                "   * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,",
                "   *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.",
                "   * @property {object} timings - Timing info for various parts of the rendering logic including SDF",
                "   *           generation, typesetting, etc.",
                "   * @frozen",
                "   */",
                "",
                "  /**",
                "   * @callback getTextRenderInfo~callback",
                "   * @param {TroikaTextRenderInfo} textRenderInfo",
                "   */",
                "",
                "  /**",
                "   * Main entry point for requesting the data needed to render a text string with given font parameters.",
                "   * This is an asynchronous call, performing most of the logic in a web worker thread.",
                "   * @param {TypesetParams} args",
                "   * @param {getTextRenderInfo~callback} callback",
                "   */",
                "  function getTextRenderInfo(args, callback) {",
                "    hasRequested = true;",
                "    args = assign({}, args);",
                "    const totalStart = now$1();",
                "",
                "    // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.",
                "    // In the future we'll allow args.font to be a list with unicode ranges too.",
                "    const { defaultFontURL } = CONFIG;",
                "    const fonts = [];",
                "    if (defaultFontURL) {",
                "      fonts.push({label: 'default', src: toAbsoluteURL(defaultFontURL)});",
                "    }",
                "    if (args.font) {",
                "      fonts.push({label: 'user', src: toAbsoluteURL(args.font)});",
                "    }",
                "    args.font = fonts;",
                "",
                "    // Normalize text to a string",
                "    args.text = '' + args.text;",
                "",
                "    args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;",
                "    args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;",
                "",
                "    // Normalize colors",
                "    if (args.colorRanges != null) {",
                "      let colors = {};",
                "      for (let key in args.colorRanges) {",
                "        if (args.colorRanges.hasOwnProperty(key)) {",
                "          let val = args.colorRanges[key];",
                "          if (typeof val !== 'number') {",
                "            val = tempColor.set(val).getHex();",
                "          }",
                "          colors[key] = val;",
                "        }",
                "      }",
                "      args.colorRanges = colors;",
                "    }",
                "",
                "    Object.freeze(args);",
                "",
                "    // Init the atlas if needed",
                "    const {textureWidth, sdfExponent} = CONFIG;",
                "    const {sdfGlyphSize} = args;",
                "    const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);",
                "    let atlas = atlases[sdfGlyphSize];",
                "    if (!atlas) {",
                "      const canvas = document.createElement('canvas');",
                "      canvas.width = textureWidth;",
                "      canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs",
                "      atlas = atlases[sdfGlyphSize] = {",
                "        glyphCount: 0,",
                "        sdfGlyphSize,",
                "        sdfCanvas: canvas,",
                "        sdfTexture: new THREE.Texture(",
                "          canvas,",
                "          undefined,",
                "          undefined,",
                "          undefined,",
                "          THREE.LinearFilter,",
                "          THREE.LinearFilter",
                "        ),",
                "        contextLost: false,",
                "        glyphsByFont: new Map()",
                "      };",
                "      atlas.sdfTexture.generateMipmaps = false;",
                "      initContextLossHandling(atlas);",
                "    }",
                "",
                "    const {sdfTexture, sdfCanvas} = atlas;",
                "",
                "    // Issue request to the typesetting engine in the worker",
                "    typesetInWorker(args).then(result => {",
                "      const {glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings} = result;",
                "      const neededSDFs = [];",
                "      const glyphBounds = new Float32Array(glyphIds.length * 4);",
                "      let boundsIdx = 0;",
                "      let positionsIdx = 0;",
                "      const quadsStart = now$1();",
                "",
                "      const fontGlyphMaps = fontData.map(font => {",
                "        let map = atlas.glyphsByFont.get(font.src);",
                "        if (!map) {",
                "          atlas.glyphsByFont.set(font.src, map = new Map());",
                "        }",
                "        return map",
                "      });",
                "",
                "      glyphIds.forEach((glyphId, i) => {",
                "        const fontIndex = glyphFontIndices[i];",
                "        const {src: fontSrc, unitsPerEm} = fontData[fontIndex];",
                "        let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);",
                "",
                "        // If this is a glyphId not seen before, add it to the atlas",
                "        if (!glyphInfo) {",
                "          const {path, pathBounds} = result.glyphData[fontSrc][glyphId];",
                "",
                "          // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.",
                "          // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain",
                "          // useful interpolated values and will be ignored anyway.",
                "          const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])",
                "            / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);",
                "",
                "          const atlasIndex = atlas.glyphCount++;",
                "          const sdfViewBox = [",
                "            pathBounds[0] - fontUnitsMargin,",
                "            pathBounds[1] - fontUnitsMargin,",
                "            pathBounds[2] + fontUnitsMargin,",
                "            pathBounds[3] + fontUnitsMargin,",
                "          ];",
                "          fontGlyphMaps[fontIndex].set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));",
                "",
                "          // Collect those that need SDF generation",
                "          neededSDFs.push(glyphInfo);",
                "        }",
                "",
                "        // Calculate bounds for renderable quads",
                "        // TODO can we get this back off the main thread?",
                "        const {sdfViewBox} = glyphInfo;",
                "        const posX = glyphPositions[positionsIdx++];",
                "        const posY = glyphPositions[positionsIdx++];",
                "        const fontSizeMult = fontSize / unitsPerEm;",
                "        glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;",
                "        glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;",
                "        glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;",
                "        glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;",
                "",
                "        // Convert glyphId to SDF index for the shader",
                "        glyphIds[i] = glyphInfo.atlasIndex;",
                "      });",
                "      timings.quads = (timings.quads || 0) + (now$1() - quadsStart);",
                "",
                "      const sdfStart = now$1();",
                "      timings.sdf = {};",
                "",
                "      // Grow the texture height by power of 2 if needed",
                "      const currentHeight = sdfCanvas.height;",
                "      const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);",
                "      const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));",
                "      if (neededHeight > currentHeight) {",
                "        // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over",
                "        console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);",
                "        resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);",
                "        // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it",
                "        sdfTexture.dispose();",
                "      }",
                "",
                "      Promise.all(neededSDFs.map(glyphInfo =>",
                "        generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {",
                "          timings.sdf[glyphInfo.atlasIndex] = timing;",
                "        })",
                "      )).then(() => {",
                "        if (neededSDFs.length && !atlas.contextLost) {",
                "          safariPre15Workaround(atlas);",
                "          sdfTexture.needsUpdate = true;",
                "        }",
                "        timings.sdfTotal = now$1() - sdfStart;",
                "        timings.total = now$1() - totalStart;",
                "        // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)",
                "",
                "        // Invoke callback with the text layout arrays and updated texture",
                "        callback(Object.freeze({",
                "          parameters: args,",
                "          sdfTexture,",
                "          sdfGlyphSize,",
                "          sdfExponent,",
                "          glyphBounds,",
                "          glyphAtlasIndices: glyphIds,",
                "          glyphColors: result.glyphColors,",
                "          caretPositions: result.caretPositions,",
                "          chunkedBounds: result.chunkedBounds,",
                "          ascender: result.ascender,",
                "          descender: result.descender,",
                "          lineHeight: result.lineHeight,",
                "          capHeight: result.capHeight,",
                "          xHeight: result.xHeight,",
                "          topBaseline: result.topBaseline,",
                "          blockBounds: result.blockBounds,",
                "          visibleBounds: result.visibleBounds,",
                "          timings: result.timings,",
                "        }));",
                "      });",
                "    });",
                "",
                "    // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is",
                "    // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets",
                "    // a head start on that process before SDFs actually start getting processed.",
                "    Promise.resolve().then(() => {",
                "      if (!atlas.contextLost) {",
                "        warmUpSDFCanvas(sdfCanvas);",
                "      }",
                "    });",
                "  }",
                "",
                "  function generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {",
                "    if (contextLost) {",
                "      // If the context is lost there's nothing we can do, just quit silently and let it",
                "      // get regenerated when the context is restored",
                "      return Promise.resolve({timing: -1})",
                "    }",
                "    const {textureWidth, sdfExponent} = CONFIG;",
                "    const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);",
                "    const squareIndex = Math.floor(atlasIndex / 4);",
                "    const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;",
                "    const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;",
                "    const channel = atlasIndex % 4;",
                "    return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)",
                "  }",
                "",
                "  function initContextLossHandling(atlas) {",
                "    const canvas = atlas.sdfCanvas;",
                "",
                "    /*",
                "    // Begin context loss simulation",
                "    if (!window.WebGLDebugUtils) {",
                "      let script = document.getElementById('WebGLDebugUtilsScript')",
                "      if (!script) {",
                "        script = document.createElement('script')",
                "        script.id = 'WebGLDebugUtils'",
                "        document.head.appendChild(script)",
                "        script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'",
                "      }",
                "      script.addEventListener('load', () => {",
                "        initContextLossHandling(atlas)",
                "      })",
                "      return",
                "    }",
                "    window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)",
                "    canvas.loseContextInNCalls(500)",
                "    canvas.addEventListener('webglcontextrestored', (event) => {",
                "      canvas.loseContextInNCalls(5000)",
                "    })",
                "    // End context loss simulation",
                "    */",
                "",
                "    canvas.addEventListener('webglcontextlost', (event) => {",
                "      console.log('Context Lost', event);",
                "      event.preventDefault();",
                "      atlas.contextLost = true;",
                "    });",
                "    canvas.addEventListener('webglcontextrestored', (event) => {",
                "      console.log('Context Restored', event);",
                "      atlas.contextLost = false;",
                "      // Regenerate all glyphs into the restored canvas:",
                "      const promises = [];",
                "      atlas.glyphsByFont.forEach(glyphMap => {",
                "        glyphMap.forEach(glyph => {",
                "          promises.push(generateGlyphSDF(glyph, atlas, true));",
                "        });",
                "      });",
                "      Promise.all(promises).then(() => {",
                "        safariPre15Workaround(atlas);",
                "        atlas.sdfTexture.needsUpdate = true;",
                "      });",
                "    });",
                "  }",
                "",
                "  /**",
                "   * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.",
                "   * This can be useful to avoid long pauses when first showing text in a scene, by preloading the",
                "   * needed fonts and glyphs up front along with other assets.",
                "   *",
                "   * @param {object} options",
                "   * @param {string} options.font - URL of the font file to preload. If not given, the default font will",
                "   *        be loaded.",
                "   * @param {string|string[]} options.characters - One or more character sequences for which to pre-",
                "   *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need",
                "   *        to specify ligature sequences in addition to their individual characters to get all",
                "   *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.",
                "   * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the",
                "   *        specified `characters`.",
                "   * @param {function} callback - A function that will be called when the preloading is complete.",
                "   */",
                "  function preloadFont({font, characters, sdfGlyphSize}, callback) {",
                "    let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;",
                "    getTextRenderInfo({ font, sdfGlyphSize, text }, callback);",
                "  }",
                "",
                "",
                "  // Local assign impl so we don't have to import troika-core",
                "  function assign(toObj, fromObj) {",
                "    for (let key in fromObj) {",
                "      if (fromObj.hasOwnProperty(key)) {",
                "        toObj[key] = fromObj[key];",
                "      }",
                "    }",
                "    return toObj",
                "  }",
                "",
                "  // Utility for making URLs absolute",
                "  let linkEl;",
                "  function toAbsoluteURL(path) {",
                "    if (!linkEl) {",
                "      linkEl = typeof document === 'undefined' ? {} : document.createElement('a');",
                "    }",
                "    linkEl.href = path;",
                "    return linkEl.href",
                "  }",
                "",
                "  /**",
                "   * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround",
                "   * where it reads the pixels out of that canvas and uploads them as a data texture instead, at",
                "   * a slight performance cost.",
                "   */",
                "  function safariPre15Workaround(atlas) {",
                "    // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers",
                "    // have supported it for a long while so any false positives should be minimal.",
                "    if (typeof createImageBitmap !== 'function') {",
                "      console.info('Safari<15: applying SDF canvas workaround');",
                "      const {sdfCanvas, sdfTexture} = atlas;",
                "      const {width, height} = sdfCanvas;",
                "      const gl = atlas.sdfCanvas.getContext('webgl');",
                "      let pixels = sdfTexture.image.data;",
                "      if (!pixels || pixels.length !== width * height * 4) {",
                "        pixels = new Uint8Array(width * height * 4);",
                "        sdfTexture.image = {width, height, data: pixels};",
                "        sdfTexture.flipY = false;",
                "        sdfTexture.isDataTexture = true;",
                "      }",
                "      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);",
                "    }",
                "  }",
                "",
                "  const typesetterWorkerModule = /*#__PURE__*/defineWorkerModule({",
                "    name: 'Typesetter',",
                "    dependencies: [",
                "      createTypesetter,",
                "      fontResolverWorkerModule,",
                "      bidiFactory,",
                "    ],",
                "    init(createTypesetter, fontResolver, bidiFactory) {",
                "      return createTypesetter(fontResolver, bidiFactory())",
                "    }",
                "  });",
                "",
                "  const typesetInWorker = /*#__PURE__*/defineWorkerModule({",
                "    name: 'Typesetter',",
                "    dependencies: [",
                "      typesetterWorkerModule,",
                "    ],",
                "    init(typesetter) {",
                "      return function(args) {",
                "        return new Promise(resolve => {",
                "          typesetter.typeset(args, resolve);",
                "        })",
                "      }",
                "    },",
                "    getTransferables(result) {",
                "      // Mark array buffers as transferable to avoid cloning during postMessage",
                "      const transferables = [];",
                "      for (let p in result) {",
                "        if (result[p] && result[p].buffer) {",
                "          transferables.push(result[p].buffer);",
                "        }",
                "      }",
                "      return transferables",
                "    }",
                "  });",
                "",
                "  function dumpSDFTextures() {",
                "    Object.keys(atlases).forEach(size => {",
                "      const canvas = atlases[size].sdfCanvas;",
                "      const {width, height} = canvas;",
                "      console.log(\"%c.\", `",
                "      background: url(${canvas.toDataURL()});",
                "      background-size: ${width}px ${height}px;",
                "      color: transparent;",
                "      font-size: 0;",
                "      line-height: ${height}px;",
                "      padding-left: ${width}px;",
                "    `);",
                "    });",
                "  }",
                "",
                "  const templateGeometries = {};",
                "",
                "  function getTemplateGeometry(detail) {",
                "    let geom = templateGeometries[detail];",
                "    if (!geom) {",
                "      // Geometry is two planes back-to-back, which will always be rendered FrontSide only but",
                "      // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.",
                "      // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials",
                "      // introduced by Three.js in r130 - see https://github.com/mrdoob/THREE.js/pull/21967",
                "      const front = new THREE.PlaneGeometry(1, 1, detail, detail);",
                "      const back = front.clone();",
                "      const frontAttrs = front.attributes;",
                "      const backAttrs = back.attributes;",
                "      const combined = new THREE.BufferGeometry();",
                "      const vertCount = frontAttrs.uv.count;",
                "      for (let i = 0; i < vertCount; i++) {",
                "        backAttrs.position.array[i * 3] *= -1; // flip position x",
                "        backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z",
                "      }",
                "      ['position', 'normal', 'uv'].forEach(name => {",
                "        combined.setAttribute(name, new THREE.Float32BufferAttribute(",
                "          [...frontAttrs[name].array, ...backAttrs[name].array],",
                "          frontAttrs[name].itemSize)",
                "        );",
                "      });",
                "      combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);",
                "      combined.translate(0.5, 0.5, 0);",
                "      geom = templateGeometries[detail] = combined;",
                "    }",
                "    return geom",
                "  }",
                "",
                "  const glyphBoundsAttrName = 'aTroikaGlyphBounds';",
                "  const glyphIndexAttrName = 'aTroikaGlyphIndex';",
                "  const glyphColorAttrName = 'aTroikaGlyphColor';",
                "",
                "  /**",
                "  @class GlyphsGeometry",
                "",
                "  A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to",
                "  render the glyphs using GPU instancing of a single quad, rather than constructing a whole",
                "  geometry with vertices, for much smaller attribute arraybuffers according to this math:",
                "",
                "    Where N = number of glyphs...",
                "",
                "    Instanced:",
                "    - position: 4 * 3",
                "    - index: 2 * 3",
                "    - normal: 4 * 3",
                "    - uv: 4 * 2",
                "    - glyph x/y bounds: N * 4",
                "    - glyph indices: N * 1",
                "    = 5N + 38",
                "",
                "    Non-instanced:",
                "    - position: N * 4 * 3",
                "    - index: N * 2 * 3",
                "    - normal: N * 4 * 3",
                "    - uv: N * 4 * 2",
                "    - glyph indices: N * 1",
                "    = 39N",
                "",
                "  A downside of this is the rare-but-possible lack of the instanced arrays extension,",
                "  which we could potentially work around with a fallback non-instanced implementation.",
                "",
                "  */",
                "  class GlyphsGeometry extends THREE.InstancedBufferGeometry {",
                "    constructor() {",
                "      super();",
                "",
                "      this.detail = 1;",
                "      this.curveRadius = 0;",
                "",
                "      // Define groups for rendering text outline as a separate pass; these will only",
                "      // be used when the `material` getter returns an array, i.e. outlineWidth > 0.",
                "      this.groups = [",
                "        {start: 0, count: Infinity, materialIndex: 0},",
                "        {start: 0, count: Infinity, materialIndex: 1}",
                "      ];",
                "",
                "      // Preallocate empty bounding objects",
                "      this.boundingSphere = new THREE.Sphere();",
                "      this.boundingBox = new THREE.Box3();",
                "    }",
                "",
                "    computeBoundingSphere () {",
                "      // No-op; we'll sync the boundingSphere proactively when needed.",
                "    }",
                "",
                "    computeBoundingBox() {",
                "      // No-op; we'll sync the boundingBox proactively when needed.",
                "    }",
                "",
                "    // Since our base geometry contains triangles for both front and back sides, we can emulate",
                "    // the \"side\" by restricting the draw range.",
                "    setSide(side) {",
                "      const verts = this.getIndex().count;",
                "      this.setDrawRange(side === THREE.BackSide ? verts / 2 : 0, side === THREE.DoubleSide ? verts : verts / 2);",
                "    }",
                "",
                "    set detail(detail) {",
                "      if (detail !== this._detail) {",
                "        this._detail = detail;",
                "        if (typeof detail !== 'number' || detail < 1) {",
                "          detail = 1;",
                "        }",
                "        let tpl = getTemplateGeometry(detail)",
                "        ;['position', 'normal', 'uv'].forEach(attr => {",
                "          this.attributes[attr] = tpl.attributes[attr].clone();",
                "        });",
                "        this.setIndex(tpl.getIndex().clone());",
                "      }",
                "    }",
                "    get detail() {",
                "      return this._detail",
                "    }",
                "",
                "    set curveRadius(r) {",
                "      if (r !== this._curveRadius) {",
                "        this._curveRadius = r;",
                "        this._updateBounds();",
                "      }",
                "    }",
                "    get curveRadius() {",
                "      return this._curveRadius",
                "    }",
                "",
                "    /**",
                "     * Update the geometry for a new set of glyphs.",
                "     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs",
                "     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1",
                "     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within",
                "     *        the SDF atlas texture.",
                "     * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs",
                "     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N",
                "     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be",
                "     *        used with `applyClipRect` to choose an optimized `instanceCount`.",
                "     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.",
                "     */",
                "    updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {",
                "      // Update the instance attributes",
                "      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);",
                "      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);",
                "      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);",
                "      this._blockBounds = blockBounds;",
                "      this._chunkedBounds = chunkedBounds;",
                "      this.instanceCount = glyphAtlasIndices.length;",
                "      this._updateBounds();",
                "    }",
                "",
                "    _updateBounds() {",
                "      const bounds = this._blockBounds;",
                "      if (bounds) {",
                "        const { curveRadius, boundingBox: bbox } = this;",
                "        if (curveRadius) {",
                "          const { PI, floor, min, max, sin, cos } = Math;",
                "          const halfPi = PI / 2;",
                "          const twoPi = PI * 2;",
                "          const absR = Math.abs(curveRadius);",
                "          const leftAngle = bounds[0] / absR;",
                "          const rightAngle = bounds[2] / absR;",
                "          const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)",
                "            ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);",
                "          const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)",
                "            ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);",
                "          const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)",
                "            ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);",
                "          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);",
                "          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);",
                "        } else {",
                "          bbox.min.set(bounds[0], bounds[1], 0);",
                "          bbox.max.set(bounds[2], bounds[3], 0);",
                "        }",
                "        bbox.getBoundingSphere(this.boundingSphere);",
                "      }",
                "    }",
                "",
                "    /**",
                "     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest",
                "     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization",
                "     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would",
                "     * be clipped anyway.",
                "     *",
                "     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting",
                "     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the",
                "     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,",
                "     * but at the expense of much larger attribute buffers (see classdoc above.)",
                "     *",
                "     * @param {Vector4} clipRect",
                "     */",
                "    applyClipRect(clipRect) {",
                "      let count = this.getAttribute(glyphIndexAttrName).count;",
                "      let chunks = this._chunkedBounds;",
                "      if (chunks) {",
                "        for (let i = chunks.length; i--;) {",
                "          count = chunks[i].end;",
                "          let rect = chunks[i].rect;",
                "          // note: both rects are l-b-r-t",
                "          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {",
                "            break",
                "          }",
                "        }",
                "      }",
                "      this.instanceCount = count;",
                "    }",
                "  }",
                "",
                "",
                "  function updateBufferAttr(geom, attrName, newArray, itemSize) {",
                "    const attr = geom.getAttribute(attrName);",
                "    if (newArray) {",
                "      // If length isn't changing, just update the attribute's array data",
                "      if (attr && attr.array.length === newArray.length) {",
                "        attr.array.set(newArray);",
                "        attr.needsUpdate = true;",
                "      } else {",
                "        geom.setAttribute(attrName, new THREE.InstancedBufferAttribute(newArray, itemSize));",
                "        // If the new attribute has a different size, we also have to (as of r117) manually clear the",
                "        // internal cached max instance count. See https://github.com/mrdoob/THREE.js/issues/19706",
                "        // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in",
                "        // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a",
                "        // different size is supported, but https://github.com/mrdoob/THREE.js/pull/17418 strongly",
                "        // implies it should be supported. It's possible we need to",
                "        delete geom._maxInstanceCount; //for r117+, could be fragile",
                "        geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like",
                "      }",
                "    } else if (attr) {",
                "      geom.deleteAttribute(attrName);",
                "    }",
                "  }",
                "",
                "  /**",
                "   * Regular expression for matching the `void main() {` opener line in GLSL.",
                "   * @type {RegExp}",
                "   */",
                "  const voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;",
                "",
                "  /**",
                "   * Recursively expands all `#include <xyz>` statements within string of shader code.",
                "   * Copied from THREE's WebGLProgram#parseIncludes for external use.",
                "   *",
                "   * @param {string} source - The GLSL source code to evaluate",
                "   * @return {string} The GLSL code with all includes expanded",
                "   */",
                "  function expandShaderIncludes( source ) {",
                "    const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;",
                "    function replace(match, include) {",
                "      let chunk = THREE.ShaderChunk[include];",
                "      return chunk ? expandShaderIncludes(chunk) : match",
                "    }",
                "    return source.replace( pattern, replace )",
                "  }",
                "",
                "  /*",
                "   * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with THREE",
                "   * versions before 0.113.0 as it was changed from Math to MathUtils in that version.",
                "   * https://github.com/mrdoob/THREE.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16",
                "   */",
                "",
                "  const _lut = [];",
                "",
                "  for (let i = 0; i < 256; i++) {",
                "    _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);",
                "  }",
                "",
                "  function generateUUID() {",
                "",
                "    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136",
                "",
                "    const d0 = Math.random() * 0xffffffff | 0;",
                "    const d1 = Math.random() * 0xffffffff | 0;",
                "    const d2 = Math.random() * 0xffffffff | 0;",
                "    const d3 = Math.random() * 0xffffffff | 0;",
                "    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +",
                "      _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +",
                "      _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +",
                "      _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];",
                "",
                "    // .toUpperCase() here flattens concatenated strings to save heap memory space.",
                "    return uuid.toUpperCase()",
                "",
                "  }",
                "",
                "  // Local assign polyfill to avoid importing troika-core",
                "  const assign$1 = Object.assign || function(/*target, ...sources*/) {",
                "    let target = arguments[0];",
                "    for (let i = 1, len = arguments.length; i < len; i++) {",
                "      let source = arguments[i];",
                "      if (source) {",
                "        for (let prop in source) {",
                "          if (Object.prototype.hasOwnProperty.call(source, prop)) {",
                "            target[prop] = source[prop];",
                "          }",
                "        }",
                "      }",
                "    }",
                "    return target",
                "  };",
                "",
                "",
                "  const epoch = Date.now();",
                "  const CONSTRUCTOR_CACHE = new WeakMap();",
                "  const SHADER_UPGRADE_CACHE = new Map();",
                "",
                "  // Material ids must be integers, but we can't access the increment from Three's `Material` module,",
                "  // so let's choose a sufficiently large starting value that should theoretically never collide.",
                "  let materialInstanceId = 1e10;",
                "",
                "  /**",
                "   * A utility for creating a custom shader material derived from another material's",
                "   * shaders. This allows you to inject custom shader logic and transforms into the",
                "   * builtin ThreeJS materials without having to recreate them from scratch.",
                "   *",
                "   * @param {THREE.Material} baseMaterial - the original material to derive from",
                "   *",
                "   * @param {Object} options - How the base material should be modified.",
                "   * @param {Object} options.defines - Custom `defines` for the material",
                "   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`",
                "   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can",
                "   *        be accessed and manipulated via the resulting material's `uniforms` property, just like",
                "   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.",
                "   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into",
                "   *        both shaders, and it will automatically be updated on each render frame with a number of",
                "   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a",
                "   *        true calendar time.",
                "   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level",
                "   *        definitions, above the `void main()` function.",
                "   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex",
                "   *        shader's `void main` function.",
                "   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex",
                "   *        shader's `void main` function.",
                "   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,",
                "   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with",
                "   *        those attributes exposed by their normal names as read/write values.",
                "   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level",
                "   *        definitions, above the `void main()` function.",
                "   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment",
                "   *        shader's `void main` function.",
                "   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment",
                "   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes",
                "   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you",
                "   *        want those to apply to your changes use `fragmentColorTransform` instead.",
                "   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`",
                "   *        output value. Will be injected near the end of the `void main` function, but before any",
                "   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the",
                "   *        `fragmentMainOutro`.",
                "   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function",
                "   *        for performing custom rewrites of the full shader code. Useful if you need to do something",
                "   *        special that's not covered by the other builtin options. This function will be executed before",
                "   *        any other transforms are applied.",
                "   * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base",
                "   *        material, rather than the default behavior of copying it. This allows the derived material to",
                "   *        automatically pick up changes made to the base material and its properties. This can be useful",
                "   *        where the derived material is hidden from the user as an implementation detail, allowing them",
                "   *        to work with the original material like normal. But it can result in unexpected behavior if not",
                "   *        handled carefully.",
                "   *",
                "   * @return {THREE.Material}",
                "   *",
                "   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,",
                "   * which can be called to get a variant of the derived material for use in shadow casting. If the",
                "   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`",
                "   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to",
                "   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These",
                "   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look",
                "   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance",
                "   * scenarios, e.g. skipping antialiasing or expensive shader logic.",
                "   */",
                "  function createDerivedMaterial(baseMaterial, options) {",
                "    // Generate a key that is unique to the content of these `options`. We'll use this",
                "    // throughout for caching and for generating the upgraded shader code. This increases",
                "    // the likelihood that the resulting shaders will line up across multiple calls so",
                "    // their GL programs can be shared and cached.",
                "    const optionsKey = getKeyForOptions(options);",
                "",
                "    // First check to see if we've already derived from this baseMaterial using this",
                "    // unique set of options, and if so reuse the constructor to avoid some allocations.",
                "    let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);",
                "    if (!ctorsByDerivation) {",
                "      CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));",
                "    }",
                "    if (ctorsByDerivation[optionsKey]) {",
                "      return new ctorsByDerivation[optionsKey]()",
                "    }",
                "",
                "    const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;",
                "",
                "    // Private onBeforeCompile handler that injects the modified shaders and uniforms when",
                "    // the renderer switches to this material's program",
                "    const onBeforeCompile = function (shaderInfo, renderer) {",
                "      baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);",
                "",
                "      // Upgrade the shaders, caching the result by incoming source code",
                "      const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;",
                "      let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];",
                "      if (!upgradedShaders) {",
                "        const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);",
                "        upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;",
                "      }",
                "",
                "      // Inject upgraded shaders and uniforms into the program",
                "      shaderInfo.vertexShader = upgradedShaders.vertexShader;",
                "      shaderInfo.fragmentShader = upgradedShaders.fragmentShader;",
                "      assign$1(shaderInfo.uniforms, this.uniforms);",
                "",
                "      // Inject auto-updating time uniform if requested",
                "      if (options.timeUniform) {",
                "        shaderInfo.uniforms[options.timeUniform] = {",
                "          get value() {return Date.now() - epoch}",
                "        };",
                "      }",
                "",
                "      // Users can still add their own handlers on top of ours",
                "      if (this[privateBeforeCompileProp]) {",
                "        this[privateBeforeCompileProp](shaderInfo);",
                "      }",
                "    };",
                "",
                "    const DerivedMaterial = function DerivedMaterial() {",
                "      return derive(options.chained ? baseMaterial : baseMaterial.clone())",
                "    };",
                "",
                "    const derive = function(base) {",
                "      // Prototype chain to the base material",
                "      const derived = Object.create(base, descriptor);",
                "",
                "      // Store the baseMaterial for reference; this is always the original even when cloning",
                "      Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });",
                "",
                "      // Needs its own ids",
                "      Object.defineProperty(derived, 'id', { value: materialInstanceId++ });",
                "      derived.uuid = generateUUID();",
                "",
                "      // Merge uniforms, defines, and extensions",
                "      derived.uniforms = assign$1({}, base.uniforms, options.uniforms);",
                "      derived.defines = assign$1({}, base.defines, options.defines);",
                "      derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material",
                "      derived.extensions = assign$1({}, base.extensions, options.extensions);",
                "",
                "      // Don't inherit EventDispatcher listeners",
                "      derived._listeners = undefined;",
                "",
                "      return derived",
                "    };",
                "",
                "    const descriptor = {",
                "      constructor: {value: DerivedMaterial},",
                "      isDerivedMaterial: {value: true},",
                "",
                "      customProgramCacheKey: {",
                "        writable: true,",
                "        configurable: true,",
                "        value: function () {",
                "          return baseMaterial.customProgramCacheKey() + '|' + optionsKey",
                "        }",
                "      },",
                "",
                "      onBeforeCompile: {",
                "        get() {",
                "          return onBeforeCompile",
                "        },",
                "        set(fn) {",
                "          this[privateBeforeCompileProp] = fn;",
                "        }",
                "      },",
                "",
                "      copy: {",
                "        writable: true,",
                "        configurable: true,",
                "        value: function (source) {",
                "          baseMaterial.copy.call(this, source);",
                "          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {",
                "            assign$1(this.extensions, source.extensions);",
                "            assign$1(this.defines, source.defines);",
                "            assign$1(this.uniforms, THREE.UniformsUtils.clone(source.uniforms));",
                "          }",
                "          return this",
                "        }",
                "      },",
                "",
                "      clone: {",
                "        writable: true,",
                "        configurable: true,",
                "        value: function () {",
                "          const newBase = new baseMaterial.constructor();",
                "          return derive(newBase).copy(this)",
                "        }",
                "      },",
                "",
                "      /**",
                "       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex",
                "       * transformations and discarded fragments.",
                "       */",
                "      getDepthMaterial: {",
                "        writable: true,",
                "        configurable: true,",
                "        value: function() {",
                "          let depthMaterial = this._depthMaterial;",
                "          if (!depthMaterial) {",
                "            depthMaterial = this._depthMaterial = createDerivedMaterial(",
                "              baseMaterial.isDerivedMaterial",
                "                ? baseMaterial.getDepthMaterial()",
                "                : new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking }),",
                "              options",
                "            );",
                "            depthMaterial.defines.IS_DEPTH_MATERIAL = '';",
                "            depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values",
                "          }",
                "          return depthMaterial",
                "        }",
                "      },",
                "",
                "      /**",
                "       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex",
                "       * transformations and discarded fragments.",
                "       */",
                "      getDistanceMaterial: {",
                "        writable: true,",
                "        configurable: true,",
                "        value: function() {",
                "          let distanceMaterial = this._distanceMaterial;",
                "          if (!distanceMaterial) {",
                "            distanceMaterial = this._distanceMaterial = createDerivedMaterial(",
                "              baseMaterial.isDerivedMaterial",
                "                ? baseMaterial.getDistanceMaterial()",
                "                : new THREE.MeshDistanceMaterial(),",
                "              options",
                "            );",
                "            distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';",
                "            distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values",
                "          }",
                "          return distanceMaterial",
                "        }",
                "      },",
                "",
                "      dispose: {",
                "        writable: true,",
                "        configurable: true,",
                "        value() {",
                "          const {_depthMaterial, _distanceMaterial} = this;",
                "          if (_depthMaterial) _depthMaterial.dispose();",
                "          if (_distanceMaterial) _distanceMaterial.dispose();",
                "          baseMaterial.dispose.call(this);",
                "        }",
                "      }",
                "    };",
                "",
                "    ctorsByDerivation[optionsKey] = DerivedMaterial;",
                "    return new DerivedMaterial()",
                "  }",
                "",
                "",
                "  function upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {",
                "    let {",
                "      vertexDefs,",
                "      vertexMainIntro,",
                "      vertexMainOutro,",
                "      vertexTransform,",
                "      fragmentDefs,",
                "      fragmentMainIntro,",
                "      fragmentMainOutro,",
                "      fragmentColorTransform,",
                "      customRewriter,",
                "      timeUniform",
                "    } = options;",
                "",
                "    vertexDefs = vertexDefs || '';",
                "    vertexMainIntro = vertexMainIntro || '';",
                "    vertexMainOutro = vertexMainOutro || '';",
                "    fragmentDefs = fragmentDefs || '';",
                "    fragmentMainIntro = fragmentMainIntro || '';",
                "    fragmentMainOutro = fragmentMainOutro || '';",
                "",
                "    // Expand includes if needed",
                "    if (vertexTransform || customRewriter) {",
                "      vertexShader = expandShaderIncludes(vertexShader);",
                "    }",
                "    if (fragmentColorTransform || customRewriter) {",
                "      // We need to be able to find postprocessing chunks after include expansion in order to",
                "      // put them after the fragmentColorTransform, so mark them with comments first. Even if",
                "      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,",
                "      // so we still mark them.",
                "      fragmentShader = fragmentShader.replace(",
                "        /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,",
                "        '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'",
                "      );",
                "      fragmentShader = expandShaderIncludes(fragmentShader);",
                "    }",
                "",
                "    // Apply custom rewriter function",
                "    if (customRewriter) {",
                "      let res = customRewriter({vertexShader, fragmentShader});",
                "      vertexShader = res.vertexShader;",
                "      fragmentShader = res.fragmentShader;",
                "    }",
                "",
                "    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract",
                "    // those and re-insert them into the outro in the correct place:",
                "    if (fragmentColorTransform) {",
                "      let postChunks = [];",
                "      fragmentShader = fragmentShader.replace(",
                "        /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines",
                "        match => {",
                "          postChunks.push(match);",
                "          return ''",
                "        }",
                "      );",
                "      fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;",
                "    }",
                "",
                "    // Inject auto-updating time uniform if requested",
                "    if (timeUniform) {",
                "      const code = `\\nuniform float ${timeUniform};\\n`;",
                "      vertexDefs = code + vertexDefs;",
                "      fragmentDefs = code + fragmentDefs;",
                "    }",
                "",
                "    // Inject a function for the vertexTransform and rename all usages of position/normal/uv",
                "    if (vertexTransform) {",
                "      // Hoist these defs to the very top so they work in other function defs",
                "      vertexShader = `vec3 troika_position_${key};",
                "vec3 troika_normal_${key};",
                "vec2 troika_uv_${key};",
                "${vertexShader}",
                "`;",
                "      vertexDefs = `${vertexDefs}",
                "void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {",
                "  ${vertexTransform}",
                "}",
                "`;",
                "      vertexMainIntro = `",
                "troika_position_${key} = vec3(position);",
                "troika_normal_${key} = vec3(normal);",
                "troika_uv_${key} = vec2(uv);",
                "troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});",
                "${vertexMainIntro}",
                "`;",
                "      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {",
                "        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`",
                "      });",
                "",
                "      // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'",
                "      // Perhaps the other textures too going forward?",
                "      if (!(material.map && material.map.channel > 0)) {",
                "        vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);",
                "      }",
                "    }",
                "",
                "    // Inject defs and intro/outro snippets",
                "    vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);",
                "    fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);",
                "",
                "    return {",
                "      vertexShader,",
                "      fragmentShader",
                "    }",
                "  }",
                "",
                "  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {",
                "    if (intro || outro || defs) {",
                "      shaderCode = shaderCode.replace(voidMainRegExp, `",
                "${defs}",
                "void troikaOrigMain${id}() {`",
                "      );",
                "      shaderCode += `",
                "void main() {",
                "  ${intro}",
                "  troikaOrigMain${id}();",
                "  ${outro}",
                "}`;",
                "    }",
                "    return shaderCode",
                "  }",
                "",
                "",
                "  function optionsJsonReplacer(key, value) {",
                "    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value",
                "  }",
                "",
                "  let _idCtr = 0;",
                "  const optionsHashesToIds = new Map();",
                "  function getKeyForOptions(options) {",
                "    const optionsHash = JSON.stringify(options, optionsJsonReplacer);",
                "    let id = optionsHashesToIds.get(optionsHash);",
                "    if (id == null) {",
                "      optionsHashesToIds.set(optionsHash, (id = ++_idCtr));",
                "    }",
                "    return id",
                "  }",
                "",
                "  // language=GLSL",
                "  const VERTEX_DEFS = `",
                "uniform vec2 uTroikaSDFTextureSize;",
                "uniform float uTroikaSDFGlyphSize;",
                "uniform vec4 uTroikaTotalBounds;",
                "uniform vec4 uTroikaClipRect;",
                "uniform mat3 uTroikaOrient;",
                "uniform bool uTroikaUseGlyphColors;",
                "uniform float uTroikaDistanceOffset;",
                "uniform float uTroikaBlurRadius;",
                "uniform vec2 uTroikaPositionOffset;",
                "uniform float uTroikaCurveRadius;",
                "attribute vec4 aTroikaGlyphBounds;",
                "attribute float aTroikaGlyphIndex;",
                "attribute vec3 aTroikaGlyphColor;",
                "varying vec2 vTroikaGlyphUV;",
                "varying vec4 vTroikaTextureUVBounds;",
                "varying float vTroikaTextureChannel;",
                "varying vec3 vTroikaGlyphColor;",
                "varying vec2 vTroikaGlyphDimensions;",
                "`;",
                "",
                "  // language=GLSL prefix=\"void main() {\" suffix=\"}\"",
                "  const VERTEX_TRANSFORM = `",
                "vec4 bounds = aTroikaGlyphBounds;",
                "bounds.xz += uTroikaPositionOffset.x;",
                "bounds.yw -= uTroikaPositionOffset.y;",
                "",
                "vec4 outlineBounds = vec4(",
                "  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,",
                "  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius",
                ");",
                "vec4 clippedBounds = vec4(",
                "  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),",
                "  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)",
                ");",
                "",
                "vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);",
                "",
                "position.xy = mix(bounds.xy, bounds.zw, clippedXY);",
                "",
                "uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);",
                "",
                "float rad = uTroikaCurveRadius;",
                "if (rad != 0.0) {",
                "  float angle = position.x / rad;",
                "  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);",
                "  normal.xz = vec2(sin(angle), cos(angle));",
                "}",
                "  ",
                "position = uTroikaOrient * position;",
                "normal = uTroikaOrient * normal;",
                "",
                "vTroikaGlyphUV = clippedXY.xy;",
                "vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);",
                "",
                "${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the",
                "  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts",
                "  on some glyphs (those in the leftmost texture column) on some systems. The exact reason",
                "  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}",
                "float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;",
                "vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;",
                "vec2 txStartUV = txUvPerSquare * vec2(",
                "  mod(floor(aTroikaGlyphIndex / 4.0), txCols),",
                "  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)",
                ");",
                "vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);",
                "vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);",
                "`;",
                "",
                "  // language=GLSL",
                "  const FRAGMENT_DEFS = `",
                "uniform sampler2D uTroikaSDFTexture;",
                "uniform vec2 uTroikaSDFTextureSize;",
                "uniform float uTroikaSDFGlyphSize;",
                "uniform float uTroikaSDFExponent;",
                "uniform float uTroikaDistanceOffset;",
                "uniform float uTroikaFillOpacity;",
                "uniform float uTroikaOutlineOpacity;",
                "uniform float uTroikaBlurRadius;",
                "uniform vec3 uTroikaStrokeColor;",
                "uniform float uTroikaStrokeWidth;",
                "uniform float uTroikaStrokeOpacity;",
                "uniform bool uTroikaSDFDebug;",
                "varying vec2 vTroikaGlyphUV;",
                "varying vec4 vTroikaTextureUVBounds;",
                "varying float vTroikaTextureChannel;",
                "varying vec2 vTroikaGlyphDimensions;",
                "",
                "float troikaSdfValueToSignedDistance(float alpha) {",
                "  // Inverse of exponential encoding in webgl-sdf-generator",
                "  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those",
                "    are linearly interpolated where the encoding is exponential. Look into improving this by rounding",
                "    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.",
                "  */}",
                "  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);",
                "  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;",
                "  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);",
                "  return signedDist;",
                "}",
                "",
                "float troikaGlyphUvToSdfValue(vec2 glyphUV) {",
                "  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);",
                "  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);",
                "  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1",
                "  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;",
                "}",
                "",
                "float troikaGlyphUvToDistance(vec2 uv) {",
                "  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));",
                "}",
                "",
                "float troikaGetAADist() {",
                "  ${''/*",
                "    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based",
                "    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes ",
                "    readability and edge crispness at all sizes and screen resolutions.",
                "  */}",
                "  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300",
                "  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;",
                "  #else",
                "  return vTroikaGlyphDimensions.x / 64.0;",
                "  #endif",
                "}",
                "",
                "float troikaGetFragDistValue() {",
                "  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);",
                "  float distance = troikaGlyphUvToDistance(clampedGlyphUV);",
                " ",
                "  // Extrapolate distance when outside bounds:",
                "  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : ",
                "    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);",
                "",
                "  ${''/* ",
                "  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...",
                "  // This has potential but currently gives very jagged extensions, maybe due to precision issues?",
                "  float uvStep = 1.0 / uTroikaSDFGlyphSize;",
                "  vec2 neighbor1UV = clampedGlyphUV + (",
                "    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :",
                "    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :",
                "    vec2(0.0)",
                "  );",
                "  vec2 neighbor2UV = clampedGlyphUV + (",
                "    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :",
                "    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :",
                "    vec2(0.0)",
                "  );",
                "  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);",
                "  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);",
                "  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);",
                "  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);",
                "  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);",
                "  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);",
                "  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;",
                "  */}",
                "",
                "  return distance;",
                "}",
                "",
                "float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {",
                "  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)",
                "  float alpha = step(-distanceOffset, -distance);",
                "  #else",
                "",
                "  float alpha = smoothstep(",
                "    distanceOffset + aaDist,",
                "    distanceOffset - aaDist,",
                "    distance",
                "  );",
                "  #endif",
                "",
                "  return alpha;",
                "}",
                "`;",
                "",
                "  // language=GLSL prefix=\"void main() {\" suffix=\"}\"",
                "  const FRAGMENT_TRANSFORM = `",
                "float aaDist = troikaGetAADist();",
                "float fragDistance = troikaGetFragDistValue();",
                "float edgeAlpha = uTroikaSDFDebug ?",
                "  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :",
                "  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));",
                "",
                "#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)",
                "vec4 fillRGBA = gl_FragColor;",
                "fillRGBA.a *= uTroikaFillOpacity;",
                "vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);",
                "if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;",
                "gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(",
                "  -uTroikaStrokeWidth - aaDist,",
                "  -uTroikaStrokeWidth + aaDist,",
                "  fragDistance",
                "));",
                "gl_FragColor.a *= edgeAlpha;",
                "#endif",
                "",
                "if (edgeAlpha == 0.0) {",
                "  discard;",
                "}",
                "`;",
                "",
                "",
                "  /**",
                "   * Create a material for rendering text, derived from a baseMaterial",
                "   */",
                "  function createTextDerivedMaterial(baseMaterial) {",
                "    const textMaterial = createDerivedMaterial(baseMaterial, {",
                "      chained: true,",
                "      extensions: {",
                "        derivatives: true",
                "      },",
                "      uniforms: {",
                "        uTroikaSDFTexture: {value: null},",
                "        uTroikaSDFTextureSize: {value: new THREE.Vector2()},",
                "        uTroikaSDFGlyphSize: {value: 0},",
                "        uTroikaSDFExponent: {value: 0},",
                "        uTroikaTotalBounds: {value: new THREE.Vector4(0,0,0,0)},",
                "        uTroikaClipRect: {value: new THREE.Vector4(0,0,0,0)},",
                "        uTroikaDistanceOffset: {value: 0},",
                "        uTroikaOutlineOpacity: {value: 0},",
                "        uTroikaFillOpacity: {value: 1},",
                "        uTroikaPositionOffset: {value: new THREE.Vector2()},",
                "        uTroikaCurveRadius: {value: 0},",
                "        uTroikaBlurRadius: {value: 0},",
                "        uTroikaStrokeWidth: {value: 0},",
                "        uTroikaStrokeColor: {value: new THREE.Color()},",
                "        uTroikaStrokeOpacity: {value: 1},",
                "        uTroikaOrient: {value: new THREE.Matrix3()},",
                "        uTroikaUseGlyphColors: {value: true},",
                "        uTroikaSDFDebug: {value: false}",
                "      },",
                "      vertexDefs: VERTEX_DEFS,",
                "      vertexTransform: VERTEX_TRANSFORM,",
                "      fragmentDefs: FRAGMENT_DEFS,",
                "      fragmentColorTransform: FRAGMENT_TRANSFORM,",
                "      customRewriter({vertexShader, fragmentShader}) {",
                "        let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;",
                "        if (uDiffuseRE.test(fragmentShader)) {",
                "          // Replace all instances of `diffuse` with our varying",
                "          fragmentShader = fragmentShader",
                "            .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')",
                "            .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');",
                "          // Make sure the vertex shader declares the uniform so we can grab it as a fallback",
                "          if (!uDiffuseRE.test(vertexShader)) {",
                "            vertexShader = vertexShader.replace(",
                "              voidMainRegExp,",
                "              'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'",
                "            );",
                "          }",
                "        }",
                "        return { vertexShader, fragmentShader }",
                "      }",
                "    });",
                "",
                "    // Force transparency - TODO is this reasonable?",
                "    textMaterial.transparent = true;",
                "",
                "    Object.defineProperties(textMaterial, {",
                "      isTroikaTextMaterial: {value: true},",
                "",
                "      // WebGLShadowMap reverses the side of the shadow material by default, which fails",
                "      // for planes, so here we force the `shadowSide` to always match the main side.",
                "      shadowSide: {",
                "        get() {",
                "          return this.side",
                "        },",
                "        set() {",
                "          //no-op",
                "        }",
                "      }",
                "    });",
                "",
                "    return textMaterial",
                "  }",
                "",
                "  const defaultMaterial = /*#__PURE__*/ new THREE.MeshBasicMaterial({",
                "    color: 0xffffff,",
                "    side: THREE.DoubleSide,",
                "    transparent: true",
                "  });",
                "  const defaultStrokeColor = 0x808080;",
                "",
                "  const tempMat4 = /*#__PURE__*/ new THREE.Matrix4();",
                "  const tempVec3a = /*#__PURE__*/ new THREE.Vector3();",
                "  const tempVec3b = /*#__PURE__*/ new THREE.Vector3();",
                "  const tempArray = [];",
                "  const origin = /*#__PURE__*/ new THREE.Vector3();",
                "  const defaultOrient = '+x+y';",
                "",
                "  function first(o) {",
                "    return Array.isArray(o) ? o[0] : o",
                "  }",
                "",
                "  let getFlatRaycastMesh = () => {",
                "    const mesh = new THREE.Mesh(",
                "      new THREE.PlaneGeometry(1, 1),",
                "      defaultMaterial",
                "    );",
                "    getFlatRaycastMesh = () => mesh;",
                "    return mesh",
                "  };",
                "  let getCurvedRaycastMesh = () => {",
                "    const mesh = new THREE.Mesh(",
                "      new THREE.PlaneGeometry(1, 1, 32, 1),",
                "      defaultMaterial",
                "    );",
                "    getCurvedRaycastMesh = () => mesh;",
                "    return mesh",
                "  };",
                "",
                "  const syncStartEvent = { type: 'syncstart' };",
                "  const syncCompleteEvent = { type: 'synccomplete' };",
                "",
                "  const SYNCABLE_PROPS = [",
                "    'font',",
                "    'fontSize',",
                "    'fontStyle',",
                "    'fontWeight',",
                "    'lang',",
                "    'letterSpacing',",
                "    'lineHeight',",
                "    'maxWidth',",
                "    'overflowWrap',",
                "    'text',",
                "    'direction',",
                "    'textAlign',",
                "    'textIndent',",
                "    'whiteSpace',",
                "    'anchorX',",
                "    'anchorY',",
                "    'colorRanges',",
                "    'sdfGlyphSize'",
                "  ];",
                "",
                "  const COPYABLE_PROPS = SYNCABLE_PROPS.concat(",
                "    'material',",
                "    'color',",
                "    'depthOffset',",
                "    'clipRect',",
                "    'curveRadius',",
                "    'orientation',",
                "    'glyphGeometryDetail'",
                "  );",
                "",
                "  /**",
                "   * @class Text",
                "   *",
                "   * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance",
                "   * fields (SDF).",
                "   */",
                "  class Text extends THREE.Mesh {",
                "    constructor() {",
                "      const geometry = new GlyphsGeometry();",
                "      super(geometry, null);",
                "",
                "      // === Text layout properties: === //",
                "",
                "      /**",
                "       * @member {string} text",
                "       * The string of text to be rendered.",
                "       */",
                "      this.text = '';",
                "",
                "      /**",
                "       * @member {number|string} anchorX",
                "       * Defines the horizontal position in the text block that should line up with the local origin.",
                "       * Can be specified as a numeric x position in local units, a string percentage of the total",
                "       * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',",
                "       * or 'right'.",
                "       */",
                "      this.anchorX = 0;",
                "",
                "      /**",
                "       * @member {number|string} anchorY",
                "       * Defines the vertical position in the text block that should line up with the local origin.",
                "       * Can be specified as a numeric y position in local units (note: down is negative y), a string",
                "       * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:",
                "       * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.",
                "       */",
                "      this.anchorY = 0;",
                "",
                "      /**",
                "       * @member {number} curveRadius",
                "       * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put",
                "       * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave",
                "       * curvature, while negative numbers put it behind the text for a convex curvature. The centerline",
                "       * will be aligned with the text's local origin; you can use `anchorX` to offset it.",
                "       *",
                "       * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane",
                "       * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.",
                "       */",
                "      this.curveRadius = 0;",
                "",
                "      /**",
                "       * @member {string} direction",
                "       * Sets the base direction for the text. The default value of \"auto\" will choose a direction based",
                "       * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.",
                "       */",
                "      this.direction = 'auto';",
                "",
                "      /**",
                "       * @member {string|null} font",
                "       * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.",
                "       * Defaults to Noto Sans.",
                "       */",
                "      this.font = null; //will use default from TextBuilder",
                "",
                "      this.unicodeFontsURL = null; //defaults to CDN",
                "",
                "      /**",
                "       * @member {number} fontSize",
                "       * The size at which to render the font in local units; corresponds to the em-box height",
                "       * of the chosen `font`.",
                "       */",
                "      this.fontSize = 0.1;",
                "",
                "      /**",
                "       * @member {number|'normal'|'bold'}",
                "       * The weight of the font. Currently only used for fallback Noto fonts.",
                "       */",
                "      this.fontWeight = 'normal';",
                "",
                "      /**",
                "       * @member {'normal'|'italic'}",
                "       * The style of the font. Currently only used for fallback Noto fonts.",
                "       */",
                "      this.fontStyle = 'normal';",
                "",
                "      /**",
                "       * @member {string|null} lang",
                "       * The language code of this text; can be used for explicitly selecting certain CJK fonts.",
                "       */",
                "      this.lang = null;",
                "",
                "        /**",
                "       * @member {number} letterSpacing",
                "       * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive",
                "       * numbers increase spacing and negative numbers decrease it.",
                "       */",
                "      this.letterSpacing = 0;",
                "",
                "      /**",
                "       * @member {number|string} lineHeight",
                "       * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'",
                "       * which chooses a reasonable height based on the chosen font's ascender/descender metrics.",
                "       */",
                "      this.lineHeight = 'normal';",
                "",
                "      /**",
                "       * @member {number} maxWidth",
                "       * The maximum width of the text block, above which text may start wrapping according to the",
                "       * `whiteSpace` and `overflowWrap` properties.",
                "       */",
                "      this.maxWidth = Infinity;",
                "",
                "      /**",
                "       * @member {string} overflowWrap",
                "       * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`",
                "       * to break at whitespace characters, or `'break-word'` to allow breaking within words.",
                "       * Defaults to `'normal'`.",
                "       */",
                "      this.overflowWrap = 'normal';",
                "",
                "      /**",
                "       * @member {string} textAlign",
                "       * The horizontal alignment of each line of text within the overall text bounding box.",
                "       */",
                "      this.textAlign = 'left';",
                "",
                "      /**",
                "       * @member {number} textIndent",
                "       * Indentation for the first character of a line; see CSS `text-indent`.",
                "       */",
                "      this.textIndent = 0;",
                "",
                "      /**",
                "       * @member {string} whiteSpace",
                "       * Defines whether text should wrap when a line reaches the `maxWidth`. Can",
                "       * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,",
                "       * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to",
                "       * manually break lines, making it behave more like `'pre-wrap'` does in CSS.",
                "       */",
                "      this.whiteSpace = 'normal';",
                "",
                "",
                "      // === Presentation properties: === //",
                "",
                "      /**",
                "       * @member {THREE.Material} material",
                "       * Defines a _base_ material to be used when rendering the text. This material will be",
                "       * automatically replaced with a material derived from it, that adds shader code to",
                "       * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.",
                "       * By default it will derive from a simple white MeshBasicMaterial, but you can use any",
                "       * of the other mesh materials to gain other features like lighting, texture maps, etc.",
                "       *",
                "       * Also see the `color` shortcut property.",
                "       */",
                "      this.material = null;",
                "",
                "      /**",
                "       * @member {string|number|THREE.Color} color",
                "       * This is a shortcut for setting the `color` of the text's material. You can use this",
                "       * if you don't want to specify a whole custom `material`. Also, if you do use a custom",
                "       * `material`, this color will only be used for this particuar Text instance, even if",
                "       * that same material instance is shared across multiple Text objects.",
                "       */",
                "      this.color = null;",
                "",
                "      /**",
                "       * @member {object|null} colorRanges",
                "       * WARNING: This API is experimental and may change.",
                "       * This allows more fine-grained control of colors for individual or ranges of characters,",
                "       * taking precedence over the material's `color`. Its format is an Object whose keys each",
                "       * define a starting character index for a range, and whose values are the color for each",
                "       * range. The color value can be a numeric hex color value, a `THREE.Color` object, or",
                "       * any of the strings accepted by `THREE.Color`.",
                "       */",
                "      this.colorRanges = null;",
                "",
                "      /**",
                "       * @member {number|string} outlineWidth",
                "       * WARNING: This API is experimental and may change.",
                "       * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.",
                "       * Can be specified as either an absolute number in local units, or as a percentage string e.g.",
                "       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means",
                "       * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.",
                "       */",
                "      this.outlineWidth = 0;",
                "",
                "      /**",
                "       * @member {string|number|THREE.Color} outlineColor",
                "       * WARNING: This API is experimental and may change.",
                "       * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.",
                "       * Defaults to black.",
                "       */",
                "      this.outlineColor = 0x000000;",
                "",
                "      /**",
                "       * @member {number} outlineOpacity",
                "       * WARNING: This API is experimental and may change.",
                "       * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.",
                "       * Defaults to `1`.",
                "       */",
                "      this.outlineOpacity = 1;",
                "",
                "      /**",
                "       * @member {number|string} outlineBlur",
                "       * WARNING: This API is experimental and may change.",
                "       * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is",
                "       * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.",
                "       * Can be specified as either an absolute number in local units, or as a percentage string e.g.",
                "       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.",
                "       */",
                "      this.outlineBlur = 0;",
                "",
                "      /**",
                "       * @member {number|string} outlineOffsetX",
                "       * WARNING: This API is experimental and may change.",
                "       * A horizontal offset for the text outline.",
                "       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`",
                "       * which is treated as a percentage of the `fontSize`. Defaults to `0`.",
                "       */",
                "      this.outlineOffsetX = 0;",
                "",
                "      /**",
                "       * @member {number|string} outlineOffsetY",
                "       * WARNING: This API is experimental and may change.",
                "       * A vertical offset for the text outline.",
                "       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`",
                "       * which is treated as a percentage of the `fontSize`. Defaults to `0`.",
                "       */",
                "      this.outlineOffsetY = 0;",
                "",
                "      /**",
                "       * @member {number|string} strokeWidth",
                "       * WARNING: This API is experimental and may change.",
                "       * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.",
                "       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`",
                "       * which is treated as a percentage of the `fontSize`. Defaults to `0`.",
                "       */",
                "      this.strokeWidth = 0;",
                "",
                "      /**",
                "       * @member {string|number|THREE.Color} strokeColor",
                "       * WARNING: This API is experimental and may change.",
                "       * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.",
                "       */",
                "      this.strokeColor = defaultStrokeColor;",
                "",
                "      /**",
                "       * @member {number} strokeOpacity",
                "       * WARNING: This API is experimental and may change.",
                "       * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.",
                "       */",
                "      this.strokeOpacity = 1;",
                "",
                "      /**",
                "       * @member {number} fillOpacity",
                "       * WARNING: This API is experimental and may change.",
                "       * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows",
                "       * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the",
                "       * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.",
                "       */",
                "      this.fillOpacity = 1;",
                "",
                "      /**",
                "       * @member {number} depthOffset",
                "       * This is a shortcut for setting the material's `polygonOffset` and related properties,",
                "       * which can be useful in preventing z-fighting when this text is laid on top of another",
                "       * plane in the scene. Positive numbers are further from the camera, negatives closer.",
                "       */",
                "      this.depthOffset = 0;",
                "",
                "      /**",
                "       * @member {Array<number>} clipRect",
                "       * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all",
                "       * pixels will be discarded. This can be used for example to clip overflowing text when",
                "       * `whiteSpace='nowrap'`.",
                "       */",
                "      this.clipRect = null;",
                "",
                "      /**",
                "       * @member {string} orientation",
                "       * Defines the axis plane on which the text should be laid out when the mesh has no extra",
                "       * rotation transform. It is specified as a string with two axes: the horizontal axis with",
                "       * positive pointing right, and the vertical axis with positive pointing up. By default this",
                "       * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y",
                "       * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's",
                "       * top toward negative z and facing positive y.",
                "       */",
                "      this.orientation = defaultOrient;",
                "",
                "      /**",
                "       * @member {number} glyphGeometryDetail",
                "       * Controls number of vertical/horizontal segments that make up each glyph's rectangular",
                "       * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom",
                "       * vertex shader effects, for example.",
                "       */",
                "      this.glyphGeometryDetail = 1;",
                "",
                "      /**",
                "       * @member {number|null} sdfGlyphSize",
                "       * The size of each glyph's SDF (signed distance field) used for rendering. This must be a",
                "       * power-of-two number. Defaults to 64 which is generally a good balance of size and quality",
                "       * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing",
                "       * the sharpness of corners and preventing loss of very thin lines, at the expense of",
                "       * increased memory footprint and longer SDF generation time.",
                "       */",
                "      this.sdfGlyphSize = null;",
                "",
                "      /**",
                "       * @member {boolean} gpuAccelerateSDF",
                "       * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,",
                "       * making it much faster especially for complex glyphs, and falling back to a JavaScript version",
                "       * executed in web workers when support isn't available. It should automatically detect support,",
                "       * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS",
                "       * version if you encounter issues with it.",
                "       */",
                "      this.gpuAccelerateSDF = true;",
                "",
                "      this.debugSDF = false;",
                "    }",
                "",
                "    /**",
                "     * Updates the text rendering according to the current text-related configuration properties.",
                "     * This is an async process, so you can pass in a callback function to be executed when it",
                "     * finishes.",
                "     * @param {function} [callback]",
                "     */",
                "    sync(callback) {",
                "      if (this._needsSync) {",
                "        this._needsSync = false;",
                "",
                "        // If there's another sync still in progress, queue",
                "        if (this._isSyncing) {",
                "          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);",
                "        } else {",
                "          this._isSyncing = true;",
                "          this.dispatchEvent(syncStartEvent);",
                "",
                "          getTextRenderInfo({",
                "            text: this.text,",
                "            font: this.font,",
                "            lang: this.lang,",
                "            fontSize: this.fontSize || 0.1,",
                "            fontWeight: this.fontWeight || 'normal',",
                "            fontStyle: this.fontStyle || 'normal',",
                "            letterSpacing: this.letterSpacing || 0,",
                "            lineHeight: this.lineHeight || 'normal',",
                "            maxWidth: this.maxWidth,",
                "            direction: this.direction || 'auto',",
                "            textAlign: this.textAlign,",
                "            textIndent: this.textIndent,",
                "            whiteSpace: this.whiteSpace,",
                "            overflowWrap: this.overflowWrap,",
                "            anchorX: this.anchorX,",
                "            anchorY: this.anchorY,",
                "            colorRanges: this.colorRanges,",
                "            includeCaretPositions: true, //TODO parameterize",
                "            sdfGlyphSize: this.sdfGlyphSize,",
                "            gpuAccelerateSDF: this.gpuAccelerateSDF,",
                "            unicodeFontsURL: this.unicodeFontsURL,",
                "          }, textRenderInfo => {",
                "            this._isSyncing = false;",
                "",
                "            // Save result for later use in onBeforeRender",
                "            this._textRenderInfo = textRenderInfo;",
                "",
                "            // Update the geometry attributes",
                "            this.geometry.updateGlyphs(",
                "              textRenderInfo.glyphBounds,",
                "              textRenderInfo.glyphAtlasIndices,",
                "              textRenderInfo.blockBounds,",
                "              textRenderInfo.chunkedBounds,",
                "              textRenderInfo.glyphColors",
                "            );",
                "",
                "            // If we had extra sync requests queued up, kick it off",
                "            const queued = this._queuedSyncs;",
                "            if (queued) {",
                "              this._queuedSyncs = null;",
                "              this._needsSync = true;",
                "              this.sync(() => {",
                "                queued.forEach(fn => fn && fn());",
                "              });",
                "            }",
                "",
                "            this.dispatchEvent(syncCompleteEvent);",
                "            if (callback) {",
                "              callback();",
                "            }",
                "          });",
                "        }",
                "      }",
                "    }",
                "",
                "    /**",
                "     * Initiate a sync if needed - note it won't complete until next frame at the",
                "     * earliest so if possible it's a good idea to call sync() manually as soon as",
                "     * all the properties have been set.",
                "     * @override",
                "     */",
                "    onBeforeRender(renderer, scene, camera, geometry, material, group) {",
                "      this.sync();",
                "",
                "      // This may not always be a text material, e.g. if there's a scene.overrideMaterial present",
                "      if (material.isTroikaTextMaterial) {",
                "        this._prepareForRender(material);",
                "      }",
                "",
                "      // We need to force the material to FrontSide to avoid the double-draw-call performance hit",
                "      // introduced in Three.js r130: https://github.com/mrdoob/THREE.js/pull/21967 - The sidedness",
                "      // is instead applied via drawRange in the GlyphsGeometry.",
                "      material._hadOwnSide = material.hasOwnProperty('side');",
                "      this.geometry.setSide(material._actualSide = material.side);",
                "      material.side = THREE.FrontSide;",
                "    }",
                "",
                "    onAfterRender(renderer, scene, camera, geometry, material, group) {",
                "      // Restore original material side",
                "      if (material._hadOwnSide) {",
                "        material.side = material._actualSide;",
                "      } else {",
                "        delete material.side; // back to inheriting from base material",
                "      }",
                "    }",
                "",
                "    /**",
                "     * Shortcut to dispose the geometry specific to this instance.",
                "     * Note: we don't also dispose the derived material here because if anything else is",
                "     * sharing the same base material it will result in a pause next frame as the program",
                "     * is recompiled. Instead users can dispose the base material manually, like normal,",
                "     * and we'll also dispose the derived material at that time.",
                "     */",
                "    dispose() {",
                "      this.geometry.dispose();",
                "    }",
                "",
                "    /**",
                "     * @property {TroikaTextRenderInfo|null} textRenderInfo",
                "     * @readonly",
                "     * The current processed rendering data for this TextMesh, returned by the TextBuilder after",
                "     * a `sync()` call. This will be `null` initially, and may be stale for a short period until",
                "     * the asynchrous `sync()` process completes.",
                "     */",
                "    get textRenderInfo() {",
                "      return this._textRenderInfo || null",
                "    }",
                "",
                "    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping",
                "    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.",
                "    get material() {",
                "      let derivedMaterial = this._derivedMaterial;",
                "      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());",
                "      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {",
                "        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);",
                "        // dispose the derived material when its base material is disposed:",
                "        baseMaterial.addEventListener('dispose', function onDispose() {",
                "          baseMaterial.removeEventListener('dispose', onDispose);",
                "          derivedMaterial.dispose();",
                "        });",
                "      }",
                "      // If text outline is configured, render it as a preliminary draw using Three's multi-material",
                "      // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi",
                "      // materials ensures the layers are always rendered consecutively in a consistent order.",
                "      // Each layer will trigger onBeforeRender with the appropriate material.",
                "      if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {",
                "        let outlineMaterial = derivedMaterial._outlineMtl;",
                "        if (!outlineMaterial) {",
                "          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {",
                "            id: {value: derivedMaterial.id + 0.1}",
                "          });",
                "          outlineMaterial.isTextOutlineMaterial = true;",
                "          outlineMaterial.depthWrite = false;",
                "          outlineMaterial.map = null; //???",
                "          derivedMaterial.addEventListener('dispose', function onDispose() {",
                "            derivedMaterial.removeEventListener('dispose', onDispose);",
                "            outlineMaterial.dispose();",
                "          });",
                "        }",
                "        return [",
                "          outlineMaterial,",
                "          derivedMaterial",
                "        ]",
                "      } else {",
                "        return derivedMaterial",
                "      }",
                "    }",
                "    set material(baseMaterial) {",
                "      if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation",
                "        this._derivedMaterial = baseMaterial;",
                "        this._baseMaterial = baseMaterial.baseMaterial;",
                "      } else {",
                "        this._baseMaterial = baseMaterial;",
                "      }",
                "    }",
                "",
                "    get glyphGeometryDetail() {",
                "      return this.geometry.detail",
                "    }",
                "    set glyphGeometryDetail(detail) {",
                "      this.geometry.detail = detail;",
                "    }",
                "",
                "    get curveRadius() {",
                "      return this.geometry.curveRadius",
                "    }",
                "    set curveRadius(r) {",
                "      this.geometry.curveRadius = r;",
                "    }",
                "",
                "    // Create and update material for shadows upon request:",
                "    get customDepthMaterial() {",
                "      return first(this.material).getDepthMaterial()",
                "    }",
                "    get customDistanceMaterial() {",
                "      return first(this.material).getDistanceMaterial()",
                "    }",
                "",
                "    _prepareForRender(material) {",
                "      const isOutline = material.isTextOutlineMaterial;",
                "      const uniforms = material.uniforms;",
                "      const textInfo = this.textRenderInfo;",
                "      if (textInfo) {",
                "        const {sdfTexture, blockBounds} = textInfo;",
                "        uniforms.uTroikaSDFTexture.value = sdfTexture;",
                "        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);",
                "        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;",
                "        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;",
                "        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);",
                "        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;",
                "",
                "        let distanceOffset = 0;",
                "        let blurRadius = 0;",
                "        let strokeWidth = 0;",
                "        let fillOpacity;",
                "        let strokeOpacity;",
                "        let strokeColor;",
                "        let offsetX = 0;",
                "        let offsetY = 0;",
                "",
                "        if (isOutline) {",
                "          let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;",
                "          distanceOffset = this._parsePercent(outlineWidth) || 0;",
                "          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);",
                "          fillOpacity = outlineOpacity;",
                "          offsetX = this._parsePercent(outlineOffsetX) || 0;",
                "          offsetY = this._parsePercent(outlineOffsetY) || 0;",
                "        } else {",
                "          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);",
                "          if (strokeWidth) {",
                "            strokeColor = this.strokeColor;",
                "            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);",
                "            strokeOpacity = this.strokeOpacity;",
                "            if (strokeOpacity == null) strokeOpacity = 1;",
                "          }",
                "          fillOpacity = this.fillOpacity;",
                "        }",
                "",
                "        uniforms.uTroikaDistanceOffset.value = distanceOffset;",
                "        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);",
                "        uniforms.uTroikaBlurRadius.value = blurRadius;",
                "        uniforms.uTroikaStrokeWidth.value = strokeWidth;",
                "        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;",
                "        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;",
                "        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;",
                "",
                "        let clipRect = this.clipRect;",
                "        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {",
                "          uniforms.uTroikaClipRect.value.fromArray(clipRect);",
                "        } else {",
                "          // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines",
                "          const pad = (this.fontSize || 0.1) * 100;",
                "          uniforms.uTroikaClipRect.value.set(",
                "            blockBounds[0] - pad,",
                "            blockBounds[1] - pad,",
                "            blockBounds[2] + pad,",
                "            blockBounds[3] + pad",
                "          );",
                "        }",
                "        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);",
                "      }",
                "      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;",
                "      material.polygonOffset = !!this.depthOffset;",
                "      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;",
                "",
                "      // Shortcut for setting material color via `color` prop on the mesh; this is",
                "      // applied only to the derived material to avoid mutating a shared base material.",
                "      const color = isOutline ? (this.outlineColor || 0) : this.color;",
                "",
                "      if (color == null) {",
                "        delete material.color; //inherit from base",
                "      } else {",
                "        const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new THREE.Color());",
                "        if (color !== colorObj._input || typeof color === 'object') {",
                "          colorObj.set(colorObj._input = color);",
                "        }",
                "      }",
                "",
                "      // base orientation",
                "      let orient = this.orientation || defaultOrient;",
                "      if (orient !== material._orientation) {",
                "        let rotMat = uniforms.uTroikaOrient.value;",
                "        orient = orient.replace(/[^-+xyz]/g, '');",
                "        let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);",
                "        if (match) {",
                "          let [, hSign, hAxis, vSign, vAxis] = match;",
                "          tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;",
                "          tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;",
                "          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);",
                "          rotMat.setFromMatrix4(tempMat4);",
                "        } else {",
                "          rotMat.identity();",
                "        }",
                "        material._orientation = orient;",
                "      }",
                "    }",
                "",
                "    _parsePercent(value) {",
                "      if (typeof value === 'string') {",
                "        let match = value.match(/^(-?[\\d.]+)%$/);",
                "        let pct = match ? parseFloat(match[1]) : NaN;",
                "        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;",
                "      }",
                "      return value",
                "    }",
                "",
                "    /**",
                "     * Translate a point in local space to an x/y in the text plane.",
                "     */",
                "    localPositionToTextCoords(position, target = new THREE.Vector2()) {",
                "      target.copy(position); //simple non-curved case is 1:1",
                "      const r = this.curveRadius;",
                "      if (r) { //flatten the curve",
                "        target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);",
                "      }",
                "      return target",
                "    }",
                "",
                "    /**",
                "     * Translate a point in world space to an x/y in the text plane.",
                "     */",
                "    worldPositionToTextCoords(position, target = new THREE.Vector2()) {",
                "      tempVec3a.copy(position);",
                "      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)",
                "    }",
                "",
                "    /**",
                "     * @override Custom raycasting to test against the whole text block's max rectangular bounds",
                "     * TODO is there any reason to make this more granular, like within individual line or glyph rects?",
                "     */",
                "    raycast(raycaster, intersects) {",
                "      const {textRenderInfo, curveRadius} = this;",
                "      if (textRenderInfo) {",
                "        const bounds = textRenderInfo.blockBounds;",
                "        const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();",
                "        const geom = raycastMesh.geometry;",
                "        const {position, uv} = geom.attributes;",
                "        for (let i = 0; i < uv.count; i++) {",
                "          let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));",
                "          const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));",
                "          let z = 0;",
                "          if (curveRadius) {",
                "            z = curveRadius - Math.cos(x / curveRadius) * curveRadius;",
                "            x = Math.sin(x / curveRadius) * curveRadius;",
                "          }",
                "          position.setXYZ(i, x, y, z);",
                "        }",
                "        geom.boundingSphere = this.geometry.boundingSphere;",
                "        geom.boundingBox = this.geometry.boundingBox;",
                "        raycastMesh.matrixWorld = this.matrixWorld;",
                "        raycastMesh.material.side = this.material.side;",
                "        tempArray.length = 0;",
                "        raycastMesh.raycast(raycaster, tempArray);",
                "        for (let i = 0; i < tempArray.length; i++) {",
                "          tempArray[i].object = this;",
                "          intersects.push(tempArray[i]);",
                "        }",
                "      }",
                "    }",
                "",
                "    copy(source) {",
                "      // Prevent copying the geometry reference so we don't end up sharing attributes between instances",
                "      const geom = this.geometry;",
                "      super.copy(source);",
                "      this.geometry = geom;",
                "",
                "      COPYABLE_PROPS.forEach(prop => {",
                "        this[prop] = source[prop];",
                "      });",
                "      return this",
                "    }",
                "",
                "    clone() {",
                "      return new this.constructor().copy(this)",
                "    }",
                "  }",
                "",
                "",
                "  // Create setters for properties that affect text layout:",
                "  SYNCABLE_PROPS.forEach(prop => {",
                "    const privateKey = '_private_' + prop;",
                "    Object.defineProperty(Text.prototype, prop, {",
                "      get() {",
                "        return this[privateKey]",
                "      },",
                "      set(value) {",
                "        if (value !== this[privateKey]) {",
                "          this[privateKey] = value;",
                "          this._needsSync = true;",
                "        }",
                "      }",
                "    });",
                "  });",
                "",
                "  //=== Utility functions for dealing with carets and selection ranges ===//",
                "",
                "  /**",
                "   * @typedef {object} TextCaret",
                "   * @property {number} x - x position of the caret",
                "   * @property {number} y - y position of the caret's bottom",
                "   * @property {number} height - height of the caret",
                "   * @property {number} charIndex - the index in the original input string of this caret's target",
                "   *   character; the caret will be for the position _before_ that character.",
                "   */",
                "",
                "  /**",
                "   * Given a local x/y coordinate in the text block plane, find the nearest caret position.",
                "   * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo",
                "   * @param {number} x",
                "   * @param {number} y",
                "   * @return {TextCaret | null}",
                "   */",
                "  function getCaretAtPoint(textRenderInfo, x, y) {",
                "    let closestCaret = null;",
                "    const rows = groupCaretsByRow(textRenderInfo);",
                "",
                "    // Find nearest row by y first",
                "    let closestRow = null;",
                "    rows.forEach(row => {",
                "      if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {",
                "        closestRow = row;",
                "      }",
                "    });",
                "",
                "    // Then find closest caret by x within that row",
                "    closestRow.carets.forEach(caret => {",
                "      if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {",
                "        closestCaret = caret;",
                "      }",
                "    });",
                "    return closestCaret",
                "  }",
                "",
                "",
                "  const _rectsCache = new WeakMap();",
                "",
                "  /**",
                "   * Given start and end character indexes, return a list of rectangles covering all the",
                "   * characters within that selection.",
                "   * @param {TroikaTextRenderInfo} textRenderInfo",
                "   * @param {number} start - index of the first char in the selection",
                "   * @param {number} end - index of the first char after the selection",
                "   * @return {Array<{left, top, right, bottom}> | null}",
                "   */",
                "  function getSelectionRects(textRenderInfo, start, end) {",
                "    let rects;",
                "    if (textRenderInfo) {",
                "      // Check cache - textRenderInfo is frozen so it's safe to cache based on it",
                "      let prevResult = _rectsCache.get(textRenderInfo);",
                "      if (prevResult && prevResult.start === start && prevResult.end === end) {",
                "        return prevResult.rects",
                "      }",
                "",
                "      const {caretPositions} = textRenderInfo;",
                "",
                "      // Normalize",
                "      if (end < start) {",
                "        const s = start;",
                "        start = end;",
                "        end = s;",
                "      }",
                "      start = Math.max(start, 0);",
                "      end = Math.min(end, caretPositions.length + 1);",
                "",
                "      // Build list of rects, expanding the current rect for all characters in a run and starting",
                "      // a new rect whenever reaching a new line or a new bidi direction",
                "      rects = [];",
                "      let currentRect = null;",
                "      for (let i = start; i < end; i++) {",
                "        const x1 = caretPositions[i * 4];",
                "        const x2 = caretPositions[i * 4 + 1];",
                "        const left = Math.min(x1, x2);",
                "        const right = Math.max(x1, x2);",
                "        const bottom = caretPositions[i * 4 + 2];",
                "        const top = caretPositions[i * 4 + 3];",
                "        if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {",
                "          currentRect = {",
                "            left: Infinity,",
                "            right: -Infinity,",
                "            bottom,",
                "            top,",
                "          };",
                "          rects.push(currentRect);",
                "        }",
                "        currentRect.left = Math.min(left, currentRect.left);",
                "        currentRect.right = Math.max(right, currentRect.right);",
                "      }",
                "",
                "      // Merge any overlapping rects, e.g. those formed by adjacent bidi runs",
                "      rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);",
                "      for (let i = rects.length - 1; i-- > 0;) {",
                "        const rectA = rects[i];",
                "        const rectB = rects[i + 1];",
                "        if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {",
                "          rectB.left = Math.min(rectB.left, rectA.left);",
                "          rectB.right = Math.max(rectB.right, rectA.right);",
                "          rects.splice(i, 1);",
                "        }",
                "      }",
                "",
                "      _rectsCache.set(textRenderInfo, {start, end, rects});",
                "    }",
                "    return rects",
                "  }",
                "",
                "  const _caretsByRowCache = new WeakMap();",
                "",
                "  /**",
                "   * Group a set of carets by row of text, caching the result. A single row of text may contain carets of",
                "   * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this",
                "   * uses an assumption of \"at least overlapping by half\" to put them in the same row.",
                "   * @return Array<{bottom: number, top: number, carets: TextCaret[]}>",
                "   */",
                "  function groupCaretsByRow(textRenderInfo) {",
                "    // textRenderInfo is frozen so it's safe to cache based on it",
                "    let rows = _caretsByRowCache.get(textRenderInfo);",
                "    if (!rows) {",
                "      rows = [];",
                "      const {caretPositions} = textRenderInfo;",
                "      let curRow;",
                "",
                "      const visitCaret = (x, bottom, top, charIndex) => {",
                "        // new row if not overlapping by at least half",
                "        if (!curRow || (top < (curRow.top + curRow.bottom) / 2)) {",
                "          rows.push(curRow = {bottom, top, carets: []});",
                "        }",
                "        // expand vertical limits if necessary",
                "        if (top > curRow.top) curRow.top = top;",
                "        if (bottom < curRow.bottom) curRow.bottom = bottom;",
                "        curRow.carets.push({",
                "          x,",
                "          y: bottom,",
                "          height: top - bottom,",
                "          charIndex,",
                "        });",
                "      };",
                "",
                "      let i = 0;",
                "      for (; i < caretPositions.length; i += 4) {",
                "        visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);",
                "      }",
                "      // Add one more caret after the final char",
                "      visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);",
                "    }",
                "    _caretsByRowCache.set(textRenderInfo, rows);",
                "    return rows",
                "  }",
                "",
                "gdjs.__text3DExtension = {",
                "    Text3DRenderer,",
                "    Text",
                "};",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "The text color.",
          "fullName": "Text color",
          "functionType": "StringExpression",
          "name": "TextColor",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object._color.join(\";\");\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The text font.",
          "fullName": "Font",
          "functionType": "StringExpression",
          "name": "Font",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object._fontName;\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the text font.",
          "fullName": "Font",
          "functionType": "Action",
          "name": "SetFont",
          "private": true,
          "sentence": "Change the font of _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "const value = eventsFunctionContext.getArgument(\"Value\");\r",
                "\r",
                "object.setFontName(value);\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            },
            {
              "description": "Font name",
              "name": "Value",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The text color.",
          "fullName": "Outline color",
          "functionType": "StringExpression",
          "name": "OutlineColor",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object._outlineColor.join(\";\");\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Outline thickness",
          "functionType": "Expression",
          "name": "OutlineThickness",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object.getOutlineThickness();\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Shadow distance",
          "functionType": "Expression",
          "name": "ShadowDistance",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object.getShadowDistance();\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Shadow angle",
          "functionType": "Expression",
          "name": "ShadowAngle",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object.getShadowAngle();\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Shadow blur radius",
          "functionType": "Expression",
          "name": "ShadowBlurRadius",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object.getShadowBlurRadius();\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The text color.",
          "fullName": "Shadow color",
          "functionType": "StringExpression",
          "name": "ShadowColor",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object._shadowColor.join(\";\");\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Shadow opacity",
          "functionType": "Expression",
          "name": "ShadowOpacity",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object.getShadowOpacity();\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Wrapping width",
          "functionType": "Expression",
          "name": "WrappingWidth",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.TextRuntimeObject} */\r",
                "const object = objects[0];\r",
                "\r",
                "eventsFunctionContext.returnValue = object.getWrappingWidth();\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "TextObject::Text",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": [
        {
          "defaultName": "Text",
          "description": "A text in 3D.",
          "fullName": "3D text",
          "is3D": true,
          "isTextContainer": true,
          "name": "Text3D",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Text",
                        "0",
                        "0",
                        "\"\""
                      ]
                    },
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Text"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "As the 3D text geometry is updated in background, its dimensions are not updated right away.\nThe 2D text child dimension is used instead as a workaround but the dimensions don't exatcly match the 3D text."
                    },
                    {
                      "disabled": true,
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "SetIncludedInParentCollisionMask"
                          },
                          "parameters": [
                            "Text",
                            "no"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const { Text, Text3DRenderer } = gdjs.__text3DExtension;",
                    "",
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "/** @type {gdjs.TextRuntimeObject} */",
                    "const textObject = eventsFunctionContext.getObjects(\"Text\")[0];",
                    "",
                    "// Here runtimeScene is the gdjs.CustomRuntimeObjectInstanceContainer inside the custom object.",
                    "const gameScene = object.getRuntimeScene();",
                    "",
                    "const superExtraInitializationFromInitialInstance = object.extraInitializationFromInitialInstance.bind(object);",
                    "object.extraInitializationFromInitialInstance = initialInstanceData => {",
                    "    superExtraInitializationFromInitialInstance(initialInstanceData);",
                    "    if (initialInstanceData.customSize) {",
                    "        textObject.setWrappingWidth(initialInstanceData.width);",
                    "        textObject.setWrapping(true);",
                    "        object.__text3DExtension.threeText.maxWidth = initialInstanceData.width;",
                    "    }",
                    "};",
                    "",
                    "// This is a hack that may break in future releases.",
                    "const layer = gameScene.getLayer(object.getLayer());",
                    "layer.getRenderer().remove3DRendererObject(object._renderer._threeGroup);",
                    "const text3DRenderer = new Text3DRenderer(object, object._instanceContainer, object.getInstanceContainer());",
                    "object._renderer = text3DRenderer;",
                    "layer.getRenderer().add3DRendererObject(text3DRenderer._threeGroup);",
                    "",
                    "const threeText = new Text()",
                    "object.__text3DExtension = { threeText };",
                    "text3DRenderer._threeGroup.add(threeText);",
                    "threeText.scale.y = -1;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateFromProperties"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateText"
                      },
                      "parameters": [
                        "Object",
                        "Object.Text::Value()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateGeometry"
                      },
                      "parameters": [
                        "Object",
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "",
                    "// Ensure it stays true at least a whole frame for events.",
                    "object.__text3DExtension.hasGeometryUpdated = false;",
                    "",
                    "if (object.__text3DExtension.hasSync) {",
                    "    object.__text3DExtension.hasSync = false;",
                    "    object.__text3DExtension.hasGeometryUpdated = true;",
                    "    object._renderer._isContainerDirty = true;",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetRotationCenter"
                      },
                      "parameters": [
                        "Object",
                        "Object.TextWidth() / 2",
                        "Object.TextHeight() / 2",
                        "0"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Update text",
              "functionType": "Action",
              "getterName": "OutlineThickness",
              "name": "UpdateText",
              "private": true,
              "sentence": "Update text of _PARAM0_ to _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::IsTextUpToDate"
                      },
                      "parameters": [
                        "Object",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        "no"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "/** @type {gdjs.CustomRuntimeObject3D} */",
                        "const object = objects[0];",
                        "const value = eventsFunctionContext.getArgument(\"Value\");",
                        "",
                        "object.__text3DExtension.threeText.text = value;",
                        "object._renderer._isContainerDirty = true;",
                        ""
                      ],
                      "parameterObjects": "Object",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "string"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Displayed text",
              "functionType": "Condition",
              "getterName": "OutlineThickness",
              "name": "IsTextUpToDate",
              "private": true,
              "sentence": "_PARAM0_ display text _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "eventsFunctionContext.returnValue = object.__text3DExtension.threeText.text === value;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "string"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Update geometry",
              "functionType": "Action",
              "getterName": "OutlineThickness",
              "name": "UpdateGeometry",
              "private": true,
              "sentence": "Update geometry of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::PropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        "yes"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "/** @type {gdjs.CustomRuntimeObject3D} */",
                        "const object = objects[0];",
                        "",
                        "object.__text3DExtension.threeText.sync(() => {",
                        "    object.__text3DExtension.hasSync = true;",
                        "});"
                      ],
                      "parameterObjects": "Object",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the text has just been updated on screen.",
              "fullName": "Has updated on sceen",
              "functionType": "Condition",
              "getterName": "OutlineThickness",
              "name": "HasGeometryUpdated",
              "private": true,
              "sentence": "_PARAM0_ has updated on screen",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "",
                    "eventsFunctionContext.returnValue =",
                    "    object.__text3DExtension.hasGeometryUpdated;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onHotReloading",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateFromProperties"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Update from properties.",
              "fullName": "Update from properties",
              "functionType": "Action",
              "name": "UpdateFromProperties",
              "private": true,
              "sentence": "Update from properties of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextContainerCapability::TextContainerBehavior::SetValue"
                      },
                      "parameters": [
                        "Object",
                        "Text",
                        "=",
                        "Text.Text::Value()"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetFontSize"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.FontSize()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetFont"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.Font()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetColor"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.Color()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetWrappingWidth"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.WrappingWidth()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetTextAlignment"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.TextAlignment()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetShadowColor"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.ShadowColor()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetShadowAngle"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.ShadowAngle()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetShadowDistance"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.ShadowDistance()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetShadowBlurRadius"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.ShadowBlurRadius()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetShadowOpacity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.ShadowOpacity()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetOutlineThickness"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.OutlineThickness()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetOutlineColor"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.OutlineColor()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetLineSpacing"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.LineSpacing()",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::IsShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::IsOutlineEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetOutlineEnabled"
                      },
                      "parameters": [
                        "Object",
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        "yes",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsOutlineEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetOutlineEnabled"
                      },
                      "parameters": [
                        "Object",
                        "yes",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::IsWrapping"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetWrapping"
                      },
                      "parameters": [
                        "Object",
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsWrapping"
                      },
                      "parameters": [
                        "Object",
                        "="
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetWrapping"
                      },
                      "parameters": [
                        "Object",
                        "yes",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Text width",
              "functionType": "Expression",
              "name": "TextWidth",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "",
                    "const boundingBox = object.__text3DExtension.threeText.geometry.boundingBox;",
                    "eventsFunctionContext.returnValue = boundingBox.max.x - boundingBox.min.x;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Text width",
              "functionType": "Expression",
              "name": "TextHeight",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "",
                    "const boundingBox = object.__text3DExtension.threeText.geometry.boundingBox;",
                    "eventsFunctionContext.returnValue = boundingBox.max.y - boundingBox.min.y;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the font size of a text object.",
              "fullName": "Font size",
              "functionType": "ExpressionAndCondition",
              "group": "Style",
              "name": "FontSize",
              "sentence": "the font size",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Text.FontSize()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "FontSize",
              "name": "SetFontSize",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::FontSize"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetFontSize"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "Value"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.fontSize = value;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the word wrapping style of an object is set.",
              "fullName": "Wrapping",
              "functionType": "Condition",
              "group": "Style",
              "name": "IsWrapping",
              "sentence": "_PARAM0_ word wrapping style is activated",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::IsWrapping"
                      },
                      "parameters": [
                        "Text"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "De/activate word wrapping. Note that word wrapping is a graphical option, you can't get the number of lines displayed.",
              "fullName": "Wrapping",
              "functionType": "Action",
              "group": "Style",
              "name": "SetWrapping",
              "sentence": "Activate wrapping style of _PARAM0_: _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::SetWrapping"
                      },
                      "parameters": [
                        "Text",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateWrappingWidth"
                      },
                      "parameters": [
                        "Object",
                        "0",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::SetWrapping"
                      },
                      "parameters": [
                        "Text",
                        "yes"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateWrappingWidth"
                      },
                      "parameters": [
                        "Object",
                        "Object.WrappingWidth()",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Enable outline",
                  "name": "Value",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the word wrapping width of a Text object.",
              "fullName": "Wrapping width",
              "functionType": "ExpressionAndCondition",
              "group": "Style",
              "name": "WrappingWidth",
              "sentence": "the wrapping width",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Text3D::WrappingWidth(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "WrappingWidth",
              "name": "SetWrappingWidth",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::WrappingWidth"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::WrappingWidth"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsWrapping"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateWrappingWidth"
                      },
                      "parameters": [
                        "Object",
                        "Object.WrappingWidth()",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Update wrapping width",
              "functionType": "Action",
              "getterName": "OutlineThickness",
              "name": "UpdateWrappingWidth",
              "private": true,
              "sentence": "Update wrapping width of _PARAM0_ to _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::WrappingWidth"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.maxWidth = value || Number.POSITIVE_INFINITY;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the color of the text.",
              "fullName": "Color",
              "functionType": "ExpressionAndCondition",
              "group": "Style",
              "name": "Color",
              "sentence": "the color",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Text3D::TextColor(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Color",
              "name": "SetColor",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::ChangeColor"
                      },
                      "parameters": [
                        "Text",
                        "Value"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.color = gdjs.rgbOrHexStringToNumber(value);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the font of the text.",
              "fullName": "Font",
              "functionType": "ExpressionAndCondition",
              "group": "Style",
              "name": "Font",
              "sentence": "the font",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Text3D::Font(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Font",
              "name": "SetFont",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::Font"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::SetFont"
                      },
                      "parameters": [
                        "Text",
                        "Text",
                        "Value",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.font =",
                    "    runtimeScene.getGame().getFontManager().getFontFile(value);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the line spacing of the object.",
              "fullName": "Line spacing",
              "functionType": "ExpressionAndCondition",
              "group": "Style",
              "name": "LineSpacing",
              "sentence": "the line spacing",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "LineSpacing"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "LineSpacing",
              "name": "SetLineSpacing",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::LineSpacing"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyLineSpacing"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.lineHeight = value || 'normal';",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the text outline is enabled.",
              "fullName": "Outline enabled",
              "functionType": "Condition",
              "group": "Outline",
              "name": "IsOutlineEnabled",
              "sentence": "The outline of _PARAM0_ is enabled",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::Text::IsOutlineEnabled"
                      },
                      "parameters": [
                        "Text"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Enable or disable the outline of the text.",
              "fullName": "Enable outline",
              "functionType": "Action",
              "group": "Outline",
              "name": "SetOutlineEnabled",
              "sentence": "Enable the outline of _PARAM0_: _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetOutlineEnabled"
                      },
                      "parameters": [
                        "Text",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateOutlineThickness"
                      },
                      "parameters": [
                        "Object",
                        "0",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetOutlineEnabled"
                      },
                      "parameters": [
                        "Text",
                        "yes"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateOutlineThickness"
                      },
                      "parameters": [
                        "Object",
                        "Object.OutlineThickness()",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Enable outline",
                  "name": "Value",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the outline thickness of the text.",
              "fullName": "Outline thickness",
              "functionType": "ExpressionAndCondition",
              "group": "Outline",
              "name": "OutlineThickness",
              "sentence": "the text outline thickness",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Text3D::OutlineThickness(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "OutlineThickness",
              "name": "SetOutlineThickness",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetOutlineThickness"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsOutlineEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateOutlineThickness"
                      },
                      "parameters": [
                        "Object",
                        "Value",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Update outline thickness",
              "functionType": "Action",
              "getterName": "OutlineThickness",
              "name": "UpdateOutlineThickness",
              "private": true,
              "sentence": "Update outline thickness of _PARAM0_ to _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::OutlineThickness"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.outlineWidth = value / 2;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the outline color of the text.",
              "fullName": "Outline color",
              "functionType": "ExpressionAndCondition",
              "group": "Outline",
              "name": "OutlineColor",
              "sentence": "the text outline color",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Text3D::OutlineColor(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "OutlineColor",
              "name": "SetOutlineColor",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetOutlineColor"
                      },
                      "parameters": [
                        "Text",
                        "Value"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsOutlineEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "/** @type {gdjs.CustomRuntimeObject3D} */",
                        "const object = objects[0];",
                        "const value = eventsFunctionContext.getArgument(\"Value\");",
                        "",
                        "object.__text3DExtension.threeText.outlineColor = gdjs.rgbOrHexStringToNumber(value);",
                        ""
                      ],
                      "parameterObjects": "Object",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the text shadowis enabled.",
              "fullName": "Shadow enabled",
              "functionType": "Condition",
              "group": "Shadow",
              "name": "IsShadowEnabled",
              "sentence": "The shadow of _PARAM0_ is enabled",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::Text::IsShadowEnabled"
                      },
                      "parameters": [
                        "Text"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Enable or disable the shadow of the text.",
              "fullName": "Enable shadow",
              "functionType": "Action",
              "group": "Shadow",
              "name": "SetShadowEnabled",
              "sentence": "Enable the shadow of _PARAM0_: _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowOffset"
                      },
                      "parameters": [
                        "Object",
                        "0",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowBlurRadius"
                      },
                      "parameters": [
                        "Object",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowOpacity"
                      },
                      "parameters": [
                        "Object",
                        "255",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "TextObject::ShowShadow"
                      },
                      "parameters": [
                        "Text",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowOffset"
                      },
                      "parameters": [
                        "Object",
                        "Object.ShadowAngle()",
                        "Object.ShadowDistance()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowBlurRadius"
                      },
                      "parameters": [
                        "Object",
                        "Object.ShadowBlurRadius()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowOpacity"
                      },
                      "parameters": [
                        "Object",
                        "Object.ShadowOpacity()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "TextObject::ShowShadow"
                      },
                      "parameters": [
                        "Text",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Show the shadow",
                  "name": "Value",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the shadow color of the text.",
              "fullName": "Shadow color",
              "functionType": "ExpressionAndCondition",
              "group": "Shadow",
              "name": "ShadowColor",
              "sentence": "the shadow color",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Text3D::ShadowColor(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ShadowColor",
              "name": "SetShadowColor",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetShadowColor"
                      },
                      "parameters": [
                        "Text",
                        "Value"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "/** @type {gdjs.CustomRuntimeObject3D} */",
                        "const object = objects[0];",
                        "const value = eventsFunctionContext.getArgument(\"Value\");",
                        "",
                        "object.__text3DExtension.threeText.outlineColor = gdjs.rgbOrHexStringToNumber(value);",
                        ""
                      ],
                      "parameterObjects": "Object",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the shadow distance of the text.",
              "fullName": "Shadow distance",
              "functionType": "ExpressionAndCondition",
              "group": "Shadow",
              "name": "ShadowDistance",
              "sentence": "the shadow distance",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Text3D::ShadowDistance(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ShadowDistance",
              "name": "SetShadowDistance",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowOffset"
                      },
                      "parameters": [
                        "Object",
                        "Object.ShadowAngle()",
                        "Value",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetShadowDistance"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the shadow angle of the text.",
              "fullName": "Shadow angle",
              "functionType": "ExpressionAndCondition",
              "group": "Shadow",
              "name": "ShadowAngle",
              "sentence": "the shadow angle",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Text3D::ShadowAngle(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ShadowAngle",
              "name": "SetShadowAngle",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowOffset"
                      },
                      "parameters": [
                        "Object",
                        "Value",
                        "Object.ShadowDistance()",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetShadowAngle"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Update shadow offset",
              "functionType": "Action",
              "getterName": "OutlineThickness",
              "name": "UpdateShadowOffset",
              "private": true,
              "sentence": "Update shadow offset of _PARAM0_ to angle: _PARAM1_ and distance: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "inverted": true,
                            "value": "Text3D::Text3D::ShadowAngle"
                          },
                          "parameters": [
                            "Object",
                            "=",
                            "Angle",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "inverted": true,
                            "value": "Text3D::Text3D::ShadowDistance"
                          },
                          "parameters": [
                            "Object",
                            "=",
                            "Distance",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const angle = eventsFunctionContext.getArgument(\"Angle\");",
                    "const distance = eventsFunctionContext.getArgument(\"Distance\");",
                    "",
                    "object.__text3DExtension.threeText.outlineOffsetX = distance * Math.cos(gdjs.toRad(angle));",
                    "object.__text3DExtension.threeText.outlineOffsetY = distance * Math.sin(gdjs.toRad(angle));"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Angle",
                  "name": "Angle",
                  "type": "expression"
                },
                {
                  "description": "Distance",
                  "name": "Distance",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the shadow blur radius of the text.",
              "fullName": "Shadow blur radius",
              "functionType": "ExpressionAndCondition",
              "group": "Shadow",
              "name": "ShadowBlurRadius",
              "sentence": "the shadow blur radius",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Text3D::ShadowBlurRadius(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ShadowBlurRadius",
              "name": "SetShadowBlurRadius",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowBlurRadius"
                      },
                      "parameters": [
                        "Object",
                        "Value",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetShadowBlurRadius"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Update shadow blur radius",
              "functionType": "Action",
              "getterName": "OutlineThickness",
              "name": "UpdateShadowBlurRadius",
              "private": true,
              "sentence": "Update shadow blur radius of _PARAM0_ to _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::ShadowBlurRadius"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.outlineBlur = value;",
                    "object.__text3DExtension.threeText.outlineWidth = -value / 2;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the shadow opacity of the text.",
              "fullName": "Shadow opacity",
              "functionType": "ExpressionAndCondition",
              "group": "Shadow",
              "name": "ShadowOpacity",
              "sentence": "the shadow opacity",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Text3D::ShadowOpacity(Text)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ShadowOpacity",
              "name": "SetShadowOpacity",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::IsShadowEnabled"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::UpdateShadowOpacity"
                      },
                      "parameters": [
                        "Object",
                        "Value",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::Text::SetShadowOpacity"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Update shadow opacity",
              "functionType": "Action",
              "getterName": "OutlineThickness",
              "name": "UpdateShadowOpacity",
              "private": true,
              "sentence": "Update shadow opacity of _PARAM0_ to _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::ShadowOpacity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.outlineOpacity = value / 255;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the boldstyle is activated.",
              "fullName": "Bold",
              "functionType": "Condition",
              "group": "Style",
              "name": "IsBold",
              "sentence": "_PARAM0_ bold style is set",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::IsBold"
                      },
                      "parameters": [
                        "Text"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "De/activate bold.",
              "fullName": "Bold",
              "functionType": "Action",
              "group": "Style",
              "name": "SetBold",
              "sentence": "Set bold style for _PARAM0_ : _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::SetBold"
                      },
                      "parameters": [
                        "Text",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::SetBold"
                      },
                      "parameters": [
                        "Text",
                        "yes"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.fontWeight = value ? \"bold\" : \"normal\";",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Bold",
                  "name": "Value",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the italic style is activated.",
              "fullName": "Italic",
              "functionType": "Condition",
              "group": "Style",
              "name": "IsItalic",
              "sentence": "_PARAM0_ italic style is set",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::IsItalic"
                      },
                      "parameters": [
                        "Text"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "De/activate italic.",
              "fullName": "Italic",
              "functionType": "Action",
              "group": "Style",
              "name": "SetItalic",
              "sentence": "Set italic style for _PARAM0_ : _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::SetItalic"
                      },
                      "parameters": [
                        "Text",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::SetItalic"
                      },
                      "parameters": [
                        "Text",
                        "yes"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.fontStyle = value ? \"italic\" : \"normal\";",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                },
                {
                  "description": "Italic",
                  "name": "Value",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the text alignment of a multiline text object.",
              "fullName": "Alignment",
              "functionType": "ExpressionAndCondition",
              "group": "Style",
              "name": "TextAlignment",
              "sentence": "the alignment",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::TextAlignment"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "\"left\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "\"left\""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::TextAlignment"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "\"center\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "\"center\""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TextObject::TextAlignment"
                      },
                      "parameters": [
                        "Text",
                        "=",
                        "\"right\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "\"right\""
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "supplementaryInformation": "[\"left\",\"center\",\"right\"]",
                "type": "stringWithSelector"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "TextAlignment",
              "name": "SetTextAlignment",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "Text3D::Text3D::TextAlignment"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Value",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::SetTextAlignment"
                      },
                      "parameters": [
                        "Text",
                        "Value"
                      ]
                    },
                    {
                      "type": {
                        "value": "Text3D::Text3D::SetPropertyIsGeometryUpToDate"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject3D} */",
                    "const object = objects[0];",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__text3DExtension.threeText.textAlign = value;",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Text3D::Text3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "Top",
              "type": "String",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [
                "Text"
              ],
              "hidden": true,
              "name": "TextVerticalAnchorOrigin"
            },
            {
              "value": "Top",
              "type": "String",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TextVerticalAnchorTarget"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "Line spacing",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "LineSpacing"
            },
            {
              "value": "false",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "IsGeometryUpToDate"
            }
          ],
          "objects": [
            {
              "assetStoreId": "",
              "bold": false,
              "italic": false,
              "name": "Text",
              "smoothed": true,
              "type": "TextObject::Text",
              "underlined": false,
              "variables": [],
              "effects": [],
              "behaviors": [],
              "string": "Text",
              "font": "",
              "textAlignment": "left",
              "characterSize": 20,
              "color": {
                "b": 0,
                "g": 0,
                "r": 0
              },
              "content": {
                "bold": false,
                "isOutlineEnabled": false,
                "isShadowEnabled": false,
                "italic": false,
                "outlineColor": "255;255;255",
                "outlineThickness": 2,
                "shadowAngle": 90,
                "shadowBlurRadius": 2,
                "shadowColor": "0;0;0",
                "shadowDistance": 4,
                "shadowOpacity": 127,
                "smoothed": true,
                "underlined": false,
                "text": "Text",
                "font": "",
                "textAlignment": "left",
                "characterSize": 20,
                "color": "0;0;0"
              }
            }
          ],
          "objectsFolderStructure": {
            "folderName": "__ROOT",
            "children": [
              {
                "objectName": "Text"
              }
            ]
          }
        }
      ]
    },
    {
      "author": "D8H",
      "category": "Game mechanic",
      "extensionNamespace": "",
      "fullName": "Object Stack",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTE4LDI5SDhjLTIuMiwwLTQtMS44LTQtNFY3YzAtMi4yLDEuOC00LDQtNGgxMGMyLjIsMCw0LDEuOCw0LDR2MThDMjIsMjcuMiwyMC4yLDI5LDE4LDI5eiIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIyLDYuNGw1LDNjMS45LDEuMSwyLjUsMy42LDEuMyw1LjVMMjIsMjUuNSIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI4LDE2bDAuNSwwLjdjMS4zLDEuOCwwLjgsNC4zLTEsNS42bC01LjcsNCIvPg0KPGxpbmUgY2xhc3M9InN0MCIgeDE9IjgiIHkxPSI3IiB4Mj0iOCIgeTI9IjkiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIxOCIgeTE9IjIzIiB4Mj0iMTgiIHkyPSIyNSIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTEwLjQsMTYuNmMwLjUsMC41LDEuMywwLjUsMS44LDBsMC44LTAuOGwwLjgsMC44YzAuNSwwLjUsMS4zLDAuNSwxLjgsMGMwLjUtMC41LDAuNS0xLjQsMC0xLjlsLTAuOC0wLjhMMTMsMTINCglsLTEuOCwxLjlsLTAuOCwwLjhDOS45LDE1LjIsOS45LDE2LjEsMTAuNCwxNi42eiIvPg0KPGxpbmUgY2xhc3M9InN0MCIgeDE9IjEyIiB5MT0iMjAiIHgyPSIxNCIgeTI9IjIwIi8+DQo8bGluZSBjbGFzcz0ic3QwIiB4MT0iMTMiIHkxPSIxNyIgeDI9IjEzIiB5Mj0iMTkiLz4NCjwvc3ZnPg0K",
      "name": "ObjectStack",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Videogames/Videogames_cards_game_solitaire_poker_blackjack_casino.svg",
      "shortDescription": "An ordered list of objects and a shuffle action.",
      "version": "0.2.0",
      "description": [
        "It provides:",
        "* Actions to modify a stack of objects",
        "* Conditions to access the objects of a stack",
        "* A shuffle action",
        "",
        "It can be helpful for:",
        "* Card games",
        "* Fair randomness (for instance, to create a stack of predetermined bonus and randomize the order they appear)",
        "",
        "3 examples use it:",
        "* a card system demonstration ([open the project online](https://editor.gdevelop.io/?project=example://card-system))",
        "* a Klondike solitaire ([open the project online](https://editor.gdevelop.io/?project=example://klondike-solitaire))",
        "* a Zuma-like ([open the project online](https://editor.gdevelop.io/?project=example://smoothy))"
      ],
      "origin": {
        "identifier": "ObjectStack",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "card",
        "stack",
        "pick",
        "list",
        "queue"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs._objectStackExtension) {",
                "    return;",
                "}",
                "",
                "// Remove from deleted objects from stacks.",
                "gdjs.registerObjectDeletedFromSceneCallback(function (runtimeScene, obj) {",
                "    const extension = runtimeScene._objectStackExtension;",
                "    if (!extension) {",
                "        return;",
                "    }",
                "    if (extension.allUsedObjects.has(obj)) {",
                "        extension.allUsedObjects.delete(obj);",
                "        for (const objectStack of extension.allObjectStacks) {",
                "            objectStack.remove(obj);",
                "        }",
                "    }",
                "});",
                "",
                "class ObjectStack {",
                "    /**",
                "     * @type {Array<gdjs.RuntimeObject>}",
                "     */",
                "    stack = [];",
                "",
                "    /**",
                "     * Make contains(), remove() and unicity checks more efficients.",
                "     * @type {Set<gdjs.RuntimeObject>}",
                "     */",
                "    objectSet = new Set();",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     */",
                "    addOnTop(object) {",
                "        if (this.objectSet.has(object)) {",
                "            return false;",
                "        }",
                "        this.stack.push(object);",
                "        this.objectSet.add(object);",
                "        return true;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     * @param {number} height",
                "     */",
                "    insert(object, height) {",
                "        if (this.objectSet.has(object)) {",
                "            return false;",
                "        }",
                "        this.stack.splice(height, 0, object);",
                "        this.objectSet.add(object);",
                "        return true;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     */",
                "    remove(object) {",
                "        if (this.objectSet.has(object)) {",
                "            // The top element is likely to be removed from the stack.",
                "            // Make its removal O(1)",
                "            if (object === this.stack[this.stack.length - 1]) {",
                "                this.stack.pop();",
                "            }",
                "            else {",
                "                const index = this.stack.indexOf(object);",
                "                if (index >= 0) {",
                "                    this.stack.splice(index, 1);",
                "                }",
                "            }",
                "            this.objectSet.delete(object);",
                "        }",
                "    }",
                "",
                "    clear() {",
                "        this.stack.length = 0;",
                "        this.objectSet.clear();",
                "    }",
                "",
                "    /**",
                "     * @param {number} insertHeight",
                "     * @param {ObjectStack} other",
                "     * @param {number} lowerBound",
                "     * @param {number} upperBound",
                "     */",
                "    takeInto(insertHeight, other, lowerBound, upperBound) {",
                "        upperBound = Math.min(upperBound, other.stack.length - 1);",
                "        for (let height = lowerBound; height <= upperBound; height++) {",
                "            const insertedObject = other.stack[height];",
                "            this.stack.splice(insertHeight, 0, insertedObject);",
                "            this.objectSet.add(insertedObject);",
                "            insertHeight++;",
                "        }",
                "        if (lowerBound <= upperBound) {",
                "            for (let height = lowerBound; height <= upperBound; height++) {",
                "                other.objectSet.delete(other.stack[height]);",
                "            }",
                "            other.stack.splice(lowerBound, upperBound - lowerBound + 1);",
                "        }",
                "    }",
                "",
                "    shuffle() {",
                "        // FisherâYates shuffle",
                "        for (let i = this.stack.length - 1; i >= 1; i--) {",
                "            // TODO use a seed",
                "            const j = Math.floor(Math.random() * (i + 1));",
                "            const swap = this.stack[i];",
                "            this.stack[i] = this.stack[j]",
                "            this.stack[j] = swap;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     */",
                "    heightOf(object) {",
                "        return this.stack.indexOf(object);",
                "    }",
                "",
                "    height() {",
                "        return this.stack.length;",
                "    }",
                "",
                "    isEmpty() {",
                "        return this.stack.length === 0;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     * @param {number} lowerBound",
                "     * @param {number} upperBound",
                "     */",
                "    containsBetween(object, lowerBound, upperBound) {",
                "        upperBound = Math.min(upperBound, this.stack.length - 1);",
                "        for (let i = lowerBound; i <= upperBound; i++) {",
                "            if (this.stack[i] === object) {",
                "                return true;",
                "            }",
                "        }",
                "        return false;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     * @param {number} height",
                "     */",
                "    containsAt(object, height) {",
                "        return this.stack[height] === object;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     */",
                "    hasOnTop(object) {",
                "        return this.stack.length > 0 && this.stack[this.stack.length - 1] === object;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     */",
                "    contains(object) {",
                "        return this.objectSet.has(object);",
                "    }",
                "}",
                "",
                "gdjs._objectStackExtension = {",
                "    ObjectStack",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Check if the stack contains the object between a range. The lower and upper bounds are included.",
          "fullName": "Contain between a range",
          "functionType": "Condition",
          "group": "Object Stack",
          "name": "ContainsBetween",
          "sentence": "_PARAM3_ is into the stack of _PARAM1_ between _PARAM4_ and _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const stackBehaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const stackObjectsLists = eventsFunctionContext.getObjectsLists(\"Object\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const elementObjectsLists = eventsFunctionContext.getObjectsLists(\"Element\");",
                "const lowerBound = Math.max(0, eventsFunctionContext.getArgument(\"LowerBound\"));",
                "let upperBound = eventsFunctionContext.getArgument(\"UpperBound\");",
                "",
                "eventsFunctionContext.returnValue = gdjs.evtTools.object.twoListsTest(",
                "  (stackObject, element) => {",
                "    const behavior = stackObject.getBehavior(stackBehaviorName);",
                "    return behavior.objectStack.containsBetween(element, lowerBound, upperBound);",
                "  },",
                "  stackObjectsLists,",
                "  elementObjectsLists,",
                "  false",
                ");"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Stack",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Stack behavior",
              "name": "Behavior",
              "supplementaryInformation": "ObjectStack::ObjectStack",
              "type": "behavior"
            },
            {
              "description": "Element",
              "name": "Element",
              "type": "objectList"
            },
            {
              "description": "Lower bound",
              "name": "LowerBound",
              "type": "expression"
            },
            {
              "description": "Upper bound",
              "name": "UpperBound",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the stack contains the object at a height.",
          "fullName": "Contain at",
          "functionType": "Condition",
          "group": "Object Stack",
          "name": "ContainsAt",
          "sentence": "_PARAM3_ is into the stack of _PARAM1_ at _PARAM4_ ",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const stackBehaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const stackObjectsLists = eventsFunctionContext.getObjectsLists(\"Object\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const elementObjectsLists = eventsFunctionContext.getObjectsLists(\"Element\");",
                "",
                "const height = eventsFunctionContext.getArgument(\"Height\");",
                "",
                "// This code is duplicated from ContainsBetween because the picking wouldn't pass from one function to the other.",
                "eventsFunctionContext.returnValue = gdjs.evtTools.object.twoListsTest(",
                "  (stackObject, element) => {",
                "    const behavior = stackObject.getBehavior(stackBehaviorName);",
                "    return behavior.objectStack.containsAt(element, height);",
                "  },",
                "  stackObjectsLists,",
                "  elementObjectsLists,",
                "  false",
                ");",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Stack",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Stack behavior",
              "name": "Behavior",
              "supplementaryInformation": "ObjectStack::ObjectStack",
              "type": "behavior"
            },
            {
              "description": "Element",
              "name": "Element",
              "type": "objectList"
            },
            {
              "description": "Height",
              "name": "Height",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if an object is on the stack top.",
          "fullName": "Stack top",
          "functionType": "Condition",
          "group": "Object Stack",
          "name": "HasOnTop",
          "sentence": "_PARAM3_ is on top of the stack of _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const stackBehaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const stackObjectsLists = eventsFunctionContext.getObjectsLists(\"Object\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const elementObjectsLists = eventsFunctionContext.getObjectsLists(\"Element\");",
                "",
                "eventsFunctionContext.returnValue = gdjs.evtTools.object.twoListsTest(",
                "  (stackObject, element) => {",
                "    const behavior = stackObject.getBehavior(stackBehaviorName);",
                "    return behavior.objectStack.hasOnTop(element);",
                "  },",
                "  stackObjectsLists,",
                "  elementObjectsLists,",
                "  false",
                ");"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Stack",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Stack behavior",
              "name": "Behavior",
              "supplementaryInformation": "ObjectStack::ObjectStack",
              "type": "behavior"
            },
            {
              "description": "Element",
              "name": "Element",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the stack contains the object.",
          "fullName": "Contain",
          "functionType": "Condition",
          "group": "Object Stack",
          "name": "Contains",
          "sentence": "_PARAM3_ is into the stack of _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const stackBehaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const stackObjectsLists = eventsFunctionContext.getObjectsLists(\"Object\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const elementObjectsLists = eventsFunctionContext.getObjectsLists(\"Element\");",
                "",
                "eventsFunctionContext.returnValue = gdjs.evtTools.object.twoListsTest(",
                "  (stackObject, element) => {",
                "    const behavior = stackObject.getBehavior(stackBehaviorName);",
                "    return behavior.objectStack.contains(element);",
                "  },",
                "  stackObjectsLists,",
                "  elementObjectsLists,",
                "  false",
                ");"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Stack",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Stack behavior",
              "name": "Behavior",
              "supplementaryInformation": "ObjectStack::ObjectStack",
              "type": "behavior"
            },
            {
              "description": "Element",
              "name": "Element",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "Hold an ordered list of objects.",
          "fullName": "Object Stack",
          "name": "ObjectStack",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ObjectStack::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const ObjectStack = gdjs._objectStackExtension.ObjectStack;",
                    "",
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "behavior.objectStack = new ObjectStack();",
                    "",
                    "if (!runtimeScene._objectStackExtension) {",
                    "  runtimeScene._objectStackExtension = {",
                    "    allObjectStacks: new Set(),",
                    "    // Its only use is to have a O(1) check for",
                    "    // deleted objects that have never been in a stack.",
                    "    allUsedObjects: new Set()",
                    "  };",
                    "}",
                    "runtimeScene._objectStackExtension.allObjectStacks.add(behavior.objectStack);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onDestroy",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "runtimeScene._objectStackExtension.allObjectStacks.delete(behavior);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Add the object on the top of the stack.",
              "fullName": "Add on top",
              "functionType": "Action",
              "name": "AddOnTop",
              "sentence": "Add _PARAM2_ on top of the stack of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "const elements = eventsFunctionContext.getObjects(\"Elements\");",
                    "",
                    "const stack = behavior.objectStack;",
                    "for (const element of elements) {",
                    "  const isAdded = stack.addOnTop(element);",
                    "  if (isAdded) {",
                    "    runtimeScene._objectStackExtension.allUsedObjects.add(object);",
                    "  }",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Elements",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Insert the object into the stack.",
              "fullName": "Insert into the stack",
              "functionType": "Action",
              "name": "Insert",
              "sentence": "Insert _PARAM2_ into the stack of _PARAM0_ at height: _PARAM3_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "const elements = eventsFunctionContext.getObjects(\"Elements\");",
                    "let height = eventsFunctionContext.getArgument(\"Height\");",
                    "",
                    "const stack = behavior.objectStack;",
                    "",
                    "if (height < 0 || height > stack.height()) {",
                    "  console.error(`Tried to insert in the stack at ${height} where the stack is ${stack.length} height.`);",
                    "  height = Math.min(0, Math.max(stack.height(), height))",
                    "}",
                    "",
                    "for (const element of elements) {",
                    "  const isAdded = stack.insert(element, height);",
                    "  if (isAdded) {",
                    "    runtimeScene._objectStackExtension.allUsedObjects.add(object);",
                    "  }",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Elements",
                  "type": "objectList"
                },
                {
                  "description": "Height",
                  "name": "Height",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Remove the object from the stack.",
              "fullName": "Remove from the stack",
              "functionType": "Action",
              "name": "Remove",
              "sentence": "Remove _PARAM2_ from the stack of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "const elements = eventsFunctionContext.getObjects(\"Elements\");",
                    "",
                    "const stack = behavior.objectStack;",
                    "for (const element of elements) {",
                    "  const isAdded = stack.remove(element);",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Elements",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Remove any object from the stack.",
              "fullName": "Clear",
              "functionType": "Action",
              "name": "Clear",
              "sentence": "Remove every object of the stack of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "behavior.objectStack.clear();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move the objects from a stack into another.",
              "fullName": "Move into the stack",
              "functionType": "Action",
              "name": "MoveInto",
              "sentence": "Move the objects of the stack of _PARAM3_ from:_PARAM5_ to:_PARAM6_ into the stack of _PARAM0_ at height: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "const otherStacks = eventsFunctionContext.getObjects(\"Stack\");",
                    "const otherStackBehaviorName = eventsFunctionContext.getBehaviorName(\"StackBehavior\");",
                    "const insertHeight = eventsFunctionContext.getArgument(\"Height\");",
                    "const lowerBound = Math.max(0, eventsFunctionContext.getArgument(\"LowerBound\"));",
                    "const upperBound = eventsFunctionContext.getArgument(\"UpperBound\");",
                    "",
                    "for (const otherStack of otherStacks) {",
                    "    const otherObjectStack = otherStack.getBehavior(otherStackBehaviorName).objectStack;",
                    "    behavior.objectStack.takeInto(insertHeight, otherObjectStack, lowerBound, upperBound);",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Height",
                  "name": "Height",
                  "type": "expression"
                },
                {
                  "description": "Stack",
                  "name": "Stack",
                  "type": "objectList"
                },
                {
                  "description": "Stack behavior",
                  "name": "StackBehavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Lower bound",
                  "name": "LowerBound",
                  "type": "expression"
                },
                {
                  "description": "Upper bound",
                  "name": "UpperBound",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move all the object from a stack into another.",
              "fullName": "Move all into the stack",
              "functionType": "Action",
              "name": "MoveAllInto",
              "sentence": "Move all the objects of the stack of _PARAM3_ into the stack of _PARAM0_ at height: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ObjectStack::ObjectStack::MoveInto"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "GetArgumentAsNumber(\"Height\")",
                        "Stack",
                        "StackBehavior",
                        "0",
                        "Stack.StackBehavior::Height() - 1",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Height",
                  "name": "Height",
                  "type": "expression"
                },
                {
                  "description": "Stack",
                  "name": "Stack",
                  "type": "objectList"
                },
                {
                  "description": "Stack behavior",
                  "name": "StackBehavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move all the object from a stack into another one at the top.",
              "fullName": "Move all on top of the stack",
              "functionType": "Action",
              "name": "MoveAllOnTop",
              "sentence": "Move all the objects of the stack of _PARAM2_ on the top of the stack of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ObjectStack::ObjectStack::MoveInto"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "Object.Behavior::Height()",
                        "Stack",
                        "StackBehavior",
                        "0",
                        "Stack.StackBehavior::Height() - 1",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Stack",
                  "name": "Stack",
                  "type": "objectList"
                },
                {
                  "description": "Stack behavior",
                  "name": "StackBehavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Shuffle the stack.",
              "fullName": "Shuffle",
              "functionType": "Action",
              "name": "Shuffle",
              "sentence": "Shuffle the stack of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "behavior.objectStack.shuffle();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The height of an element in the stack.",
              "fullName": "Height of a stack element",
              "functionType": "Expression",
              "name": "HeightOf",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "const elements = eventsFunctionContext.getObjects(\"Elements\");",
                    "",
                    "eventsFunctionContext.returnValue = behavior.objectStack.heightOf(elements[0]);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Elements",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the number of objects in the stack.",
              "fullName": "Stack height",
              "functionType": "ExpressionAndCondition",
              "name": "Height",
              "sentence": "the number of objects in the stack",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.objectStack.height();",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Compare the number of objects in the stack.",
              "fullName": "Stack height (deprecated)",
              "functionType": "Condition",
              "name": "CheckHeight",
              "private": true,
              "sentence": "_PARAM0_ has _PARAM2_ objects in its stack",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ObjectStack::ObjectStack::Height"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Height",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                },
                {
                  "description": "Stack height",
                  "name": "Height",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the stack is empty.",
              "fullName": "Is empty",
              "functionType": "Condition",
              "name": "IsEmpty",
              "sentence": "The stack of _PARAM0_ is empty",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.objectStack.isEmpty();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "Movement",
      "extensionNamespace": "",
      "fullName": "Curved movement",
      "helpPath": "/extensions/curved-movement/details/",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQoJLnN0MXtmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30NCgkuc3Qye2ZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWRhc2hhcnJheTo2LDY7fQ0KCS5zdDN7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtZGFzaGFycmF5OjQsNDt9DQoJLnN0NHtmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fQ0KCS5zdDV7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1kYXNoYXJyYXk6My4xMDgxLDMuMTA4MTt9DQoJDQoJCS5zdDZ7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5OjQsMzt9DQo8L3N0eWxlPg0KPHJlY3QgeD0iMyIgeT0iMjUiIGNsYXNzPSJzdDAiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiLz4NCjxyZWN0IHg9IjI1IiB5PSIzIiBjbGFzcz0ic3QwIiB3aWR0aD0iNCIgaGVpZ2h0PSI0Ii8+DQo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjUsNUwyNSw1QzE0LDUsNSwxNCw1LDI1djAiLz4NCjwvc3ZnPg0K",
      "name": "CurvedMovement",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Graphic Design/Graphic Design_bezier_curve.svg",
      "shortDescription": "Move objects on curved paths.",
      "version": "1.1.0",
      "description": [
        "This extension allows to move objects on BÃ©zier curve paths.",
        "- Paths can be built dynamically or from predetermined paths in SVG format.",
        "- A behavior moves objects in a given duration a bit like the Tween extension does.",
        "- Another behavior moves objects using a speed and an acceleration.",
        "- Expressions give access to the path trajectory values for more complex movements.",
        "",
        "This extension can be used to:",
        "- Move enemies that follow a pattern",
        "- Animate decorations",
        "",
        "A collection of [small examples](https://editor.gdevelop.io/?project=example://curved-movement) shows how to use this extension.",
        "",
        "2 examples use it:",
        "- a 3D racing game ([open the project online](https://editor.gdevelop.io/?project=example://3d-racing-game))",
        "- a Zuma-like ([open the project online](https://editor.gdevelop.io/?project=example://smoothy))"
      ],
      "origin": {
        "identifier": "CurvedMovement",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "bezier",
        "curve",
        "path",
        "movement",
        "animate",
        "animation",
        "smooth"
      ],
      "authorIds": [
        "AX15J5TSnpSLUglk4nQVamviftr2",
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onFirstSceneLoaded",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "CurvedMovement::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/**",
                " * @param {number[]} array ",
                " * @param {number} value",
                " */",
                "const findLowerIndex = function (array, value) {",
                "  let low = 0;",
                "  let high = array.length - 1;",
                "  let index = 0;",
                "  while (low < high) {",
                "    index = low + (((high - low) / 2) | 0);",
                "    if (array[index] < value) {",
                "      low = index + 1;",
                "    } else {",
                "      high = index;",
                "    }",
                "  }",
                "  if (array[index] > value) {",
                "    index--;",
                "  }",
                "  return index;",
                "};",
                "",
                "const CurvedPath = /** @class */ (function () {",
                "  /**",
                "   * @param {number} speedScaleY Set it to 0.5 for pixel isometry.",
                "   */",
                "  function CurvedPath(speedScaleY = 1) {",
                "    /**",
                "     * @type {CubicBezierCurve[]}",
                "     */",
                "    this.curves = [];",
                "    /**",
                "     * @type {number[]}",
                "     */",
                "    this.curvePreviousLengths = [0];",
                "    /**",
                "     * Set it to 0.5 for pixel isometry.",
                "     */",
                "    this.speedScaleY = speedScaleY;",
                "  };",
                "",
                "  CurvedPath.prototype.getCurvePreviousLengths = function () {",
                "    if (this.curvePreviousLengths.length === 0) {",
                "      let lengthSum = 0;",
                "      this.curvePreviousLengths.push(0);",
                "      for (const curve of this.curves) {",
                "        lengthSum += curve.getLength();",
                "        this.curvePreviousLengths.push(lengthSum);",
                "      }",
                "    }",
                "    return this.curvePreviousLengths;",
                "  }",
                "",
                "  CurvedPath.prototype.clone = function () {",
                "    const clone = new CurvedPath();",
                "    clone.curves = this.curves.map(curve => curve.clone());",
                "    clone.curvePreviousLengths = [...this.curvePreviousLengths];",
                "    return clone;",
                "  };",
                "",
                "  CurvedPath.prototype.getSpeedScaleY = function () {",
                "    return this.speedScaleY;",
                "  };",
                "",
                "  /**",
                "   * @param {number} speedScaleY Set it to 0.5 for pixel isometry.",
                "   */",
                "  CurvedPath.prototype.setSpeedScaleY = function (speedScaleY) {",
                "    if (this.speedScaleY === speedScaleY) {",
                "      return;",
                "    }",
                "    this.scale(1, this.speedScaleY / speedScaleY);",
                "    this.speedScaleY = speedScaleY;",
                "  };",
                "",
                "  /**",
                "   * @param {CubicBezierCurve} curve",
                "   */",
                "  CurvedPath.prototype._add = function (curve) {",
                "    this.curves.push(curve);",
                "    if (this.curvePreviousLengths.length > 0) {",
                "      this.curvePreviousLengths.push(this.getLength() + curve.getLength());",
                "    }",
                "  };",
                "",
                "  /**",
                "   * @param {number} firstControlX",
                "   * @param {number} firstControlY",
                "   * @param {number} secondControlX",
                "   * @param {number} secondControlY",
                "   * @param {number} destinationX",
                "   * @param {number} destinationY",
                "   * @param {boolean} isRelative",
                "   */",
                "  CurvedPath.prototype.addCurve = function (",
                "    firstControlX,",
                "    firstControlY,",
                "    secondControlX,",
                "    secondControlY,",
                "    destinationX,",
                "    destinationY,",
                "    isRelative) {",
                "    const endX = this.getEndX();",
                "    const endY = this.getEndY();",
                "    if (isRelative) {",
                "      firstControlX += endX;",
                "      firstControlY += endY;",
                "      secondControlX += endX;",
                "      secondControlY += endY;",
                "      destinationX += endX;",
                "      destinationY += endY;",
                "    }",
                "    this._add(new CubicBezierCurve(",
                "      endX,",
                "      endY / this.speedScaleY,",
                "      firstControlX,",
                "      firstControlY / this.speedScaleY,",
                "      secondControlX,",
                "      secondControlY / this.speedScaleY,",
                "      destinationX,",
                "      destinationY / this.speedScaleY",
                "    ));",
                "  }",
                "",
                "  /**",
                "   * @param {number} secondControlX",
                "   * @param {number} secondControlY",
                "   * @param {number} destinationX",
                "   * @param {number} destinationY",
                "   * @param {boolean} isRelative",
                "   */",
                "  CurvedPath.prototype.addSmoothCurve = function (",
                "    secondControlX,",
                "    secondControlY,",
                "    destinationX,",
                "    destinationY,",
                "    isRelative) {",
                "    const endX = this.getEndX();",
                "    const endY = this.getEndY();",
                "    if (isRelative) {",
                "      secondControlX += endX;",
                "      secondControlY += endY;",
                "      destinationX += endX;",
                "      destinationY += endY;",
                "    }",
                "    const lastControlX = this.getLastControlX();",
                "    const lastControlY = this.getLastControlY();",
                "    let firstControlX = 2 * endX - lastControlX;",
                "    let firstControlY = 2 * endY - lastControlY;",
                "",
                "    this._add(new CubicBezierCurve(",
                "      endX,",
                "      endY / this.speedScaleY,",
                "      firstControlX,",
                "      firstControlY / this.speedScaleY,",
                "      secondControlX,",
                "      secondControlY / this.speedScaleY,",
                "      destinationX,",
                "      destinationY / this.speedScaleY",
                "    ));",
                "  }",
                "",
                "",
                "  /**",
                "   * @param {number} destinationX",
                "   * @param {number} destinationY",
                "   * @param {boolean} isRelative",
                "   */",
                "  CurvedPath.prototype.addLine = function (",
                "    destinationX,",
                "    destinationY,",
                "    isRelative) {",
                "    const endX = this.getEndX();",
                "    const endY = this.getEndY();",
                "    if (isRelative) {",
                "      destinationX += endX;",
                "      destinationY += endY;",
                "    }",
                "    const lengthX = destinationX - endX;",
                "    const lengthY = destinationY - endY;",
                "",
                "    // TODO Optimize it with an object dedicated to lines.",
                "    this._add(new CubicBezierCurve(",
                "      endX,",
                "      endY / this.speedScaleY,",
                "      endX + lengthX / 3,",
                "      (endY + lengthY / 3) / this.speedScaleY,",
                "      endX + lengthX * 2 / 3,",
                "      (endY + lengthY * 2 / 3) / this.speedScaleY,",
                "      destinationX,",
                "      destinationY / this.speedScaleY",
                "    ));",
                "  }",
                "",
                "  CurvedPath.prototype.close = function () {",
                "    if (this.curves.length === 0) {",
                "      return;",
                "    }",
                "    const firstCurve = this.curves[0];",
                "    this.addLine(firstCurve.getOriginX(), firstCurve.getOriginY(), false);",
                "  }",
                "",
                "  /**",
                "   * @param {CurvedPath} path",
                "   */",
                "  CurvedPath.prototype.append = function (path) {",
                "    const endX = this.getEndX();",
                "    const endY = this.getEndY();",
                "    for (const curve of path.curves) {",
                "      const clone = curve.clone();",
                "      for (const point of clone.points) {",
                "        point[0] += endX;",
                "        point[1] *= path.speedScaleY / this.speedScaleY;",
                "        point[1] += endY;",
                "      }",
                "      this._add(clone);",
                "    }",
                "  };",
                "",
                "  /**",
                "   * @param {CurvedPath} path",
                "   * @param {boolean} shouldFlip",
                "   */",
                "  CurvedPath.prototype.appendRotatedPath = function (path, shouldFlip) {",
                "    const startAngle = Math.atan2(path.curves[0].getFirstControlY(), path.curves[0].getFirstControlX());",
                "    const rotatedPath = path.clone();",
                "    rotatedPath.rotate(this.getEndAngle() - startAngle);",
                "    if (shouldFlip) {",
                "      rotatedPath.flip();",
                "    }",
                "    this.append(rotatedPath, false);",
                "  };",
                "",
                "  CurvedPath.prototype.clear = function () {",
                "    this.curves.length = 0;",
                "    this.curvePreviousLengths.length = 1;",
                "    this.curvePreviousLengths[0] = 0;",
                "  };",
                "",
                "  CurvedPath.prototype.getLength = function () {",
                "    const curvePreviousLengths = this.getCurvePreviousLengths();",
                "    return curvePreviousLengths[curvePreviousLengths.length - 1];",
                "  };",
                "",
                "  CurvedPath.prototype.isClosed = function () {",
                "    if (this.curves.length === 0) {",
                "      return true;",
                "    }",
                "    const firstCurve = this.curves[0];",
                "    const lastCurve = this.curves[this.curves.length - 1];",
                "    return firstCurve.getOriginX() === lastCurve.getTargetX() &&",
                "      firstCurve.getOriginY() === lastCurve.getTargetY();",
                "  };",
                "",
                "  /**",
                "   * @param {number} length",
                "   */",
                "  CurvedPath.prototype.getCurveIndex = function (length) {",
                "    const curvePreviousLengths = this.getCurvePreviousLengths();",
                "    return Math.min(this.curves.length - 1, findLowerIndex(curvePreviousLengths, length));",
                "  };",
                "",
                "  /**",
                "   * @param {number} length",
                "   */",
                "  CurvedPath.prototype.getX = function (length) {",
                "    const curvePreviousLengths = this.getCurvePreviousLengths();",
                "    if (length >= this.getLength()) {",
                "      return this.getEndX();",
                "    }",
                "    const curveIndex = this.getCurveIndex(length);",
                "    const curve = this.curves[curveIndex];",
                "    const curveStartLength = curvePreviousLengths[curveIndex];",
                "    const u = (length - curveStartLength) / curve.getLength();",
                "    return curve.getX(u);",
                "  };",
                "",
                "  /**",
                "   * @param {number} length",
                "   */",
                "  CurvedPath.prototype.getY = function (length) {",
                "    const curvePreviousLengths = this.getCurvePreviousLengths();",
                "    if (length >= this.getLength()) {",
                "      return this.getEndY();",
                "    }",
                "    const curveIndex = this.getCurveIndex(length);",
                "    const curve = this.curves[curveIndex];",
                "    const curveStartLength = curvePreviousLengths[curveIndex];",
                "    const u = (length - curveStartLength) / curve.getLength();",
                "    return curve.getY(u) * this.speedScaleY;",
                "  };",
                "",
                "  const workingPoint = [0, 0];",
                "  /**",
                "   * @param {number} length",
                "   * @param {gdjs.AffineTransformation} transformation",
                "   * @param {[number, number]} transformation",
                "   */",
                "  CurvedPath.prototype.getTransformedPosition = function (length, transformation, result) {",
                "    if (!result) {",
                "      result = workingPoint;",
                "    }",
                "    const curvePreviousLengths = this.getCurvePreviousLengths();",
                "    if (length >= this.getLength()) {",
                "      result[0] = this.getEndX();",
                "      result[1] = this.getEndY();",
                "    }",
                "    else {",
                "      const curveIndex = this.getCurveIndex(length);",
                "      const curve = this.curves[curveIndex];",
                "      const curveStartLength = curvePreviousLengths[curveIndex];",
                "      const u = (length - curveStartLength) / curve.getLength();",
                "      result[0] = curve.getX(u);",
                "      result[1] = curve.getY(u);",
                "    }",
                "    transformation.transform(result, result);",
                "    result[1] *= this.speedScaleY;",
                "    return result;",
                "  };",
                "",
                "  /**",
                "   * @param {number} x",
                "   * @param {number} y",
                "   * @param {gdjs.AffineTransformation} transformation",
                "   * @param {[number, number]} transformation",
                "   */",
                "  CurvedPath.prototype.transformPosition = function (x, y, transformation, result) {",
                "    if (!result) {",
                "      result = workingPoint;",
                "    }",
                "    result[0] = x;",
                "    result[1] = y / this.speedScaleY;",
                "    transformation.transform(result, result);",
                "    result[1] *= this.speedScaleY;",
                "    return result;",
                "  };",
                "",
                "  /**",
                "   * @param {number} length",
                "   */",
                "  CurvedPath.prototype.getAngle = function (length) {",
                "    const curvePreviousLengths = this.getCurvePreviousLengths();",
                "    if (this.curves.length === 0) {",
                "      return 0;",
                "    }",
                "    const curveIndex = this.getCurveIndex(length);",
                "    const curve = this.curves[curveIndex];",
                "    const curveStartLength = curvePreviousLengths[curveIndex];",
                "    const u = (length - curveStartLength) / curve.getLength();",
                "    return curve.getAngle(u);",
                "  };",
                "",
                "  CurvedPath.prototype.getOriginX = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getOriginX();",
                "  };",
                "",
                "  CurvedPath.prototype.getOriginY = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getOriginY() * this.speedScaleY;",
                "  };",
                "",
                "  CurvedPath.prototype.getFirstControlX = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getFirstControlX();",
                "  };",
                "",
                "  CurvedPath.prototype.getFirstControlY = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getFirstControlY() * this.speedScaleY;",
                "  };",
                "",
                "  CurvedPath.prototype.getSecondControlX = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getSecondControlX();",
                "  };",
                "",
                "  CurvedPath.prototype.getSecondControlY = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getSecondControlY() * this.speedScaleY;",
                "  };",
                "",
                "  CurvedPath.prototype.getTargetX = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getTargetX();",
                "  };",
                "",
                "  CurvedPath.prototype.getTargetY = function (curveIndex) {",
                "    return this.curves.length === 0 ? 0 : this.curves[curveIndex].getTargetY() * this.speedScaleY;",
                "  };",
                "",
                "  CurvedPath.prototype.getLastControlX = function () {",
                "    return this.getSecondControlX(this.curves.length - 1);",
                "  };",
                "",
                "  CurvedPath.prototype.getLastControlY = function () {",
                "    return this.getSecondControlY(this.curves.length - 1);",
                "  };",
                "",
                "  CurvedPath.prototype.getEndX = function () {",
                "    return this.getTargetX(this.curves.length - 1);",
                "  };",
                "",
                "  CurvedPath.prototype.getEndY = function () {",
                "    return this.getTargetY(this.curves.length - 1);",
                "  };",
                "",
                "  CurvedPath.prototype.getEndAngle = function () {",
                "    if (this.curves.length === 0) {",
                "      return 0;",
                "    }",
                "    const lastCurve = this.curves[this.curves.length - 1];",
                "    return Math.atan2(",
                "      lastCurve.getTargetY() - lastCurve.getSecondControlY(),",
                "      lastCurve.getTargetX() - lastCurve.getSecondControlX());",
                "  };",
                "",
                "  /**",
                "   * @param {number} translationX",
                "   * @param {number} translationY",
                "   */",
                "  CurvedPath.prototype.translate = function (translationX, translationY) {",
                "    for (const curve of this.curves) {",
                "      for (const point of curve.points) {",
                "        point[0] += translationX;",
                "        point[1] += translationY / this.speedScaleY;",
                "      }",
                "    }",
                "  };",
                "",
                "  /**",
                "   * @param {number} scaleX",
                "   * @param {number} scaleY",
                "   */",
                "  CurvedPath.prototype.scale = function (scaleX, scaleY) {",
                "    for (const curve of this.curves) {",
                "      for (const point of curve.points) {",
                "        point[0] *= scaleX;",
                "        point[1] *= scaleY;",
                "      }",
                "      curve.arcLengths.length = 0;",
                "    }",
                "    this.curvePreviousLengths.length = 0;",
                "  };",
                "",
                "  /**",
                "   * @param {number} angle",
                "   */",
                "  CurvedPath.prototype.rotate = function (angle) {",
                "    let cos = Math.cos(angle);",
                "    let sin = Math.sin(angle);",
                "",
                "    // Avoid rounding errors around 0.",
                "    if (cos === -1 || cos === 1) {",
                "      sin = 0;",
                "    }",
                "    if (sin === -1 || sin === 1) {",
                "      cos = 0;",
                "    }",
                "    ",
                "    for (const curve of this.curves) {",
                "      for (const point of curve.points) {",
                "        const x = point[0];",
                "        const y = point[1];",
                "        point[0] = x * cos - y * sin;",
                "        point[1] = x * sin + y * cos;",
                "      }",
                "      curve.arcLengths.length = 0;",
                "    }",
                "    this.curvePreviousLengths.length = 0;",
                "  };",
                "",
                "  CurvedPath.prototype.invert = function () {",
                "    const endX = this.getEndX();",
                "    const endY = this.getEndY();",
                "    for (const curve of this.curves) {",
                "      for (const point of curve.points) {",
                "        point[0] = point[0] - endX;",
                "        point[1] = point[1] - endY;",
                "      }",
                "      curve.points.reverse();",
                "      curve.arcLengths.length = 0;",
                "    }",
                "    this.curves.reverse();",
                "    this.curvePreviousLengths.length = 0;",
                "  };",
                "",
                "  /**",
                "   * Do a symetry around the first control vector.",
                "   */",
                "  CurvedPath.prototype.flip = function () {",
                "    const axisX = this.curves[0].getFirstControlX();",
                "    const axisY = this.curves[0].getFirstControlY();",
                "    const axisLength = Math.hypot(axisX, axisY);",
                "    const ux = axisX / axisLength;",
                "    const uy = axisY / axisLength;",
                "",
                "    const sx = 2 * ux * ux - 1;",
                "    const sy = 2 * uy * uy - 1;",
                "    const rx = 2 * uy * ux;",
                "    const ry = rx;",
                "",
                "    for (const curve of this.curves) {",
                "      for (const point of curve.points) {",
                "        const x = point[0];",
                "        const y = point[1];",
                "        point[0] = x * sx + y * rx;",
                "        point[1] = x * ry + y * sy;",
                "      }",
                "      curve.arcLengths.length = 0;",
                "    }",
                "    this.curvePreviousLengths.length = 0;",
                "  };",
                "",
                "  return CurvedPath;",
                "})();",
                "",
                "/**",
                " * @param {number} t",
                " * @param {number} a",
                " * @param {number} b",
                " * @param {number} c",
                " * @param {number} d",
                " */",
                "const interpolateCubicCurve = function (t, a, b, c, d) {",
                "  return (",
                "    (1 - t) ** 3 * a +",
                "    3 * (1 - t) ** 2 * t * b +",
                "    3 * (1 - t) * t ** 2 * c +",
                "    t ** 3 * d",
                "  );",
                "};",
                "/**",
                " * @param {number} t",
                " * @param {number} a",
                " * @param {number} b",
                " * @param {number} c",
                " * @param {number} d",
                " */",
                "const interpolateCubicCurveDirection = function (t, a, b, c, d) {",
                "  return (",
                "    3 * (1 - t) ** 2 * (b - a) +",
                "    6 * (1 - t) * t * (c - b) +",
                "    3 * t ** 2 * (d - c)",
                "  );",
                "};",
                "",
                "",
                "const CubicBezierCurve = /** @class */ (function () {",
                "  /**",
                "   * @param {number} aX",
                "   * @param {number} aY",
                "   * @param {number} bX",
                "   * @param {number} bY",
                "   * @param {number} cX",
                "   * @param {number} cY",
                "   * @param {number} dX",
                "   * @param {number} dY",
                "   */",
                "  function CubicBezierCurve(aX, aY, bX, bY, cX, cY, dX, dY) {",
                "    /** @type {[FloatPoint, FloatPoint, FloatPoint, FloatPoint]} */",
                "    this.points = [[aX, aY], [bX, bY], [cX, cY], [dX, dY]];",
                "",
                "    /** @type {number[]} */",
                "    this.arcLengths = [];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.clone = function () {",
                "    const clone = new CubicBezierCurve();",
                "    clone.points = this.points.map(point => [...point]);",
                "    clone.arcLengths = [...this.arcLengths];",
                "    clone.speedScaleY = this.speedScaleY;",
                "    return clone;",
                "  }",
                "",
                "  CubicBezierCurve.prototype.getArcLengths = function () {",
                "    if (this.arcLengths.length === 0) {",
                "      const segmentsCount = 100;",
                "      this.arcLengths.length = segmentsCount + 1;",
                "      this.arcLengths[0] = 0;",
                "",
                "      const aX = this.points[0][0];",
                "      const aY = this.points[0][1];",
                "      const bX = this.points[1][0];",
                "      const bY = this.points[1][1];",
                "      const cX = this.points[2][0];",
                "      const cY = this.points[2][1];",
                "      const dX = this.points[3][0];",
                "      const dY = this.points[3][1];",
                "",
                "      let oldX = aX;",
                "      let oldY = aY;",
                "      let currentLength = 0;",
                "      for (let i = 1; i <= segmentsCount; i += 1) {",
                "        const x = interpolateCubicCurve(i * 0.01, aX, bX, cX, dX);",
                "        const y = interpolateCubicCurve(i * 0.01, aY, bY, cY, dY);",
                "        currentLength += Math.hypot(x - oldX, y - oldY);",
                "        this.arcLengths[i] = currentLength;",
                "        oldX = x;",
                "        oldY = y;",
                "      }",
                "    }",
                "    return this.arcLengths;",
                "  };",
                "",
                "  /**",
                "   * @param {number} u",
                "   */",
                "  CubicBezierCurve.prototype.reparametrizeByArcLength = function (u) {",
                "    const arcLengths = this.getArcLengths();",
                "    const segmentsCount = arcLengths.length - 1;",
                "    const targetLength = u * arcLengths[segmentsCount];",
                "    const index = findLowerIndex(arcLengths, targetLength);",
                "",
                "    const lengthBefore = arcLengths[index];",
                "    if (lengthBefore === targetLength) {",
                "      return index / segmentsCount;",
                "    } else {",
                "      return (",
                "        (index +",
                "          (targetLength - lengthBefore) /",
                "          (arcLengths[index + 1] - lengthBefore)) /",
                "        segmentsCount",
                "      );",
                "    }",
                "  };",
                "",
                "  /**",
                "   * @param {number} u",
                "   */",
                "  CubicBezierCurve.prototype.getX = function (u) {",
                "    return interpolateCubicCurve(",
                "      this.reparametrizeByArcLength(u),",
                "      this.points[0][0],",
                "      this.points[1][0],",
                "      this.points[2][0],",
                "      this.points[3][0]",
                "    );",
                "  };",
                "",
                "  /**",
                "   * @param {number} u",
                "   */",
                "  CubicBezierCurve.prototype.getY = function (u) {",
                "    return interpolateCubicCurve(",
                "      this.reparametrizeByArcLength(u),",
                "      this.points[0][1],",
                "      this.points[1][1],",
                "      this.points[2][1],",
                "      this.points[3][1]",
                "    );",
                "  };",
                "",
                "  /**",
                "   * @param {number} u",
                "   */",
                "  CubicBezierCurve.prototype.getAngle = function (u) {",
                "    const t = this.reparametrizeByArcLength(u);",
                "    const directionX = interpolateCubicCurveDirection(",
                "      t,",
                "      this.points[0][0],",
                "      this.points[1][0],",
                "      this.points[2][0],",
                "      this.points[3][0]",
                "    );",
                "    const directionY = interpolateCubicCurveDirection(",
                "      t,",
                "      this.points[0][1],",
                "      this.points[1][1],",
                "      this.points[2][1],",
                "      this.points[3][1]",
                "    );",
                "    return Math.atan2(directionY, directionX);",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getLength = function () {",
                "    const arcLengths = this.getArcLengths();",
                "    return arcLengths[arcLengths.length - 1];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getOriginX = function () {",
                "    return this.points[0][0];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getOriginY = function () {",
                "    return this.points[0][1];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getFirstControlX = function () {",
                "    return this.points[1][0];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getFirstControlY = function () {",
                "    return this.points[1][1];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getSecondControlX = function () {",
                "    return this.points[2][0];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getSecondControlY = function () {",
                "    return this.points[2][1];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getTargetX = function () {",
                "    return this.points[3][0];",
                "  };",
                "",
                "  CubicBezierCurve.prototype.getTargetY = function () {",
                "    return this.points[3][1];",
                "  };",
                "",
                "  return CubicBezierCurve;",
                "})();",
                "",
                "const pathRegex = /[CcSsLlMmHhVvZz]|(?:-?\\d+(?:\\.\\d+)?(?:e-?\\d+)?)/g;",
                "const svgActions = [\"c\", \"s\", \"l\", \"m\", \"v\", \"h\", \"z\"];",
                "",
                "/**",
                " * @param {string} svgComandsString",
                " */",
                "CurvedPath.parsePath = function (svgComandsString) {",
                "  const regExpResults = svgComandsString.match(pathRegex);",
                "  if (!regExpResults) {",
                "    return null;",
                "  }",
                "  const path = new CurvedPath();",
                "  let currentAction = \"\";",
                "  let isRelative = false;",
                "  let originX = 0;",
                "  let originY = 0;",
                "  for (let index = 0; index < regExpResults.length; index++) {",
                "    const regExpResult = regExpResults[index];",
                "    if (regExpResult.length === 1) {",
                "      const lowerCaseRegExpResult = regExpResult.toLowerCase();",
                "      if (svgActions.indexOf(lowerCaseRegExpResult) >= 0) {",
                "        currentAction = lowerCaseRegExpResult;",
                "        isRelative = lowerCaseRegExpResult === regExpResult;",
                "        index++;",
                "      }",
                "    }",
                "    switch (currentAction) {",
                "      case \"c\":",
                "        {",
                "          if (regExpResults.length < index + 5) {",
                "            break;",
                "          }",
                "          const firstControlX = Number.parseFloat(regExpResults[index + 0]);",
                "          const firstControlY = Number.parseFloat(regExpResults[index + 1]);",
                "          const secondControlX = Number.parseFloat(regExpResults[index + 2]);",
                "          const secondControlY = Number.parseFloat(regExpResults[index + 3]);",
                "          const destinationX = Number.parseFloat(regExpResults[index + 4]);",
                "          const destinationY = Number.parseFloat(regExpResults[index + 5]);",
                "          index += 5;",
                "          if (isRelative) {",
                "            path.addCurve(",
                "              firstControlX,",
                "              firstControlY,",
                "              secondControlX,",
                "              secondControlY,",
                "              destinationX,",
                "              destinationY,",
                "              isRelative);",
                "          }",
                "          else {",
                "            // Movement paths always start at (0;0).",
                "            path.addCurve(",
                "              -originX + firstControlX,",
                "              -originY + firstControlY,",
                "              -originX + secondControlX,",
                "              -originY + secondControlY,",
                "              -originX + destinationX,",
                "              -originY + destinationY,",
                "              isRelative);",
                "          }",
                "          break;",
                "        }",
                "      case \"s\":",
                "        {",
                "          if (regExpResults.length < index + 3) {",
                "            break;",
                "          }",
                "          const secondControlX = Number.parseFloat(regExpResults[index + 0]);",
                "          const secondControlY = Number.parseFloat(regExpResults[index + 1]);",
                "          const destinationX = Number.parseFloat(regExpResults[index + 2]);",
                "          const destinationY = Number.parseFloat(regExpResults[index + 3]);",
                "          index += 3;",
                "          if (isRelative) {",
                "            path.addSmoothCurve(",
                "              secondControlX,",
                "              secondControlY,",
                "              destinationX,",
                "              destinationY,",
                "              isRelative);",
                "          }",
                "          else {",
                "            // Movement paths always start at (0;0).",
                "            path.addSmoothCurve(",
                "              -originX + secondControlX,",
                "              -originY + secondControlY,",
                "              -originX + destinationX,",
                "              -originY + destinationY,",
                "              isRelative);",
                "          }",
                "          break;",
                "        }",
                "      case \"l\":",
                "        {",
                "          if (regExpResults.length < index + 1) {",
                "            break;",
                "          }",
                "          const destinationX = Number.parseFloat(regExpResults[index + 0]);",
                "          const destinationY = Number.parseFloat(regExpResults[index + 1]);",
                "          index++;",
                "          if (isRelative) {",
                "            path.addLine(",
                "              destinationX,",
                "              destinationY,",
                "              isRelative);",
                "          }",
                "          else {",
                "            // Movement paths always start at (0;0).",
                "            path.addLine(",
                "              -originX + destinationX,",
                "              -originY + destinationY,",
                "              isRelative);",
                "          }",
                "          break;",
                "        }",
                "      case \"m\":",
                "        {",
                "          if (regExpResults.length < index + 1) {",
                "            break;",
                "          }",
                "          if (index === 1) {",
                "            originX = Number.parseFloat(regExpResults[index + 0]) || 0;",
                "            originY = Number.parseFloat(regExpResults[index + 1]) || 0;",
                "          }",
                "          index++;",
                "          currentAction = \"l\";",
                "          break;",
                "        }",
                "      case \"h\":",
                "        {",
                "          if (regExpResults.length < index) {",
                "            break;",
                "          }",
                "          const destinationX = Number.parseFloat(regExpResults[index + 0]);",
                "          const destinationY = 0;",
                "          if (isRelative) {",
                "            path.addLine(",
                "              destinationX,",
                "              destinationY,",
                "              isRelative);",
                "          }",
                "          else {",
                "            // Movement paths always start at (0;0).",
                "            path.addLine(",
                "              -originX + destinationX,",
                "              -originY + destinationY,",
                "              isRelative);",
                "          }",
                "          break;",
                "        }",
                "      case \"v\":",
                "        {",
                "          if (regExpResults.length < index) {",
                "            break;",
                "          }",
                "          const destinationX = 0;",
                "          const destinationY = Number.parseFloat(regExpResults[index + 0]);",
                "          if (isRelative) {",
                "            path.addLine(",
                "              destinationX,",
                "              destinationY,",
                "              isRelative);",
                "          }",
                "          else {",
                "            // Movement paths always start at (0;0).",
                "            path.addLine(",
                "              -originX + destinationX,",
                "              -originY + destinationY,",
                "              isRelative);",
                "          }",
                "          break;",
                "        }",
                "      case \"z\":",
                "        {",
                "          path.close();",
                "          break;",
                "        }",
                "      default:",
                "        break;",
                "    }",
                "  }",
                "//  if (originX !== 0 && originY !== 0) {",
                "//    path.translate(-originX, -originY);",
                "//    path.curves[0].getOriginX = 0;",
                "//  }",
                "  return path;",
                "}",
                "",
                "/**",
                " * @param {CurvedPath} path",
                " */",
                "CurvedPath.toSvg = function (path) {",
                "  let svgString = '';",
                "  for (const curve of path.curves) {",
                "    svgString += 'C'",
                "    for (const point of curve.points) {",
                "      svgString += `${point[0]},${point[1]} `;",
                "    }",
                "  }",
                "  return svgString;",
                "}",
                "",
                "gdjs.__curvedMovementExtension = gdjs.__curvedMovementExtension || {};",
                "gdjs.__curvedMovementExtension.CurvedPath = CurvedPath;",
                "",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onSceneLoaded",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "runtimeScene.__curvedMovementExtension = { curvedPaths: new Map() };"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Append a cubic Bezier curve at the end of the path.",
          "fullName": "Append a curve",
          "functionType": "Action",
          "name": "AddCubicCurve",
          "sentence": "Append a curve to the path _PARAM1_ relatively to the end: _PARAM8_, first control point: _PARAM2_ ; _PARAM3_, second control point: _PARAM4_ ; _PARAM5_,  destination: _PARAM6_ ; _PARAM7_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (!curvedPath) {",
                "    curvedPath = new gdjs.__curvedMovementExtension.CurvedPath();",
                "    curvedPaths.set(pathName, curvedPath);",
                "}",
                "",
                "let firstControlX = eventsFunctionContext.getArgument(\"FirstControlX\");",
                "let firstControlY = eventsFunctionContext.getArgument(\"FirstControlY\");",
                "let secondControlX = eventsFunctionContext.getArgument(\"SecondControlX\");",
                "let secondControlY = eventsFunctionContext.getArgument(\"SecondControlY\");",
                "let destinationX = eventsFunctionContext.getArgument(\"DestinationX\");",
                "let destinationY = eventsFunctionContext.getArgument(\"DestinationY\");",
                "let isRelative = eventsFunctionContext.getArgument(\"IsRelative\");",
                "",
                "curvedPath.addCurve(",
                "    firstControlX,",
                "    firstControlY,",
                "    secondControlX,",
                "    secondControlY,",
                "    destinationX,",
                "    destinationY,",
                "    isRelative",
                ");",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "First control point X",
              "name": "FirstControlX",
              "type": "expression"
            },
            {
              "description": "First control point Y",
              "name": "FirstControlY",
              "type": "expression"
            },
            {
              "description": "Second Control point X",
              "name": "SecondControlX",
              "type": "expression"
            },
            {
              "description": "Second Control point Y",
              "name": "SecondControlY",
              "type": "expression"
            },
            {
              "description": "Destination point X",
              "name": "DestinationX",
              "type": "expression"
            },
            {
              "description": "Destination point Y",
              "name": "DestinationY",
              "type": "expression"
            },
            {
              "defaultValue": "yes",
              "description": "Relative",
              "name": "IsRelative",
              "optional": true,
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Append a cubic Bezier curve to the end of an object's path. The first control point is symmetrical to the last control point of the path.",
          "fullName": "Append a smooth curve",
          "functionType": "Action",
          "name": "AddSmoothCubicCurve",
          "sentence": "Append a smooth curve to the path _PARAM1_ relatively to the end: _PARAM6_, second control point: _PARAM2_ ; _PARAM3_,  destination: _PARAM4_ ; _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (!curvedPath) {",
                "    curvedPath = new gdjs.__curvedMovementExtension.CurvedPath();",
                "    curvedPaths.set(pathName, curvedPath);",
                "}",
                "",
                "let secondControlX = eventsFunctionContext.getArgument(\"SecondControlX\");",
                "let secondControlY = eventsFunctionContext.getArgument(\"SecondControlY\");",
                "let destinationX = eventsFunctionContext.getArgument(\"DestinationX\");",
                "let destinationY = eventsFunctionContext.getArgument(\"DestinationY\");",
                "let isRelative = eventsFunctionContext.getArgument(\"IsRelative\");",
                "",
                "curvedPath.addSmoothCurve(",
                "    secondControlX,",
                "    secondControlY,",
                "    destinationX,",
                "    destinationY,",
                "    isRelative",
                ");",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Second Control point X",
              "name": "SecondControlX",
              "type": "expression"
            },
            {
              "description": "Second Control point Y",
              "name": "SecondControlY",
              "type": "expression"
            },
            {
              "description": "Destination point X",
              "name": "DestinationX",
              "type": "expression"
            },
            {
              "description": "Destination point Y",
              "name": "DestinationY",
              "type": "expression"
            },
            {
              "defaultValue": "yes",
              "description": "Relative",
              "name": "IsRelative",
              "optional": true,
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Append a line at the end of the path.",
          "fullName": "Append a line",
          "functionType": "Action",
          "name": "AddLine",
          "sentence": "Append a line to the path _PARAM1_ relatively to the end: _PARAM4_,  destination: _PARAM2_ ; _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (!curvedPath) {",
                "    curvedPath = new gdjs.__curvedMovementExtension.CurvedPath();",
                "    curvedPaths.set(pathName, curvedPath);",
                "}",
                "",
                "let destinationX = eventsFunctionContext.getArgument(\"DestinationX\");",
                "let destinationY = eventsFunctionContext.getArgument(\"DestinationY\");",
                "let isRelative = eventsFunctionContext.getArgument(\"IsRelative\");",
                "",
                "curvedPath.addLine(",
                "    destinationX,",
                "    destinationY,",
                "    isRelative",
                ");",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Destination point X",
              "name": "DestinationX",
              "type": "expression"
            },
            {
              "description": "Destination point Y",
              "name": "DestinationY",
              "type": "expression"
            },
            {
              "defaultValue": "yes",
              "description": "Relative",
              "name": "IsRelative",
              "optional": true,
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Append a line to close the path.",
          "fullName": "Close a path",
          "functionType": "Action",
          "name": "ClosePath",
          "sentence": "Close the path _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (!curvedPath) {",
                "    curvedPath = new gdjs.__curvedMovementExtension.CurvedPath();",
                "    curvedPaths.set(pathName, curvedPath);",
                "}",
                "",
                "curvedPath.close();",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Create a path from SVG commands, for instance \"M 0,0 C 55,0 100,45 100,100\". Commands are: M = Move, C = Curve, S = Smooth, L = Line. Lower case is for relative positions. The preferred way to build the commands is to use an external SVG editor like Inkscape.",
          "fullName": "Create a path from SVG",
          "functionType": "Action",
          "name": "CreatePathFromSvg",
          "sentence": "Create the path _PARAM1_ from the SVG path commands _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "\r",
                "const svgCommandsString = eventsFunctionContext.getArgument(\"SvgCommandsString\");\r",
                "\r",
                "curvedPaths.set(pathName, gdjs.__curvedMovementExtension.CurvedPath.parsePath(svgCommandsString));\r",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "SVG commands",
              "name": "SvgCommandsString",
              "supplementaryInformation": "scene",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the SVG commands of a path.",
          "fullName": "SVG path commands",
          "functionType": "StringExpression",
          "name": "ToSvg",
          "sentence": "Create the path _PARAM1_ from the SVG path commands _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "\r",
                "let curvedPath = curvedPaths.get(pathName);\r",
                "eventsFunctionContext.returnValue = curvedPath ? gdjs.__curvedMovementExtension.CurvedPath.toSvg(curvedPath) : '';\r",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Delete a path from the memory.",
          "fullName": "Delete a path",
          "functionType": "Action",
          "name": "DeletePath",
          "sentence": "Delete the path: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "curvedPaths.delete(pathName);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Append a path to another path.",
          "fullName": "Append a path",
          "functionType": "Action",
          "name": "AppendPath",
          "sentence": "Append the path _PARAM2_ to the path _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const modifiedPathName = eventsFunctionContext.getArgument(\"ModifiedPathName\");",
                "const addedPathName = eventsFunctionContext.getArgument(\"AddedPathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let addedPath = curvedPaths.get(addedPathName);",
                "if (addedPath) {",
                "    let modifiedPath = curvedPaths.get(modifiedPathName);",
                "    if (!modifiedPath) {",
                "        modifiedPath = new gdjs.__curvedMovementExtension.CurvedPath();",
                "        curvedPaths.set(modifiedPathName, modifiedPath);",
                "    }",
                "    modifiedPath.append(addedPath);",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Name of the path to modify",
              "name": "ModifiedPathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Name of the path to add to the first one",
              "name": "AddedPathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Duplicate a path.",
          "fullName": "Duplicate a path",
          "functionType": "Action",
          "name": "DuplicatedPath",
          "sentence": "Create path _PARAM1_ as a duplicate of path _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const createdPathName = eventsFunctionContext.getArgument(\"CreatedPathName\");",
                "const sourcePathName = eventsFunctionContext.getArgument(\"SourcePathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let sourcePath = curvedPaths.get(sourcePathName);",
                "if (sourcePath) {",
                "    const createdPath = sourcePath.clone();",
                "    curvedPaths.set(createdPathName, createdPath);",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Name of the path to create",
              "name": "CreatedPathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Name of the source path",
              "name": "SourcePathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Append a path to another path. The appended path is rotated to have a smooth junction.",
          "fullName": "Append a rotated path",
          "functionType": "Action",
          "name": "AppendRotatedPath",
          "sentence": "Append the path _PARAM2_ rotated to connect to the path _PARAM1_ flip: _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const modifiedPathName = eventsFunctionContext.getArgument(\"ModifiedPathName\");",
                "const addedPathName = eventsFunctionContext.getArgument(\"AddedPathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let addedPath = curvedPaths.get(addedPathName);",
                "if (addedPath) {",
                "    let modifiedPath = curvedPaths.get(modifiedPathName);",
                "    if (!modifiedPath) {",
                "        modifiedPath = new gdjs.__curvedMovementExtension.CurvedPath();",
                "        curvedPaths.set(modifiedPathName, modifiedPath);",
                "    }",
                "    const shouldFlip = eventsFunctionContext.getArgument(\"ShouldFlip\");",
                "    modifiedPath.appendRotatedPath(addedPath, shouldFlip);",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Name of the path to modify",
              "name": "ModifiedPathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Name of the path to add to the first one",
              "name": "AddedPathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Flip the appended path",
              "name": "ShouldFlip",
              "type": "yesorno"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the speed scale on Y axis. This is used to change the view point of a path (top-dwon or isometry).",
          "fullName": "Speed scale Y",
          "functionType": "Expression",
          "group": "Path transformation",
          "name": "SpeedScaleY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "const curvedPath = curvedPaths.get(pathName);",
                "eventsFunctionContext.returnValue = curvedPath ?Â curvedPath.getSpeedScaleY() : 0;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the speed scale on Y axis. This allows to change the view point of a path (top-dwon or isometry).",
          "fullName": "Speed scale Y",
          "functionType": "Action",
          "group": "Path transformation",
          "name": "SetSpeedScaleY",
          "sentence": "Change the speed scale Y of the path _PARAM1_ to _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (curvedPath) {",
                "    const scaleY = eventsFunctionContext.getArgument(\"ScaleY\");",
                "    curvedPath.setSpeedScaleY(scaleY);",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Speed scale on Y axis (0.5 for pixel isometry)",
              "name": "ScaleY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Invert a path, the end becomes the beginning.",
          "fullName": "Invert a path",
          "functionType": "Action",
          "group": "Path transformation",
          "name": "InvertPath",
          "sentence": "Invert the path _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (curvedPath) {",
                "    curvedPath.invert();",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Flip a path.",
          "fullName": "Flip a path",
          "functionType": "Action",
          "group": "Path transformation",
          "name": "FlipPath",
          "private": true,
          "sentence": "Flip the path _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (curvedPath) {",
                "    curvedPath.flip();",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Flip a path horizontally.",
          "fullName": "Flip a path horizontally",
          "functionType": "Action",
          "group": "Path transformation",
          "name": "FlipPathX",
          "private": true,
          "sentence": "Flip the path _PARAM1_ horizontally",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "CurvedMovement::ScalePath"
                  },
                  "parameters": [
                    "",
                    "\"\"",
                    "-1",
                    "1",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Flip a path vertically.",
          "fullName": "Flip a path vertically",
          "functionType": "Action",
          "group": "Path transformation",
          "name": "FlipPathY",
          "private": true,
          "sentence": "Flip the path _PARAM1_ vertically",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "CurvedMovement::ScalePath"
                  },
                  "parameters": [
                    "",
                    "\"\"",
                    "1",
                    "-1",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Scale a path.",
          "fullName": "Scale a path",
          "functionType": "Action",
          "group": "Path transformation",
          "name": "ScalePath",
          "sentence": "Scale the path _PARAM1_ by _PARAM2_ ; _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (curvedPath) {",
                "    const scaleX = eventsFunctionContext.getArgument(\"ScaleX\");",
                "    const scaleY = eventsFunctionContext.getArgument(\"ScaleY\");",
                "    curvedPath.scale(scaleX, scaleY);",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Scale on X axis",
              "name": "ScaleX",
              "type": "expression"
            },
            {
              "description": "Scale on Y axis",
              "name": "ScaleY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Rotate a path.",
          "fullName": "Rotate a path",
          "functionType": "Action",
          "group": "Path transformation",
          "name": "RotatePath",
          "sentence": "Rotate _PARAM2_Â° the path _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "let curvedPath = curvedPaths.get(pathName);",
                "if (curvedPath) {",
                "    const angle = eventsFunctionContext.getArgument(\"Angle\") * Math.PI / 180;",
                "    curvedPath.rotate(angle);",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Rotation angle",
              "name": "Angle",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a path is closed.",
          "fullName": "Is  closed",
          "functionType": "Condition",
          "name": "IsClosed",
          "sentence": "The path _PARAM1_ is closed",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "",
                "const curvedPath = curvedPaths.get(pathName);",
                "eventsFunctionContext.returnValue = curvedPath && curvedPath.isClosed();",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the position on X axis of the path for a given length.",
          "fullName": "Path X",
          "functionType": "Expression",
          "name": "PathX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "const curvedPath = curvedPaths.get(pathName);",
                "",
                "const length = eventsFunctionContext.getArgument(\"Length\");",
                "",
                "eventsFunctionContext.returnValue = curvedPath ? curvedPath.getX(length) : 0;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Length on the path",
              "name": "Length",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the position on Y axis of the path for a given length.",
          "fullName": "Path Y",
          "functionType": "Expression",
          "name": "PathY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "const curvedPath = curvedPaths.get(pathName);",
                "",
                "const length = eventsFunctionContext.getArgument(\"Length\");",
                "",
                "eventsFunctionContext.returnValue = curvedPath ? curvedPath.getY(length) : 0;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Length on the path",
              "name": "Length",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the direction angle of the path for a given length (in degree).",
          "fullName": "Path angle",
          "functionType": "Expression",
          "name": "PathAngle",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "const curvedPath = curvedPaths.get(pathName);",
                "",
                "const length = eventsFunctionContext.getArgument(\"Length\");",
                "",
                "eventsFunctionContext.returnValue = curvedPath ? curvedPath.getAngle(length) * 180 / Math.PI : 0;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Length on the path",
              "name": "Length",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the length of the path.",
          "fullName": "Path length",
          "functionType": "Expression",
          "name": "PathLength",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                "const curvedPath = curvedPaths.get(pathName);",
                "",
                "eventsFunctionContext.returnValue = curvedPath ? curvedPath.getLength() : 0;",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the displacement on X axis of the path end.",
          "fullName": "Path end X",
          "functionType": "Expression",
          "name": "PathEndX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "eventsFunctionContext.returnValue = curvedPath ? curvedPath.getEndX() : 0;"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the displacement on Y axis of the path end.",
          "fullName": "Path end Y",
          "functionType": "Expression",
          "name": "PathEndY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "eventsFunctionContext.returnValue = curvedPath ? curvedPath.getEndY() : 0;\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the number of lines or curves that make the path.",
          "fullName": "Path element count",
          "functionType": "Expression",
          "group": "Path element",
          "name": "ElementCount",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "eventsFunctionContext.returnValue = curvedPath ? curvedPath.curves.length : 0;\r",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the origin position on X axis of a curve.",
          "fullName": "Origin X",
          "functionType": "Expression",
          "group": "Path element",
          "name": "OriginX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getOriginX(index) : 0);\r",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the origin position on Y axis of a curve.",
          "fullName": "Origin Y",
          "functionType": "Expression",
          "group": "Path element",
          "name": "OriginY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getOriginY(index) : 0);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the first control point position on X axis of a curve.",
          "fullName": "First control X",
          "functionType": "Expression",
          "group": "Path element",
          "name": "FirstControlX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getFirstControlX(index) : 0);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the first control point position on Y axis of a curve.",
          "fullName": "First control Y",
          "functionType": "Expression",
          "group": "Path element",
          "name": "FirstControlY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getFirstControlY(index) : 0);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the second control point position on X axis of a curve.",
          "fullName": "Second control X",
          "functionType": "Expression",
          "group": "Path element",
          "name": "SecondControlX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getSecondControlX(index) : 0);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the second control point position on Y axis of a curve.",
          "fullName": "Second control Y",
          "functionType": "Expression",
          "group": "Path element",
          "name": "SecondControlY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getSecondControlY(index) : 0);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the target position on X axis of a curve.",
          "fullName": "Target X",
          "functionType": "Expression",
          "group": "Path element",
          "name": "TargetX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getTargetX(index) : 0);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the target position on Y axis of a curve.",
          "fullName": "Target Y",
          "functionType": "Expression",
          "group": "Path element",
          "name": "TargetY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "/** @type {number} */\r",
                "const index = eventsFunctionContext.getArgument(\"Index\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (\r",
                "  (curvedPath && index >= 0 && index < curvedPath.curves.length)\r",
                "  ? curvedPath.getTargetY(index) : 0);"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            },
            {
              "description": "Curve index",
              "name": "Index",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Path exists.",
          "fullName": "Path exists",
          "functionType": "Condition",
          "name": "PathExists",
          "sentence": "Path _PARAM1_ exists",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "const pathName = eventsFunctionContext.getArgument(\"PathName\");\r",
                "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */\r",
                "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;\r",
                "const curvedPath = curvedPaths.get(pathName);\r",
                "\r",
                "eventsFunctionContext.returnValue = !!curvedPath;"
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Path name",
              "name": "PathName",
              "supplementaryInformation": "sceneBezierCurve",
              "type": "identifier"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "Move objects on curved paths in a given duration and tween easing function.",
          "fullName": "Movement on a curve (duration-based)",
          "name": "TweenPathMovement",
          "objectType": "Sprite",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Back and forth states",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "CurvedMovement::TweenPathMovement::HasReachedAnEnd"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::TweenPathMovement::PropertyShouldGoBack"
                          },
                          "parameters": [
                            "Object",
                            "Behavior"
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "colorB": 228,
                          "colorG": 176,
                          "colorR": 74,
                          "creationTime": 0,
                          "name": "Wait",
                          "source": "",
                          "type": "BuiltinCommonInstructions::Group",
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "value": "CurvedMovement::TweenPathMovement::PropertyPauseDurationBeforeGoingBack"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    ">",
                                    "0"
                                  ]
                                },
                                {
                                  "type": {
                                    "inverted": true,
                                    "value": "CompareObjectTimer"
                                  },
                                  "parameters": [
                                    "Object",
                                    "\"__CurvedMovement.Wait\"",
                                    ">=",
                                    "0"
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "ResetObjectTimer"
                                  },
                                  "parameters": [
                                    "Object",
                                    "\"__CurvedMovement.Wait\""
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "value": "CompareObjectTimer"
                                  },
                                  "parameters": [
                                    "Object",
                                    "\"__CurvedMovement.Wait\"",
                                    ">=",
                                    "Object.Behavior::PropertyPauseDurationBeforeGoingBack()"
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "RemoveObjectTimer"
                                  },
                                  "parameters": [
                                    "Object",
                                    "\"__CurvedMovement.Wait\""
                                  ]
                                }
                              ]
                            }
                          ],
                          "parameters": []
                        },
                        {
                          "colorB": 228,
                          "colorG": 176,
                          "colorR": 74,
                          "creationTime": 0,
                          "name": "Change of direction",
                          "source": "",
                          "type": "BuiltinCommonInstructions::Group",
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "inverted": true,
                                    "value": "CompareObjectTimer"
                                  },
                                  "parameters": [
                                    "Object",
                                    "\"__CurvedMovement.Wait\"",
                                    ">=",
                                    "0"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "BuiltinCommonInstructions::Or"
                                  },
                                  "parameters": [],
                                  "subInstructions": [
                                    {
                                      "type": {
                                        "inverted": true,
                                        "value": "CurvedMovement::TweenPathMovement::PropertyIsGoingBack"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior"
                                      ]
                                    },
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::PropertyShouldLoop"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior"
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "ResetObjectTimer"
                                  },
                                  "parameters": [
                                    "Object",
                                    "\"__CurvedMovement.Time\""
                                  ]
                                }
                              ],
                              "events": [
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [
                                    {
                                      "type": {
                                        "inverted": true,
                                        "value": "CurvedMovement::TweenPathMovement::PropertyIsGoingBack"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior"
                                      ]
                                    }
                                  ],
                                  "actions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::SetPropertyOrigin"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "=",
                                        "1"
                                      ]
                                    },
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::SetPropertyTarget"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "=",
                                        "0"
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::PropertyIsGoingBack"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior"
                                      ]
                                    }
                                  ],
                                  "actions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::SetPropertyOrigin"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "=",
                                        "0"
                                      ]
                                    },
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::SetPropertyTarget"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "=",
                                        "1"
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::PropertyTarget"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "=",
                                        "1"
                                      ]
                                    }
                                  ],
                                  "actions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::SetPropertyIsGoingBack"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        ""
                                      ]
                                    }
                                  ],
                                  "events": [
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "CurvedMovement::TweenPathMovement::PropertyFlipXToGoBack"
                                          },
                                          "parameters": [
                                            "Object",
                                            "Behavior"
                                          ]
                                        }
                                      ],
                                      "actions": [
                                        {
                                          "type": {
                                            "value": "FlipX"
                                          },
                                          "parameters": [
                                            "Object",
                                            "no"
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "CurvedMovement::TweenPathMovement::PropertyFlipYToGoBack"
                                          },
                                          "parameters": [
                                            "Object",
                                            "Behavior"
                                          ]
                                        }
                                      ],
                                      "actions": [
                                        {
                                          "type": {
                                            "value": "FlipY"
                                          },
                                          "parameters": [
                                            "Object",
                                            "no"
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::PropertyTarget"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "=",
                                        "0"
                                      ]
                                    }
                                  ],
                                  "actions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::SetPropertyIsGoingBack"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "yes"
                                      ]
                                    }
                                  ],
                                  "events": [
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "CurvedMovement::TweenPathMovement::PropertyFlipXToGoBack"
                                          },
                                          "parameters": [
                                            "Object",
                                            "Behavior"
                                          ]
                                        }
                                      ],
                                      "actions": [
                                        {
                                          "type": {
                                            "value": "FlipX"
                                          },
                                          "parameters": [
                                            "Object",
                                            "yes"
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "CurvedMovement::TweenPathMovement::PropertyFlipYToGoBack"
                                          },
                                          "parameters": [
                                            "Object",
                                            "Behavior"
                                          ]
                                        }
                                      ],
                                      "actions": [
                                        {
                                          "type": {
                                            "value": "FlipY"
                                          },
                                          "parameters": [
                                            "Object",
                                            "yes"
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ],
                          "parameters": []
                        }
                      ]
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Move on the path",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "inverted": true,
                            "value": "CurvedMovement::TweenPathMovement::HasReachedAnEnd"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "CurvedMovement::TweenPathMovement::UpdatePosition"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "CurvedMovement::TweenPathMovement::PropertyRotation"
                              },
                              "parameters": [
                                "Object",
                                "Behavior"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "SetAngle"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyPathAngle() + CurvedMovement::PathAngle(Object.Behavior::PropertyPathName(), Object.Behavior::RepeatedPathPosition()) + Object.Behavior::PropertyRotationOffset() + Object.Behavior::BackOrForthAngle()"
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set the the object on the path according to the current length.",
              "fullName": "Update position",
              "functionType": "Action",
              "name": "UpdatePosition",
              "private": true,
              "sentence": "Update the position of _PARAM0_ on the path",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "/** @type {string} */",
                    "const pathName = behavior._getPathName();",
                    "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                    "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                    "const curvedPath = curvedPaths.get(pathName);",
                    "if (!curvedPath) {",
                    "    return;",
                    "}",
                    "",
                    "behavior.workingTransformation = behavior.workingTransformation || new gdjs.AffineTransformation();",
                    "/** @type {gdjs.AffineTransformation} */",
                    "const transformation = behavior.workingTransformation;",
                    "",
                    "const repetitionDone = behavior.RepetitionDone();",
                    "transformation.setToTranslation(",
                    "    repetitionDone * behavior.PathEndX(),",
                    "    repetitionDone * behavior.PathEndY() / behavior.PathSpeedScaleY()",
                    ");",
                    "transformation.preConcatenate(behavior.curvedMovementTransformation);",
                    "",
                    "/** @type {number} */",
                    "const length = behavior.RepeatedPathPosition();",
                    "/** @type {[number, number]} */",
                    "const point = curvedPath.getTransformedPosition(length, transformation);",
                    "const x = point[0] + behavior._getPathOriginX();",
                    "const y = point[1] + behavior._getPathOriginY();",
                    "object.setPosition(x, y);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move the object to a position by following a path.",
              "fullName": "Move on path to a position",
              "functionType": "Action",
              "name": "MoveTo",
              "sentence": "Move _PARAM0_ to _PARAM6_ ; _PARAM7_ on the path: _PARAM2_ do _PARAM3_ times in _PARAM4_ seconds with _PARAM5_ easing",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathName"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsString(\"PathName\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyDuration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Duration\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyEasing"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsString(\"Easing\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyRepetitionCount"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"RepetitionCount\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldGoBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathOriginX"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.X()"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathOriginY"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Y()"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathAngle"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "AngleBetweenPositions(Object.X(), Object.Y(), GetArgumentAsNumber(\"DestinationX\"), Object.Y() + (GetArgumentAsNumber(\"DestinationY\") - Object.Y()) / Object.Behavior::PathSpeedScaleY()) - AngleBetweenPositions(0, 0, Object.Behavior::PathEndX(),  Object.Behavior::PathEndY() / Object.Behavior::PathSpeedScaleY())"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathScale"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "DistanceBetweenPositions(Object.X(), Object.Y(), GetArgumentAsNumber(\"DestinationX\"), Object.Y() + (GetArgumentAsNumber(\"DestinationY\") - Object.Y()) / Object.Behavior::PathSpeedScaleY()) / DistanceBetweenPositions(0, 0, Object.Behavior::PathEndX(), Object.Behavior::PathEndY() / Object.Behavior::PathSpeedScaleY()) / GetArgumentAsNumber(\"RepetitionCount\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::InitializeMovement"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Path name",
                  "longDescription": "The path can be define with the \"Append curve\" action.",
                  "name": "PathName",
                  "supplementaryInformation": "sceneBezierCurve",
                  "type": "identifier"
                },
                {
                  "description": "Number of repetitions",
                  "name": "RepetitionCount",
                  "type": "expression"
                },
                {
                  "description": "Duration in seconds",
                  "name": "Duration",
                  "type": "expression"
                },
                {
                  "description": "Easing",
                  "name": "Easing",
                  "supplementaryInformation": "[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]",
                  "type": "stringWithSelector"
                },
                {
                  "description": "Destination X",
                  "name": "DestinationX",
                  "type": "expression"
                },
                {
                  "description": "Destination Y",
                  "name": "DestinationY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move the object to a position by following a path and go back.",
              "fullName": "Move back and forth to a position",
              "functionType": "Action",
              "name": "MoveToAndGoBack",
              "sentence": "Move back and forth _PARAM0_ to _PARAM6_ ; _PARAM7_ on the path: _PARAM2_ do _PARAM3_ times  in _PARAM4_ seconds with _PARAM5_ easing, wait _PARAM8_ seconds before going back and loop: _PARAM9_ ",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::MoveTo"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "GetArgumentAsString(\"PathName\")",
                        "GetArgumentAsNumber(\"RepetitionCount\")",
                        "GetArgumentAsNumber(\"Duration\")",
                        "GetArgumentAsString(\"Easing\")",
                        "GetArgumentAsNumber(\"DestinationX\")",
                        "GetArgumentAsNumber(\"DestinationY\")",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldGoBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPauseDurationBeforeGoingBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"WaitBeforeGoingBackDuration\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldLoop\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "="
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldLoop\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Path name",
                  "longDescription": "The path can be define with the \"Append curve\" action.",
                  "name": "PathName",
                  "supplementaryInformation": "sceneBezierCurve",
                  "type": "identifier"
                },
                {
                  "description": "Number of repetitions",
                  "name": "RepetitionCount",
                  "type": "expression"
                },
                {
                  "description": "Duration in seconds",
                  "name": "Duration",
                  "type": "expression"
                },
                {
                  "description": "Easing",
                  "name": "Easing",
                  "supplementaryInformation": "[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]",
                  "type": "stringWithSelector"
                },
                {
                  "description": "Destination X",
                  "name": "DestinationX",
                  "type": "expression"
                },
                {
                  "description": "Destination Y",
                  "name": "DestinationY",
                  "type": "expression"
                },
                {
                  "description": "Duration to wait before going back",
                  "name": "WaitBeforeGoingBackDuration",
                  "type": "expression"
                },
                {
                  "description": "Loop",
                  "name": "ShouldLoop",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move the object by following a path.",
              "fullName": "Move on path",
              "functionType": "Action",
              "name": "Move",
              "sentence": "Move _PARAM0_ on the path: _PARAM2_ do _PARAM3_ times in _PARAM4_ seconds with _PARAM5_ easing",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathName"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsString(\"PathName\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyDuration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Duration\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyEasing"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsString(\"Easing\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyRepetitionCount"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"RepetitionCount\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldGoBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathOriginX"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.X()"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathOriginY"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Y()"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathAngle"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPathScale"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "1"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::InitializeMovement"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Path name",
                  "longDescription": "The path can be define with the \"Append curve\" action.",
                  "name": "PathName",
                  "supplementaryInformation": "sceneBezierCurve",
                  "type": "identifier"
                },
                {
                  "description": "Number of repetitions",
                  "name": "RepetitionCount",
                  "type": "expression"
                },
                {
                  "description": "Duration in seconds",
                  "name": "Duration",
                  "type": "expression"
                },
                {
                  "description": "Easing",
                  "name": "Easing",
                  "supplementaryInformation": "[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move the object by following a path and go back.",
              "fullName": "Move back and forth",
              "functionType": "Action",
              "name": "MoveAndGoBack",
              "sentence": "Move back and forth _PARAM0_ on the path: _PARAM2_ do _PARAM3_ times  in _PARAM4_ seconds with _PARAM5_ easing, wait _PARAM6_ seconds before going back and loop: _PARAM7_ ",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::Move"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "GetArgumentAsString(\"PathName\")",
                        "GetArgumentAsNumber(\"RepetitionCount\")",
                        "GetArgumentAsNumber(\"Duration\")",
                        "GetArgumentAsString(\"Easing\")",
                        "GetArgumentAsNumber(\"DestinationX\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldGoBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyPauseDurationBeforeGoingBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"WaitBeforeGoingBackDuration\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldLoop\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "="
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldLoop\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Path name",
                  "longDescription": "The path can be define with the \"Append curve\" action.",
                  "name": "PathName",
                  "supplementaryInformation": "sceneBezierCurve",
                  "type": "identifier"
                },
                {
                  "description": "Number of repetitions",
                  "name": "RepetitionCount",
                  "type": "expression"
                },
                {
                  "description": "Duration in seconds",
                  "name": "Duration",
                  "type": "expression"
                },
                {
                  "description": "Easing",
                  "name": "Easing",
                  "supplementaryInformation": "[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]",
                  "type": "stringWithSelector"
                },
                {
                  "description": "Duration to wait before going back",
                  "name": "WaitBeforeGoingBackDuration",
                  "type": "expression"
                },
                {
                  "description": "Loop",
                  "name": "ShouldLoop",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object has reached one of the 2 ends of the path.",
              "fullName": "Reached an end",
              "functionType": "Condition",
              "name": "HasReachedAnEnd",
              "sentence": "_PARAM0_ reached an end of the path",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::CompareNumbers"
                      },
                      "parameters": [
                        "Object.Behavior::Progress()",
                        "=",
                        "Object.Behavior::PropertyTarget()"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object has finished to move on the path.",
              "fullName": "Finished to move",
              "functionType": "Condition",
              "name": "HasFinishedToMove",
              "sentence": "_PARAM0_ has finished to move",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "value": "CurvedMovement::TweenPathMovement::PropertyShouldLoop"
                          },
                          "parameters": [
                            "Object",
                            "Behavior"
                          ]
                        },
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::And"
                          },
                          "parameters": [],
                          "subInstructions": [
                            {
                              "type": {
                                "value": "CurvedMovement::TweenPathMovement::HasReachedAnEnd"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "BuiltinCommonInstructions::Or"
                              },
                              "parameters": [],
                              "subInstructions": [
                                {
                                  "type": {
                                    "inverted": true,
                                    "value": "CurvedMovement::TweenPathMovement::PropertyShouldGoBack"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "BuiltinCommonInstructions::And"
                                  },
                                  "parameters": [],
                                  "subInstructions": [
                                    {
                                      "type": {
                                        "value": "CurvedMovement::TweenPathMovement::PropertyShouldGoBack"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior"
                                      ]
                                    },
                                    {
                                      "type": {
                                        "inverted": true,
                                        "value": "CurvedMovement::TweenPathMovement::PropertyIsGoingBack"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior"
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the angle of movement on its path.",
              "fullName": "Movement angle",
              "functionType": "Expression",
              "name": "MovementAngle",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyPathAngle() + CurvedMovement::PathAngle(Object.Behavior::PropertyPathName(), Object.Behavior::RepeatedPathPosition()) + Object.Behavior::PropertyRotationOffset() + Object.Behavior::BackOrForthAngle()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Draw the object trajectory.",
              "fullName": "Draw the trajectory",
              "functionType": "Action",
              "group": "Debug",
              "name": "DrawDebug",
              "sentence": "Draw trajectory of _PARAM0_ on _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "PrimitiveDrawing::UseRelativeCoordinates"
                      },
                      "parameters": [
                        "ShapePainter",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "PrimitiveDrawing::FillOpacity"
                      },
                      "parameters": [
                        "ShapePainter",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "PrimitiveDrawing::OutlineSize"
                      },
                      "parameters": [
                        "ShapePainter",
                        "=",
                        "1"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/** @type {gdjs.ShapePainterRuntimeObject} */",
                    "const shapePainter = eventsFunctionContext.getObjects(\"ShapePainter\")[0];",
                    "if (!shapePainter) {",
                    "    return ;",
                    "}",
                    "",
                    "/** @type {string} */",
                    "const pathName = behavior._getPathName();",
                    "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                    "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                    "const curvedPath = curvedPaths.get(pathName);",
                    "if (!curvedPath) {",
                    "    return ;",
                    "}",
                    "",
                    "/** @type {gdjs.AffineTransformation} */",
                    "const transformation = behavior.curvedMovementTransformation;",
                    "let point = behavior.curvedMovementWorkingPoint || [0, 0];",
                    "",
                    "let originX = behavior._getPathOriginX();",
                    "let originY = behavior._getPathOriginY();",
                    "shapePainter.drawPathMoveTo(originX, originY);",
                    "const repetitionCount = behavior._getRepetitionCount();",
                    "let previousLastTargetX = 0;",
                    "let previousLastTargetY = 0;",
                    "const endX = curvedPath.getEndX();",
                    "const endY = curvedPath.getEndY();",
                    "for (let repetitionIndex = 0; repetitionIndex < repetitionCount; repetitionIndex++) {",
                    "  for (let curveIndex = 0; curveIndex < curvedPath.curves.length; curveIndex++) {",
                    "    point[0] = curvedPath.getFirstControlX(curveIndex) + previousLastTargetX;",
                    "    point[1] = curvedPath.getFirstControlY(curveIndex) + previousLastTargetY;",
                    "    if (transformation) {",
                    "      point = curvedPath.transformPosition(point[0], point[1], transformation, point);",
                    "    }",
                    "    const firstControlX = point[0];",
                    "    const firstControlY = point[1];",
                    "",
                    "    point[0] = curvedPath.getSecondControlX(curveIndex) + previousLastTargetX;",
                    "    point[1] = curvedPath.getSecondControlY(curveIndex) + previousLastTargetY;",
                    "    if (transformation) {",
                    "      point = curvedPath.transformPosition(point[0], point[1], transformation, point);",
                    "    }",
                    "    const secondControlX = point[0];",
                    "    const secondControlY = point[1];",
                    "",
                    "    point[0] = curvedPath.getTargetX(curveIndex) + previousLastTargetX;",
                    "    point[1] = curvedPath.getTargetY(curveIndex) + previousLastTargetY;",
                    "    if (transformation) {",
                    "      point = curvedPath.transformPosition(point[0], point[1], transformation, point);",
                    "    }",
                    "    const targetX = point[0];",
                    "    const targetY = point[1];",
                    "",
                    "    shapePainter.drawPathBezierCurveTo(",
                    "      firstControlX + originX,",
                    "      firstControlY + originY,",
                    "      secondControlX + originX,",
                    "      secondControlY + originY,",
                    "      targetX + originX,",
                    "      targetY + originY);",
                    "  }",
                    "  previousLastTargetX += endX;",
                    "  previousLastTargetY += endY;",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Shape painter",
                  "name": "ShapePainter",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the transformation to apply to the path.",
              "fullName": "Path transformation",
              "functionType": "Action",
              "name": "SetTransformation",
              "private": true,
              "sentence": "Change the path trasformation of _PARAM0_ to origin _PARAM2_; _PARAM3_ scale by _PARAM4_ and a rotation of _PARAM5_Â°",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": []
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "const scale = eventsFunctionContext.getArgument(\"Scale\");",
                    "const angle = eventsFunctionContext.getArgument(\"Angle\");",
                    "",
                    "/** @type {gdjs.AffineTransformation} */",
                    "const transformation = behavior.curvedMovementTransformation || new gdjs.AffineTransformation()",
                    "transformation.setToScale(scale, scale);",
                    "transformation.rotate(angle / 180 * Math.PI);",
                    "",
                    "behavior.curvedMovementTransformation = transformation;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Origin X",
                  "name": "OriginX",
                  "type": "expression"
                },
                {
                  "description": "Origin Y",
                  "name": "OriginY",
                  "type": "expression"
                },
                {
                  "description": "Scale",
                  "name": "Scale",
                  "type": "expression"
                },
                {
                  "description": "Angle",
                  "name": "Angle",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Initialize the movement state.",
              "fullName": "Initialize the movement",
              "functionType": "Action",
              "name": "InitializeMovement",
              "private": true,
              "sentence": "Initialize the movement of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyViewpoint"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Top-down\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SetSpeedScaleY"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyPathName()",
                        "1",
                        "0.5"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyViewpoint"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Isometry 2:1 (26.565Â°)\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SetSpeedScaleY"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyPathName()",
                        "0.5",
                        "0.5"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetTransformation"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "Object.X()",
                        "Object.Y()",
                        "Object.Behavior::PropertyPathScale()",
                        "Object.Behavior::PropertyPathAngle()",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ResetObjectTimer"
                      },
                      "parameters": [
                        "Object",
                        "\"__CurvedMovement.Time\""
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyIsGoingBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyOrigin"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::SetPropertyTarget"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "1"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::PropertyFlipXToGoBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "FlipX"
                      },
                      "parameters": [
                        "Object",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::PropertyFlipYToGoBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "FlipY"
                      },
                      "parameters": [
                        "Object",
                        "no"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the number of repetitions between the current position and the origin.",
              "fullName": "Repetition done",
              "functionType": "Expression",
              "name": "RepetitionDone",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "floor(Object.Behavior::Progress() * Object.Behavior::PropertyRepetitionCount())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the position on one repeated path.",
              "fullName": "Path position",
              "functionType": "Expression",
              "name": "RepeatedPathPosition",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PathLength() * mod(Object.Behavior::Progress(), 1 / Object.Behavior::PropertyRepetitionCount()) * Object.Behavior::PropertyRepetitionCount()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the progress on the full path from 0 to 1, where 0 means the origin and 1 the end.",
              "fullName": "Progress",
              "functionType": "Expression",
              "name": "Progress",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Tween::Ease(Object.Behavior::PropertyEasing(), Object.Behavior::PropertyOrigin(), Object.Behavior::PropertyTarget(),  min(1, Object.ObjectTimerElapsedTime(\"__CurvedMovement.Time\") / Object.Behavior::PropertyDuration()))"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the length of the path (one repetition only).",
              "fullName": "Path length",
              "functionType": "Expression",
              "name": "PathLength",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::PathLength(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the displacement on X axis of the path end.",
              "fullName": "Path end X",
              "functionType": "Expression",
              "name": "PathEndX",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::PathEndX(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the displacement on Y axis of the path end.",
              "fullName": "Path end Y",
              "functionType": "Expression",
              "name": "PathEndY",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::PathEndY(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the speed scale on Y axis of the path.",
              "fullName": "Path speed scale Y",
              "functionType": "Expression",
              "name": "PathSpeedScaleY",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::SpeedScaleY(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the angle to use when the object is going back or not.",
              "fullName": "Back or forth angle",
              "functionType": "Expression",
              "name": "BackOrForthAngle",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::TweenPathMovement::PropertyIsGoingBack"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "180"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::TweenPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "true",
              "type": "Boolean",
              "label": "Rotate object",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Rotation"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "DegreeAngle",
              "label": "Rotation offset",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "RotationOffset"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Flip on X to go back",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "FlipXToGoBack"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Flip on Y to go back",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "FlipYToGoBack"
            },
            {
              "value": "1",
              "type": "Number",
              "label": "Speed scale",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "SpeedScale"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathOriginX"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathOriginY"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Target"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Origin"
            },
            {
              "value": "",
              "type": "String",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathName"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Duration"
            },
            {
              "value": "",
              "type": "String",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Easing"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DrawingElementIndex"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "X"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Y"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathAngle"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathScale"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "RepetitionCount"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "ShouldGoBack"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "ShouldLoop"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "RepetitionDoneCount"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "IsGoingBack"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Pause duration before going back",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PauseDurationBeforeGoingBack"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DrawingPathOriginX"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DrawingPathOriginY"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DebugLineStrokeWidth"
            },
            {
              "value": "Top-Down",
              "type": "Choice",
              "label": "Viewpoint",
              "description": "",
              "group": "",
              "extraInformation": [
                "Top-Down",
                "Isometry 2:1 (26.565Â°)"
              ],
              "name": "Viewpoint"
            }
          ],
          "sharedPropertyDescriptors": []
        },
        {
          "description": "Move objects on curved paths at a given speed.",
          "fullName": "Movement on a curve (speed-based)",
          "name": "SpeedPathMovement",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Move on the path",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::CanMoveFurther"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyPreviousSpeed"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "Object.Behavior::PropertySpeed()"
                          ]
                        }
                      ],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Comment",
                          "color": {
                            "b": 109,
                            "g": 230,
                            "r": 255,
                            "textB": 0,
                            "textG": 0,
                            "textR": 0
                          },
                          "comment": "Update speed"
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "!=",
                                "Object.Behavior::PropertyTargetedSpeed()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::SetPropertySpeed"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "+",
                                "Object.Behavior::PropertyAcceleration() * TimeDelta()"
                              ]
                            }
                          ],
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "value": "BuiltinCommonInstructions::CompareNumbers"
                                  },
                                  "parameters": [
                                    "sign(Object.Behavior::PropertyAcceleration())",
                                    "!=",
                                    "sign(Object.Behavior::PropertyTargetedSpeed() - Object.Behavior::PropertySpeed())"
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "CurvedMovement::SpeedPathMovement::SetPropertySpeed"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "Object.Behavior::PropertyTargetedSpeed()"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "CurvedMovement::SpeedPathMovement::SetPropertyAcceleration"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "0"
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Comment",
                          "color": {
                            "b": 109,
                            "g": 230,
                            "r": 255,
                            "textB": 0,
                            "textG": 0,
                            "textR": 0
                          },
                          "comment": "Update the position on the path (the current length) with a Verlet integration."
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::SetPositionOnPath"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "+",
                                "(Object.Behavior::PropertyPreviousSpeed() + Object.Behavior::PropertySpeed()) * TimeDelta() / 2",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Comment",
                          "color": {
                            "b": 109,
                            "g": 230,
                            "r": 255,
                            "textB": 0,
                            "textG": 0,
                            "textR": 0
                          },
                          "comment": "It's useful to know which way to look at when the speed reached 0."
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "<",
                                "0"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::SetPropertyIsLookingBack"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "yes"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ">",
                                "0"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::SetPropertyIsLookingBack"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "no"
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the path followed by an object.",
              "fullName": "Follow a path",
              "functionType": "Action",
              "name": "SetPath",
              "sentence": "_PARAM0_ follow the path: _PARAM2_ do _PARAM3_ times and loop: _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathName"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsString(\"PathName\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyRepetitionCount"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "min(1, GetArgumentAsNumber(\"RepetitionCount\"))"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldLoop\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldLoop\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathOriginX"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.X()"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathOriginY"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Y()"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathAngle"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathScale"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "1"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::InitializeMovement"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Path name",
                  "longDescription": "The path can be define with the \"Append curve\" action.",
                  "name": "PathName",
                  "supplementaryInformation": "sceneBezierCurve",
                  "type": "identifier"
                },
                {
                  "description": "Number of repetitions",
                  "name": "RepetitionCount",
                  "type": "expression"
                },
                {
                  "description": "Loop",
                  "name": "ShouldLoop",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the path followed by an object to reach a position.",
              "fullName": "Follow a path to a position",
              "functionType": "Action",
              "name": "SetPathTo",
              "sentence": "_PARAM0_ follow the path _PARAM2_ do _PARAM3_ times to reach _PARAM5_ ; _PARAM6_ and loop: _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "When the path is close or empty, there is no way to reach a destination"
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "CurvedMovement::IsClosed"
                      },
                      "parameters": [
                        "",
                        "GetArgumentAsString(\"PathName\")",
                        ""
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathName"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "GetArgumentAsString(\"PathName\")"
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyRepetitionCount"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "min(1, GetArgumentAsNumber(\"RepetitionCount\"))"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "inverted": true,
                            "value": "GetArgumentAsBoolean"
                          },
                          "parameters": [
                            "\"ShouldLoop\""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyShouldLoop"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "no"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "GetArgumentAsBoolean"
                          },
                          "parameters": [
                            "\"ShouldLoop\""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyShouldLoop"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "yes"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathOriginX"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "Object.X()"
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathOriginY"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "Object.Y()"
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathAngle"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "AngleBetweenPositions(Object.X(), Object.Y(), GetArgumentAsNumber(\"DestinationX\"), Object.Y() + (GetArgumentAsNumber(\"DestinationY\") - Object.Y()) / Object.Behavior::PathSpeedScaleY()) - AngleBetweenPositions(0, 0, Object.Behavior::PathEndX(),  Object.Behavior::PathEndY() / Object.Behavior::PathSpeedScaleY())"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPropertyPathScale"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "DistanceBetweenPositions(Object.X(), Object.Y(), GetArgumentAsNumber(\"DestinationX\"), Object.Y() + (GetArgumentAsNumber(\"DestinationY\") - Object.Y()) / Object.Behavior::PathSpeedScaleY()) / DistanceBetweenPositions(0, 0, Object.Behavior::PathEndX(), Object.Behavior::PathEndY() / Object.Behavior::PathSpeedScaleY()) / GetArgumentAsNumber(\"RepetitionCount\")"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::InitializeMovement"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        }
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Path name",
                  "longDescription": "The path can be define with the \"Append curve\" action.",
                  "name": "PathName",
                  "supplementaryInformation": "sceneBezierCurve",
                  "type": "identifier"
                },
                {
                  "description": "Number of repetitions",
                  "name": "RepetitionCount",
                  "type": "expression"
                },
                {
                  "description": "Loop",
                  "name": "ShouldLoop",
                  "type": "yesorno"
                },
                {
                  "description": "Destination X",
                  "name": "DestinationX",
                  "type": "expression"
                },
                {
                  "description": "Destination Y",
                  "name": "DestinationY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the length between the trajectory origin and the current position without counting the loops.",
              "fullName": "Position on the loop",
              "functionType": "ExpressionAndCondition",
              "name": "PositionOnLoop",
              "sentence": "the length from the trajectory origin in the current loop",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "mod(Object.Behavior::PropertyCurrentLength(), Object.Behavior::TotalLength())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the number time the object loop the trajectory.",
              "fullName": "Current loop",
              "functionType": "ExpressionAndCondition",
              "name": "Loop",
              "sentence": "the current loop",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "ceil(Object.Behavior::PropertyCurrentLength() / Object.Behavior::TotalLength())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the length between the trajectory origin and the current position counting the loops.",
              "fullName": "Position on the path",
              "functionType": "ExpressionAndCondition",
              "name": "PositionOnPath",
              "sentence": "the length from the trajectory origin counting the loops",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyCurrentLength()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the position of the object on the path.",
              "fullName": "Position on the path",
              "functionType": "ActionWithOperator",
              "getterName": "PositionOnPath",
              "name": "SetPositionOnPath",
              "sentence": "Change the position of _PARAM0_ on the path at the length _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "CurvedMovement::SpeedPathMovement::PropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyCurrentLength"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "clamp(GetArgumentAsNumber(\"Value\"), 0, Object.Behavior::TotalLength())"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyShouldLoop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyCurrentLength"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::UpdatePosition"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyRotation"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetAngle"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.Behavior::PropertyPathAngle() + CurvedMovement::PathAngle(Object.Behavior::PropertyPathName(), Object.Behavior::RepeatedPathPosition()) + Object.Behavior::PropertyRotationOffset() + Object.Behavior::BackOrForthAngle()"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Length",
                  "name": "Length",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set the the object on the path according to the current length.",
              "fullName": "Update position",
              "functionType": "Action",
              "name": "UpdatePosition",
              "private": true,
              "sentence": "Update the position of _PARAM0_ on the path",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "/** @type {string} */",
                    "const pathName = behavior._getPathName();",
                    "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                    "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                    "const curvedPath = curvedPaths.get(pathName);",
                    "if (!curvedPath) {",
                    "    return;",
                    "}",
                    "",
                    "behavior.workingTransformation = behavior.workingTransformation || new gdjs.AffineTransformation();",
                    "/** @type {gdjs.AffineTransformation} */",
                    "const transformation = behavior.workingTransformation;",
                    "",
                    "const repetitionDone = behavior.RepetitionDone();",
                    "transformation.setToTranslation(",
                    "    repetitionDone * behavior.PathEndX(),",
                    "    repetitionDone * behavior.PathEndY() / behavior.PathSpeedScaleY()",
                    ");",
                    "transformation.preConcatenate(behavior.curvedMovementTransformation);",
                    "",
                    "/** @type {number} */",
                    "const length = behavior.RepeatedPathPosition();",
                    "/** @type {[number, number]} */",
                    "const point = curvedPath.getTransformedPosition(length, transformation);",
                    "const x = point[0] + behavior._getPathOriginX();",
                    "const y = point[1] + behavior._getPathOriginY();",
                    "object.setPosition(x, y);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the length from the trajectory origin is lesser than a value.",
              "fullName": "Current length",
              "functionType": "Condition",
              "name": "CheckPositionOnPath",
              "private": true,
              "sentence": "_PARAM0_ is less than _PARAM2_ pixels away from the trajectory origin",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::CompareNumbers"
                      },
                      "parameters": [
                        "Object.Behavior::PositionOnLoop()",
                        "<",
                        "GetArgumentAsNumber(\"Length\")"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Length from the trajectory origin (in pixels)",
                  "name": "Length",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object has reached the origin position of the path.",
              "fullName": "Reached path origin",
              "functionType": "Condition",
              "name": "HasReachedOrigin",
              "sentence": "_PARAM0_ reached the path beginning",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyCurrentLength"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "<=",
                        "0"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object has reached the target position of the path.",
              "fullName": "Reached path target",
              "functionType": "Condition",
              "name": "HasReachedTarget",
              "sentence": "_PARAM0_ reached the path target",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyCurrentLength"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Behavior::TotalLength()"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ">=",
                        "0"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object has reached one of the 2 ends of the path.",
              "fullName": "Reach an end",
              "functionType": "Condition",
              "name": "HasReachedAnEnd",
              "sentence": "_PARAM0_ reached an end of the path",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::HasReachedTarget"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::HasReachedOrigin"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object can still move in the current direction.",
              "fullName": "Can move further",
              "functionType": "Condition",
              "name": "CanMoveFurther",
              "sentence": "_PARAM0_ can move further on its path",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "!=",
                            "0"
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::PropertyAcceleration"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "!=",
                            "0"
                          ]
                        }
                      ]
                    },
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::PropertyShouldLoop"
                          },
                          "parameters": [
                            "Object",
                            "Behavior"
                          ]
                        },
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::And"
                          },
                          "parameters": [],
                          "subInstructions": [
                            {
                              "type": {
                                "inverted": true,
                                "value": "CurvedMovement::SpeedPathMovement::HasReachedTarget"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "BuiltinCommonInstructions::Or"
                              },
                              "parameters": [],
                              "subInstructions": [
                                {
                                  "type": {
                                    "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    ">",
                                    "0"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "CurvedMovement::SpeedPathMovement::PropertyAcceleration"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    ">",
                                    "0"
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::And"
                          },
                          "parameters": [],
                          "subInstructions": [
                            {
                              "type": {
                                "inverted": true,
                                "value": "CurvedMovement::SpeedPathMovement::HasReachedOrigin"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "BuiltinCommonInstructions::Or"
                              },
                              "parameters": [],
                              "subInstructions": [
                                {
                                  "type": {
                                    "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "<",
                                    "0"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "CurvedMovement::SpeedPathMovement::PropertyAcceleration"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "<",
                                    "0"
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the angle of movement on its path.",
              "fullName": "Movement angle",
              "functionType": "Expression",
              "name": "MovementAngle",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyPathAngle() + CurvedMovement::PathAngle(Object.Behavior::PropertyPathName(), Object.Behavior::RepeatedPathPosition()) + Object.Behavior::PropertyRotationOffset() + Object.Behavior::BackOrForthAngle()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the speed of the object.",
              "fullName": "Speed",
              "functionType": "ExpressionAndCondition",
              "name": "Speed",
              "sentence": "the speed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertySpeed()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the current speed of the object.",
              "fullName": "Speed",
              "functionType": "ActionWithOperator",
              "getterName": "Speed",
              "name": "SetSpeed",
              "sentence": "Change the speed of _PARAM0_ to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertySpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyTargetedSpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Speed (in pixels per second)",
                  "name": "Speed",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Make an object accelerate until it reaches a given speed.",
              "fullName": "Accelerate",
              "functionType": "Action",
              "name": "AccelarateAt",
              "sentence": "_PARAM0_ accelerate at _PARAM3_ to reach the speed of _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyTargetedSpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"TargetedSpeed\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyAcceleration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Acceleration\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedAnEnd"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertySpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Targeted speed (in pixels per second)",
                  "name": "TargetedSpeed",
                  "type": "expression"
                },
                {
                  "description": "Acceleration (in pixels per second per second)",
                  "name": "Acceleration",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Make an object accelerate to reaches a speed in a given amount of time.",
              "fullName": "Accelerate during",
              "functionType": "Action",
              "name": "AccelarateDuring",
              "sentence": "_PARAM0_ accelerate during _PARAM3_ seconds to reach the speed of _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyTargetedSpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"TargetedSpeed\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertyAcceleration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "(GetArgumentAsNumber(\"TargetedSpeed\") - Object.Behavior::PropertySpeed()) / GetArgumentAsNumber(\"Duration\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedAnEnd"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPropertySpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Targeted speed (in pixels per second)",
                  "name": "TargetedSpeed",
                  "type": "expression"
                },
                {
                  "description": "Duration (in seconds)",
                  "name": "Duration",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Draw the object trajectory.",
              "fullName": "Draw the trajectory",
              "functionType": "Action",
              "group": "Debug",
              "name": "DrawDebug",
              "sentence": "Draw trajectory of _PARAM0_ on _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "PrimitiveDrawing::UseRelativeCoordinates"
                      },
                      "parameters": [
                        "ShapePainter",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "PrimitiveDrawing::FillOpacity"
                      },
                      "parameters": [
                        "ShapePainter",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "PrimitiveDrawing::OutlineSize"
                      },
                      "parameters": [
                        "ShapePainter",
                        "=",
                        "ShapePainter.OutlineSize()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/** @type {gdjs.ShapePainterRuntimeObject} */",
                    "const shapePainter = eventsFunctionContext.getObjects(\"ShapePainter\")[0];",
                    "if (!shapePainter) {",
                    "    return ;",
                    "}",
                    "",
                    "/** @type {string} */",
                    "const pathName = behavior._getPathName();",
                    "/** @type {Map<string, gdjs.__curvedMovementExtension.CurvedPath>} */",
                    "const curvedPaths = runtimeScene.__curvedMovementExtension.curvedPaths;",
                    "const curvedPath = curvedPaths.get(pathName);",
                    "if (!curvedPath) {",
                    "    return ;",
                    "}",
                    "",
                    "/** @type {gdjs.AffineTransformation} */",
                    "const transformation = behavior.curvedMovementTransformation;",
                    "let point = behavior.curvedMovementWorkingPoint || [0, 0];",
                    "",
                    "let originX = behavior._getPathOriginX();",
                    "let originY = behavior._getPathOriginY();",
                    "shapePainter.drawPathMoveTo(originX, originY);",
                    "const repetitionCount = behavior._getRepetitionCount();",
                    "let previousLastTargetX = 0;",
                    "let previousLastTargetY = 0;",
                    "const endX = curvedPath.getEndX();",
                    "const endY = curvedPath.getEndY();",
                    "for (let repetitionIndex = 0; repetitionIndex < repetitionCount; repetitionIndex++) {",
                    "  for (let curveIndex = 0; curveIndex < curvedPath.curves.length; curveIndex++) {",
                    "    point[0] = curvedPath.getFirstControlX(curveIndex) + previousLastTargetX;",
                    "    point[1] = curvedPath.getFirstControlY(curveIndex) + previousLastTargetY;",
                    "    if (transformation) {",
                    "      point = curvedPath.transformPosition(point[0], point[1], transformation, point);",
                    "    }",
                    "    const firstControlX = point[0];",
                    "    const firstControlY = point[1];",
                    "",
                    "    point[0] = curvedPath.getSecondControlX(curveIndex) + previousLastTargetX;",
                    "    point[1] = curvedPath.getSecondControlY(curveIndex) + previousLastTargetY;",
                    "    if (transformation) {",
                    "      point = curvedPath.transformPosition(point[0], point[1], transformation, point);",
                    "    }",
                    "    const secondControlX = point[0];",
                    "    const secondControlY = point[1];",
                    "",
                    "    point[0] = curvedPath.getTargetX(curveIndex) + previousLastTargetX;",
                    "    point[1] = curvedPath.getTargetY(curveIndex) + previousLastTargetY;",
                    "    if (transformation) {",
                    "      point = curvedPath.transformPosition(point[0], point[1], transformation, point);",
                    "    }",
                    "    const targetX = point[0];",
                    "    const targetY = point[1];",
                    "",
                    "    shapePainter.drawPathBezierCurveTo(",
                    "      firstControlX + originX,",
                    "      firstControlY + originY,",
                    "      secondControlX + originX,",
                    "      secondControlY + originY,",
                    "      targetX + originX,",
                    "      targetY + originY);",
                    "  }",
                    "  previousLastTargetX += endX;",
                    "  previousLastTargetY += endY;",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Shape painter",
                  "name": "ShapePainter",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the transformation to apply to the path.",
              "fullName": "Path transformation",
              "functionType": "Action",
              "name": "SetTransformation",
              "private": true,
              "sentence": "Change the path trasformation of _PARAM0_ to origin _PARAM2_; _PARAM3_ scale by _PARAM4_ and a rotation of _PARAM5_Â°",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": []
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "const scale = eventsFunctionContext.getArgument(\"Scale\");",
                    "const angle = eventsFunctionContext.getArgument(\"Angle\");",
                    "",
                    "/** @type {gdjs.AffineTransformation} */",
                    "const transformation = behavior.curvedMovementTransformation || new gdjs.AffineTransformation()",
                    "transformation.setToScale(scale, scale);",
                    "transformation.rotate(angle / 180 * Math.PI);",
                    "",
                    "behavior.curvedMovementTransformation = transformation;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                },
                {
                  "description": "Origin X",
                  "name": "OriginX",
                  "type": "expression"
                },
                {
                  "description": "Origin Y",
                  "name": "OriginY",
                  "type": "expression"
                },
                {
                  "description": "Scale",
                  "name": "Scale",
                  "type": "expression"
                },
                {
                  "description": "Angle",
                  "name": "Angle",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Initialize the movement state.",
              "fullName": "Initialize the movement",
              "functionType": "Action",
              "name": "InitializeMovement",
              "private": true,
              "sentence": "Initialize the movement of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyViewpoint"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Top-down\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SetSpeedScaleY"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyPathName()",
                        "1",
                        "0.5"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::PropertyViewpoint"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Isometry 2:1 (26.565Â°)\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SetSpeedScaleY"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyPathName()",
                        "0.5",
                        "0.5"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetTransformation"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "Object.X()",
                        "Object.Y()",
                        "Object.Behavior::PropertyPathScale()",
                        "Object.Behavior::PropertyPathAngle()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPositionOnPath"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the position on one repeated path.",
              "fullName": "Repeated path position",
              "functionType": "Expression",
              "name": "RepeatedPathPosition",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedTarget"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "mod(Object.Behavior::PositionOnLoop(), Object.Behavior::PathLength())"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "When the object reaches the target, it must stay on the last repetition end and not at the start of a new one."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedTarget"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PathLength()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the number of repetitions between the current position and the origin.",
              "fullName": "Repetition done",
              "functionType": "Expression",
              "name": "RepetitionDone",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedTarget"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "floor(Object.Behavior::PositionOnLoop() / Object.Behavior::PathLength())"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "When the object reaches the target, it must stay on the last repetition end and not at the start of a new one."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedTarget"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyRepetitionCount() - 1"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the progress on the full path from 0 to 1, where 0 means the origin and 1 the end.",
              "fullName": "Progress",
              "functionType": "Expression",
              "name": "Progress",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "mod(Object.Behavior::PositionOnLoop(), Object.Behavior::TotalLength())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the length of the path (one repetition only).",
              "fullName": "Path length",
              "functionType": "Expression",
              "name": "PathLength",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::PathLength(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the length of the complete trajectory (without looping).",
              "fullName": "Total length",
              "functionType": "Expression",
              "name": "TotalLength",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::PathLength(Object.Behavior::PropertyPathName()) * Object.Behavior::PropertyRepetitionCount()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the displacement on X axis of the path end.",
              "fullName": "Path end X",
              "functionType": "Expression",
              "name": "PathEndX",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::PathEndX(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the displacement on Y axis of the path end.",
              "fullName": "Path end Y",
              "functionType": "Expression",
              "name": "PathEndY",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::PathEndY(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the speed scale on Y axis of the path.",
              "fullName": "Path speed scale Y",
              "functionType": "Expression",
              "name": "PathSpeedScaleY",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CurvedMovement::SpeedScaleY(Object.Behavior::PropertyPathName())"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the angle to use when the object is going back or not.",
              "fullName": "Back or forth angle",
              "functionType": "Expression",
              "name": "BackOrForthAngle",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::PropertySpeed"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "<",
                            "0"
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::PropertyIsLookingBack"
                          },
                          "parameters": [
                            "Object",
                            "Behavior"
                          ]
                        }
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "180"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the path origin on X axis of the object.",
              "fullName": "Path origin X",
              "functionType": "Expression",
              "group": "Movement on a curve (speed-based) configuration",
              "name": "PathOriginX",
              "sentence": "the path origin on X axis",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyPathOriginX()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the path origin on Y axis of the object.",
              "fullName": "Path origin Y",
              "functionType": "Expression",
              "group": "Movement on a curve (speed-based) configuration",
              "name": "PathOriginY",
              "sentence": "the path origin on Y axis",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyPathOriginY()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "true",
              "type": "Boolean",
              "label": "Rotate object",
              "description": "",
              "group": "Rotation",
              "extraInformation": [],
              "name": "Rotation"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "DegreeAngle",
              "label": "Rotation offset",
              "description": "",
              "group": "Rotation",
              "extraInformation": [],
              "name": "RotationOffset"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Speed"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathOriginX"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathOriginY"
            },
            {
              "value": "",
              "type": "String",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathName"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TargetedSpeed"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Acceleration"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DrawingElementIndex"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "X"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Y"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathAngle"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PathScale"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "RepetitionCount"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "ShouldLoop"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DrawingPathOriginX"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DrawingPathOriginY"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "DebugLineStrokeWidth"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "PreviousSpeed"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "CurrentLength"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "IsLookingBack"
            },
            {
              "value": "Top-Down",
              "type": "Choice",
              "label": "Viewpoint",
              "description": "",
              "group": "",
              "extraInformation": [
                "Top-Down",
                "Isometry 2:1 (26.565Â°)"
              ],
              "name": "Viewpoint"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "Camera",
      "extensionNamespace": "",
      "fullName": "Third person camera",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSI3LDEwIDEsMTMgNywxNiAxMywxMyAiLz4NCjxwb2x5bGluZSBjbGFzcz0ic3QwIiBwb2ludHM9IjEsMTMgMSwyMCA3LDIzIDEzLDIwIDEzLDEzICIvPg0KPGxpbmUgY2xhc3M9InN0MCIgeDE9IjciIHkxPSIxNiIgeDI9IjciIHkyPSIyMyIvPg0KPGxpbmUgY2xhc3M9InN0MCIgeDE9IjMxIiB5MT0iMTYiIHgyPSIyMSIgeTI9IjgiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIyMSIgeTE9IjI0IiB4Mj0iMzEiIHkyPSIxNiIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIyLjcsMjIuNkMyMCwyMS43LDE4LDE5LjEsMTgsMTZjMC0zLjEsMi01LjcsNC43LTYuNiIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTE5LjgsMTEuM2MxLjQsMS4xLDIuMiwyLjgsMi4yLDQuN2MwLDEuOS0wLjksMy42LTIuMiw0LjciLz4NCjwvc3ZnPg0K",
      "name": "ThirdPersonCamera",
      "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Line Hero Pack/Master/SVG/Virtual Reality/94e95d2c318e1f3dc7151a351024e13c574e1e44669c6696aa107d60230073f6_Virtual Reality_3d_vision_eye_vr.svg",
      "shortDescription": "Move the camera  to look at an object from a given distance.",
      "version": "1.2.1",
      "description": [
        "Move the camera  to look at an object from a given distance with a rotation and an elevation angles.",
        "",
        "It can be useful for:",
        "- Third person camera",
        "- Isometric-like point of view",
        ""
      ],
      "origin": {
        "identifier": "ThirdPersonCamera",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "3d",
        "camera"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Move the camera to look at a position from a distance.",
          "fullName": "Look at a position from a distance (deprecated)",
          "functionType": "Action",
          "name": "LookFromDistanceAtPosition",
          "private": true,
          "sentence": "Move the camera of _PARAM6_ to look at _PARAM1_; _PARAM2_ from _PARAM3_ pixels with a rotation of _PARAM4_Â° and an elevation of _PARAM5_Â°",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetCameraCenterX"
                  },
                  "parameters": [
                    "",
                    "=",
                    "GetArgumentAsNumber(\"PositionX\") + GetArgumentAsNumber(\"Distance\") * cos(ToRad(GetArgumentAsNumber(\"RotationAngle\") + 90)) * cos(ToRad(GetArgumentAsNumber(\"ElevationAngle\")))",
                    "GetArgumentAsString(\"Layer\")",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "SetCameraCenterY"
                  },
                  "parameters": [
                    "",
                    "=",
                    "GetArgumentAsNumber(\"PositionY\") + GetArgumentAsNumber(\"Distance\") * sin(ToRad(GetArgumentAsNumber(\"RotationAngle\") + 90)) * cos(ToRad(GetArgumentAsNumber(\"ElevationAngle\")))",
                    "GetArgumentAsString(\"Layer\")",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Scene3D::SetCameraZ"
                  },
                  "parameters": [
                    "",
                    "=",
                    "GetArgumentAsNumber(\"Distance\") * sin(ToRad(GetArgumentAsNumber(\"ElevationAngle\")))",
                    "GetArgumentAsString(\"Layer\")",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Scene3D::TurnCameraTowardPosition"
                  },
                  "parameters": [
                    "",
                    "GetArgumentAsNumber(\"PositionX\")",
                    "GetArgumentAsNumber(\"PositionY\")",
                    "0",
                    "GetArgumentAsString(\"Layer\")",
                    "",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Position on X axis",
              "name": "PositionX",
              "type": "expression"
            },
            {
              "description": "Position on Y axis",
              "name": "PositionY",
              "type": "expression"
            },
            {
              "description": "Distance",
              "name": "Distance",
              "type": "expression"
            },
            {
              "description": "Rotation angle (around Z axis)",
              "name": "RotationAngle",
              "type": "expression"
            },
            {
              "description": "Elevation angle (around Y axis)",
              "name": "ElevationAngle",
              "type": "expression"
            },
            {
              "description": "Layer",
              "name": "Layer",
              "type": "layer"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Move the camera to look at an object from a distance.",
          "fullName": "Look at an object from a distance (deprecated)",
          "functionType": "Action",
          "name": "LookFromDistanceAtObject",
          "private": true,
          "sentence": "Move the camera of _PARAM5_ to look at _PARAM1_ from _PARAM2_ pixels with a rotation of _PARAM3_Â° and an elevation of _PARAM4_Â°",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ThirdPersonCamera::LookFromDistanceAtPosition"
                  },
                  "parameters": [
                    "",
                    "Object.CenterX()",
                    "Object.CenterY()",
                    "GetArgumentAsNumber(\"Distance\")",
                    "GetArgumentAsNumber(\"RotationAngle\")",
                    "GetArgumentAsNumber(\"ElevationAngle\")",
                    "GetArgumentAsString(\"Layer\")",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Distance",
              "name": "Distance",
              "type": "expression"
            },
            {
              "description": "Rotation angle (around Z axis)",
              "name": "RotationAngle",
              "type": "expression"
            },
            {
              "description": "Elevation angle (around Y axis)",
              "name": "ElevationAngle",
              "type": "expression"
            },
            {
              "description": "Layer",
              "name": "Layer",
              "type": "layer"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Move the camera to look at a position from a distance.",
          "fullName": "Look at a position from a distance",
          "functionType": "Action",
          "name": "LookFromDistanceAtPosition3D",
          "sentence": "Move the camera of _PARAM7_ to look at _PARAM1_; _PARAM2_; _PARAM3_ from _PARAM4_ pixels with a rotation of _PARAM5_Â° and an elevation of _PARAM6_Â°",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetCameraCenterX"
                  },
                  "parameters": [
                    "",
                    "=",
                    "PositionX + Distance * cos(ToRad(RotationAngle + 90)) * cos(ToRad(ElevationAngle))",
                    "Layer",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "SetCameraCenterY"
                  },
                  "parameters": [
                    "",
                    "=",
                    "PositionY + Distance * sin(ToRad(RotationAngle + 90)) * cos(ToRad(ElevationAngle))",
                    "Layer",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Scene3D::SetCameraZ"
                  },
                  "parameters": [
                    "",
                    "=",
                    "PositionZ + Distance * sin(ToRad(ElevationAngle))",
                    "Layer",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Scene3D::SetCameraRotationX"
                  },
                  "parameters": [
                    "",
                    "=",
                    "90 - ElevationAngle",
                    "Layer",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Scene3D::SetCameraRotationY"
                  },
                  "parameters": [
                    "",
                    "=",
                    "0",
                    "Layer",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "SetCameraAngle"
                  },
                  "parameters": [
                    "",
                    "=",
                    "RotationAngle",
                    "Layer",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Position on X axis",
              "name": "PositionX",
              "type": "expression"
            },
            {
              "description": "Position on Y axis",
              "name": "PositionY",
              "type": "expression"
            },
            {
              "description": "Position on Z axis",
              "name": "PositionZ",
              "type": "expression"
            },
            {
              "description": "Distance",
              "name": "Distance",
              "type": "expression"
            },
            {
              "description": "Rotation angle (around Z axis)",
              "name": "RotationAngle",
              "type": "expression"
            },
            {
              "description": "Elevation angle (around Y axis)",
              "name": "ElevationAngle",
              "type": "expression"
            },
            {
              "description": "Layer",
              "name": "Layer",
              "type": "layer"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Move the camera to look at an object from a distance.",
          "fullName": "Look at an object from a distance",
          "functionType": "Action",
          "group": "Layers and cameras",
          "name": "LookFromDistanceAtObject3D",
          "sentence": "Move the camera of _PARAM6_ to look at _PARAM1_ from _PARAM3_ pixels with a rotation of _PARAM4_Â° and an elevation of _PARAM5_Â°",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ThirdPersonCamera::LookFromDistanceAtPosition3D"
                  },
                  "parameters": [
                    "",
                    "Object.CenterX()",
                    "Object.CenterY()",
                    "Object.Object3D::CenterZ()",
                    "Distance",
                    "RotationAngle",
                    "ElevationAngle",
                    "Layer",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "3D capability",
              "name": "Object3D",
              "supplementaryInformation": "Scene3D::Base3DBehavior",
              "type": "behavior"
            },
            {
              "description": "Distance",
              "name": "Distance",
              "type": "expression"
            },
            {
              "description": "Rotation angle (around Z axis)",
              "name": "RotationAngle",
              "type": "expression"
            },
            {
              "description": "Elevation angle (around Y axis)",
              "name": "ElevationAngle",
              "type": "expression"
            },
            {
              "description": "Layer",
              "name": "Layer",
              "type": "layer"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "Smoothly follow an object at a distance.",
          "fullName": "Third person camera",
          "name": "ThirdPersonCamera",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Update private properties through setters to check their values and initialize state."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetRotationHalfwayDuration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Behavior::PropertyRotationHalfwayDuration()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetTranslationZHalfwayDuration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Behavior::PropertyTranslationZHalfwayDuration()",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "ThirdPersonCamera::ThirdPersonCamera::PropertyIsCalledManually"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::DoMoveCameraCloser"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move the camera closer to the object. This action must be called after the object has moved for the frame.",
              "fullName": "Move the camera closer",
              "functionType": "Action",
              "name": "MoveCameraCloser",
              "sentence": "Move the camera closer to _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "The camera following is called with an action, the call from doStepPreEvents must be disabled to avoid to do it twice."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyIsCalledManually"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::DoMoveCameraCloser"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Move the camera closer to the object.",
              "fullName": "Do move the camera closer",
              "functionType": "Action",
              "name": "DoMoveCameraCloser",
              "private": true,
              "sentence": "Do move the camera closer _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "At each frame, the camera must catchup the target by a given ratio (speed)\ncameraX(t) - targetX = (cameraX(t - 1) - targetX) * (1 - speed)\n\nThe frame rate must not impact on the catch-up speed, we don't want a speed in ratio per frame but a speed ratio per second, like this:\ncameraX(t) - targetX = (cameraX(t - 1s) - targetX) * (1 - speed)\n\nOk, but we still need to process each frame, we can use a exponent for this:\ncameraX(t) - targetX = (cameraX(t - timeDelta) - targetX) * (1 - speed)^timeDelta\ncameraX(t) = targetX + (cameraX(t - timeDelta) - targetX) * exp(timeDelta * ln((1 - speed)))\n\npow is probably more efficient than precalculated log if the speed is changed continuously but this might be rare enough."
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Z translation",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "ThirdPersonCamera::ThirdPersonCamera::PropertyCameraZ"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "<",
                                "Object.Behavior::FreeAreaZMin()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyCameraZ"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "Object.Behavior::FreeAreaZMin() + (CameraZ - Object.Behavior::FreeAreaZMin()) * exp(TimeDelta() * TranslationZLogSpeed)"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "ThirdPersonCamera::ThirdPersonCamera::PropertyCameraZ"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ">",
                                "Object.Behavior::FreeAreaZMax()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyCameraZ"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "Object.Behavior::FreeAreaZMax() + (CameraZ - Object.Behavior::FreeAreaZMax()) * exp(TimeDelta() * TranslationZLogSpeed)"
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Z rotation",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "ThirdPersonCamera::LookFromDistanceAtPosition3D"
                          },
                          "parameters": [
                            "",
                            "Object.X() + OffsetX",
                            "Object.Y() + OffsetY",
                            "CameraZ + OffsetZ",
                            "Distance",
                            "Object.Angle() + 90 + (AngleDifference(CameraAngle(Object.Layer(), 0), (Object.Angle() + 90))) * exp(TimeDelta() * Object.Behavior::PropertyRotationLogSpeed()) + RotationAngleOffset",
                            "Object.Object3D::RotationY() + ElevationAngleOffset",
                            "",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the halfway time for rotation of the object.",
              "fullName": "Halfway time for rotation",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "RotationHalfwayDuration",
              "sentence": "the halfway time for rotation",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "RotationHalfwayDuration"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "RotationHalfwayDuration",
              "name": "SetRotationHalfwayDuration",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "ln((1 - speed)) = ln(1 / 2) / halfwatTime"
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyRotationHalfwayDuration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    },
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyRotationLogSpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "log(0.5) / Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the halfway time on Z axis of the object.",
              "fullName": "Halfway time on Z axis",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "TranslationZHalfwayDuration",
              "sentence": "the halfway time on Z axis",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "TranslationZHalfwayDuration"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "TranslationZHalfwayDuration",
              "name": "SetTranslationZHalfwayDuration",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "ln((1 - speed)) = ln(1 / 2) / halfwatTime"
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyTranslationZHalfwayDuration"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    },
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyTranslationZLogSpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "log(0.5) / Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return follow free area bottom border Z.",
              "fullName": "Free area Z min",
              "functionType": "Expression",
              "group": "Private",
              "name": "FreeAreaZMin",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Object3D::CenterZ() + OffsetZ - FollowFreeAreaZMin"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return follow free area top border Z.",
              "fullName": "Free area Z max",
              "functionType": "Expression",
              "group": "Private",
              "name": "FreeAreaZMax",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Object3D::CenterZ() + OffsetZ + FollowFreeAreaZMax"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the follow free area top border on Z axis of the object.",
              "fullName": "Follow free area top border on Z axis",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "FollowFreeAreaZMax",
              "sentence": "the follow free area top border on Z axis",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "FollowFreeAreaZMax"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "FollowFreeAreaZMax",
              "name": "SetFollowFreeAreaZMax",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyFollowFreeAreaZMax"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the follow free area bottom border on Z axis of the object.",
              "fullName": "Follow free area bottom border on Z axis",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "FollowFreeAreaZMin",
              "sentence": "the follow free area bottom border on Z axis",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "FollowFreeAreaZMin"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "FollowFreeAreaZMin",
              "name": "SetFollowFreeAreaZMin",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyFollowFreeAreaZMin"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the camera distance of the object.",
              "fullName": "Camera distance",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "Distance",
              "sentence": "the camera distance",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Distance"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Distance",
              "name": "SetDistance",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyDistance"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the x offset of the object.",
              "fullName": "X offset",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "OffsetX",
              "sentence": "the x offset",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "OffsetX"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "OffsetX",
              "name": "SetOffsetX",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyOffsetX"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the y offset of the object.",
              "fullName": "Y offset",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "OffsetY",
              "sentence": "the y offset",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "OffsetY"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "OffsetY",
              "name": "SetOffsetY",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyOffsetY"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the z offset of the object.",
              "fullName": "Z offset",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "OffsetZ",
              "sentence": "the z offset",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "OffsetZ"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "OffsetZ",
              "name": "SetOffsetZ",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyOffsetZ"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the rotation angle offset of the object.",
              "fullName": "Rotation angle offset",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "RotationAngleOffset",
              "sentence": "the rotation angle offset",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "RotationAngleOffset"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "RotationAngleOffset",
              "name": "SetRotationAngleOffset",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyRotationAngleOffset"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the elevation angle offset of the object.",
              "fullName": "Elevation angle offset",
              "functionType": "ExpressionAndCondition",
              "group": "Third person camera configuration",
              "name": "ElevationAngleOffset",
              "sentence": "the elevation angle offset",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "ElevationAngleOffset"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ElevationAngleOffset",
              "name": "SetElevationAngleOffset",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ThirdPersonCamera::ThirdPersonCamera::SetPropertyElevationAngleOffset"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ThirdPersonCamera::ThirdPersonCamera",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "",
              "type": "Behavior",
              "label": "3D capability",
              "description": "",
              "group": "",
              "extraInformation": [
                "Scene3D::Base3DBehavior"
              ],
              "name": "Object3D"
            },
            {
              "value": "0.125",
              "type": "Number",
              "unit": "Second",
              "label": "Halfway  time for rotation",
              "description": "",
              "group": "Catch-up speed",
              "extraInformation": [],
              "name": "RotationHalfwayDuration"
            },
            {
              "value": "0.125",
              "type": "Number",
              "unit": "Second",
              "label": "Halfway time on Z axis",
              "description": "",
              "group": "Catch-up speed",
              "extraInformation": [],
              "name": "TranslationZHalfwayDuration"
            },
            {
              "value": "500",
              "type": "Number",
              "unit": "Pixel",
              "label": "Camera distance",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "name": "Distance"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "X offset",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "name": "OffsetX"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Y offset",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "name": "OffsetY"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Z offset",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "name": "OffsetZ"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "DegreeAngle",
              "label": "Rotation angle offset",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "name": "RotationAngleOffset"
            },
            {
              "value": "20",
              "type": "Number",
              "unit": "DegreeAngle",
              "label": "Elevation angle offset",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "name": "ElevationAngleOffset"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Follow free area top border on Z axis",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "advanced": true,
              "name": "FollowFreeAreaZMax"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Follow free area bottom border on Z axis",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "advanced": true,
              "name": "FollowFreeAreaZMin"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "RotationLogSpeed"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TranslationZLogSpeed"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "IsCalledManually"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "CameraZ"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "Visual effect",
      "extensionNamespace": "",
      "fullName": "3D particle emitter",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWZpcmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTcuNjYgMTEuMkMxNy40MyAxMC45IDE3LjE1IDEwLjY0IDE2Ljg5IDEwLjM4QzE2LjIyIDkuNzggMTUuNDYgOS4zNSAxNC44MiA4LjcyQzEzLjMzIDcuMjYgMTMgNC44NSAxMy45NSAzQzEzIDMuMjMgMTIuMTcgMy43NSAxMS40NiA0LjMyQzguODcgNi40IDcuODUgMTAuMDcgOS4wNyAxMy4yMkM5LjExIDEzLjMyIDkuMTUgMTMuNDIgOS4xNSAxMy41NUM5LjE1IDEzLjc3IDkgMTMuOTcgOC44IDE0LjA1QzguNTcgMTQuMTUgOC4zMyAxNC4wOSA4LjE0IDEzLjkzQzguMDggMTMuODggOC4wNCAxMy44MyA4IDEzLjc2QzYuODcgMTIuMzMgNi42OSAxMC4yOCA3LjQ1IDguNjRDNS43OCAxMCA0Ljg3IDEyLjMgNSAxNC40N0M1LjA2IDE0Ljk3IDUuMTIgMTUuNDcgNS4yOSAxNS45N0M1LjQzIDE2LjU3IDUuNyAxNy4xNyA2IDE3LjdDNy4wOCAxOS40MyA4Ljk1IDIwLjY3IDEwLjk2IDIwLjkyQzEzLjEgMjEuMTkgMTUuMzkgMjAuOCAxNy4wMyAxOS4zMkMxOC44NiAxNy42NiAxOS41IDE1IDE4LjU2IDEyLjcyTDE4LjQzIDEyLjQ2QzE4LjIyIDEyIDE3LjY2IDExLjIgMTcuNjYgMTEuMk0xNC41IDE3LjVDMTQuMjIgMTcuNzQgMTMuNzYgMTggMTMuNCAxOC4xQzEyLjI4IDE4LjUgMTEuMTYgMTcuOTQgMTAuNSAxNy4yOEMxMS42OSAxNyAxMi40IDE2LjEyIDEyLjYxIDE1LjIzQzEyLjc4IDE0LjQzIDEyLjQ2IDEzLjc3IDEyLjMzIDEzQzEyLjIxIDEyLjI2IDEyLjIzIDExLjYzIDEyLjUgMTAuOTRDMTIuNjkgMTEuMzIgMTIuODkgMTEuNyAxMy4xMyAxMkMxMy45IDEzIDE1LjExIDEzLjQ0IDE1LjM3IDE0LjhDMTUuNDEgMTQuOTQgMTUuNDMgMTUuMDggMTUuNDMgMTUuMjNDMTUuNDYgMTYuMDUgMTUuMSAxNi45NSAxNC41IDE3LjVIMTQuNVoiIC8+PC9zdmc+",
      "name": "ParticleEmitter3D",
      "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/f2e5a34bf465f781866677762d385d6c8e9e8d203383f2df9a3b7e0fad6a2cb5_fire.svg",
      "shortDescription": "Display a large number of particles to create visual effects.",
      "version": "2.0.0",
      "description": [
        "Particle emitters can be used to display:",
        "- Fire",
        "- Smoke",
        "- Splashes",
        "- Lights",
        "",
        "Breaking change",
        "- 2.0.0",
        "  - Object properties for position and rotation have been removed. They must be set with the instance editor or the action.",
        "- 1.0.0",
        "  - Particles were 3 times too small"
      ],
      "origin": {
        "identifier": "ParticleEmitter3D",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "3d",
        "particle",
        "explosion",
        "fire",
        "smoke",
        "splash",
        "light"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "GlobalVariableAsBoolean"
                  },
                  "parameters": [
                    "_ParticleEmmiter3DExtension_ClassesDefined",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetGlobalVariableAsBoolean"
                  },
                  "parameters": [
                    "_ParticleEmmiter3DExtension_ClassesDefined",
                    "True"
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "gdjs.__particleEmmiter3DExtension = gdjs.__particleEmmiter3DExtension || {};",
                    "",
                    "class ParticleEmitter3DRenderer extends gdjs.CustomRuntimeObject3DRenderer {",
                    "    constructor(",
                    "      object,",
                    "      instanceContainer,",
                    "      parent",
                    "    ) {",
                    "        super(object, instanceContainer, parent);",
                    "    }",
                    "",
                    "    _updateThreeGroup() {",
                    "      const threeObject3D = this.get3DRendererObject();",
                    "",
                    "      threeObject3D.rotation.set(",
                    "        gdjs.toRad(this._object.getRotationX()),",
                    "        gdjs.toRad(this._object.getRotationY()),",
                    "        -gdjs.toRad(this._object.angle)",
                    "      );",
                    "",
                    "      threeObject3D.position.set(",
                    "        this._object.getX(),",
                    "        -this._object.getY(),",
                    "        this._object.getZ()",
                    "      );",
                    "",
                    "      threeObject3D.scale.set(",
                    "        this._object.isFlippedX() ? -1 : 1,",
                    "        this._object.isFlippedY() ? -1 : 1,",
                    "        this._object.isFlippedZ() ? -1 : 1",
                    "      );",
                    "",
                    "      threeObject3D.visible = !this._object.hidden;",
                    "",
                    "      this._isContainerDirty = true;",
                    "    }",
                    "}",
                    "",
                    "gdjs.__particleEmmiter3DExtension.ParticleEmitter3DRenderer = ParticleEmitter3DRenderer;",
                    "",
                    "/**",
                    " * @param {string} colorString",
                    " * @param {THREE.Vector4} threeColor",
                    " */",
                    "const setThreeColor = (colorString, threeColor = new THREE.Vector4()) => {",
                    "    const integerColor = gdjs.rgbOrHexToRGBColor(colorString);",
                    "    threeColor.x = integerColor[0] / 255;",
                    "    threeColor.y = integerColor[1] / 255;",
                    "    threeColor.z = integerColor[2] / 255;",
                    "};",
                    "",
                    "/**",
                    " * @param {string} integerOpacity",
                    " * @param {THREE.Vector4} threeColor",
                    " */",
                    "const setThreeOpacity = (integerOpacity, threeColor = new THREE.Vector4()) => {",
                    "    threeColor.w = integerOpacity / 255;",
                    "};",
                    "",
                    "class ParticleEmitterAdapter {",
                    "    /**",
                    "     * @param particleSystem {ParticleSystem}",
                    "     * @param colorOverLife {ColorOverLife}",
                    "     * @param sizeOverLife {SizeOverLife}",
                    "     * @param applyForce {ApplyForce}",
                    "     */",
                    "    constructor(particleSystem, colorOverLife, sizeOverLife, applyForce) {",
                    "        this.particleSystem = particleSystem;",
                    "        this.colorOverLife = colorOverLife;",
                    "        this.sizeOverLife = sizeOverLife;",
                    "        this.applyForce = applyForce;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param startColor {string}",
                    "     */",
                    "    setStartColor(startColor) {",
                    "        setThreeColor(startColor, this.colorOverLife.color.color.keys[0][0]);",
                    "    }",
                    "",
                    "    /**",
                    "     * @param endColor {string}",
                    "     */",
                    "    setEndColor(endColor) {",
                    "        setThreeColor(endColor, this.colorOverLife.color.color.keys[1][0]);",
                    "    }",
                    "",
                    "    /**",
                    "     * @param startOpacity {number}",
                    "     */",
                    "    setStartOpacity(startOpacity) {",
                    "        this.colorOverLife.color.alpha.keys[0][0] = startOpacity / 255;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param endOpacity {number}",
                    "     */",
                    "    setEndOpacity(endOpacity) {",
                    "        this.colorOverLife.color.alpha.keys[1][0] = endOpacity / 255;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param flow {number}",
                    "     */",
                    "    setFlow(flow) {",
                    "        this.particleSystem.emissionOverTime.value = flow;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param startMinSize {number}",
                    "     */",
                    "    setStartMinSize(startMinSize) {",
                    "        this.particleSystem.startSize.a = startMinSize;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param startMaxSize {number}",
                    "     */",
                    "    setStartMaxSize(startMaxSize) {",
                    "        this.particleSystem.startSize.b = startMaxSize;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param endScale {number}",
                    "     */",
                    "    setEndScale(endScale) {",
                    "        /** @type Bezier */",
                    "        const bezier = this.sizeOverLife.size.functions[0][0];",
                    "        bezier.p[0] = 1;",
                    "        bezier.p[1] = gdjs.evtTools.common.lerp(1, endScale, 1 / 3);",
                    "        bezier.p[2] = gdjs.evtTools.common.lerp(1, endScale, 2 / 3);",
                    "        bezier.p[3] = endScale;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param startSpeedMin {number}",
                    "     */",
                    "    setStartSpeedMin(startSpeedMin) {",
                    "        this.particleSystem.startSpeed.a = startSpeedMin;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param startSpeedMax {number}",
                    "     */",
                    "    setStartSpeedMax(startSpeedMax) {",
                    "        this.particleSystem.startSpeed.b = startSpeedMax;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param lifespanMin {number}",
                    "     */",
                    "    setLifespanMin(lifespanMin) {",
                    "        this.particleSystem.startLife.a = lifespanMin;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param lifespanMax {number}",
                    "     */",
                    "    setLifespanMax(lifespanMax) {",
                    "        this.particleSystem.startLife.b = lifespanMax;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param duration {number}",
                    "     */",
                    "    setDuration(duration) {",
                    "        this.particleSystem.duration = duration || Number.POSITIVE_INFINITY;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param areParticlesRelative {boolean}",
                    "     */",
                    "    setParticlesRelative(areParticlesRelative) {",
                    "        this.particleSystem.worldSpace = !areParticlesRelative;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param sprayConeAngle {number}",
                    "     */",
                    "    setSprayConeAngle(sprayConeAngle) {",
                    "        if (0 < sprayConeAngle && sprayConeAngle <= 180) {",
                    "            if (!this.particleSystem.emitterShape.angle) {",
                    "                this.particleSystem.emitterShape = new ConeEmitter({ radius: 0.1, angle: Math.PI / 8 });",
                    "            }",
                    "            this.particleSystem.emitterShape.angle = sprayConeAngle * Math.PI / 180;",
                    "        }",
                    "        else {",
                    "            if (this.particleSystem.emitterShape.angle) {",
                    "                this.particleSystem.emitterShape = new PointEmitter();",
                    "            }",
                    "        }",
                    "    }",
                    "",
                    "    /**",
                    "     * @param blending {string}",
                    "     */",
                    "    setBlending(blendingString) {",
                    "        const blending =",
                    "            blendingString === \"Additive\" ? THREE.AdditiveBlending :",
                    "                blendingString === \"Normal\" ? THREE.NormalBlending :",
                    "                    blendingString === \"Subtractive\" ? THREE.SubtractiveBlending :",
                    "                        blendingString === \"Multiply\" ? THREE.MultiplyBlending :",
                    "                            blendingString === \"None\" ? THREE.NoBlending :",
                    "                                THREE.AdditiveBlending;",
                    "        // TODO This doesn't work.",
                    "        this.particleSystem.blending = blending;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param gravity {number}",
                    "     */",
                    "    setGravity(gravity) {",
                    "        this.applyForce.magnitude.value = gravity;",
                    "    }",
                    "",
                    "    /**",
                    "     * @param gravityTop {string}",
                    "     */",
                    "    setGravityTop(gravityTop) {",
                    "        // TODO Make gravity absolute even when \"relative\" is enabled. ",
                    "        switch (gravityTop) {",
                    "            case \"Z+\":",
                    "                this.applyForce.direction.set(0, 0, -1);",
                    "                break;",
                    "",
                    "            case \"Y-\":",
                    "                this.applyForce.direction.set(0, 1, 0);",
                    "                break;",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "gdjs.__particleEmmiter3DExtension.ParticleEmitterAdapter = ParticleEmitterAdapter;",
                    "",
                    "",
                    "/**",
                    " * three.quarks v0.11.2 build Mon Jan 22 2024",
                    " * https://github.com/Alchemist0823/three.quarks#readme",
                    " * Copyright 2024 Alchemist0823 <the.forrest.sun@gmail.com>, MIT",
                    " */",
                    "",
                    "class ParticleEmitter extends THREE.Object3D {",
                    "    constructor(system) {",
                    "        super();",
                    "        this.type = 'ParticleEmitter';",
                    "        this.system = system;",
                    "    }",
                    "    clone() {",
                    "        const system = this.system.clone();",
                    "        system.emitter.copy(this, true);",
                    "        return system.emitter;",
                    "    }",
                    "    dispose() { }",
                    "    extractFromCache(cache) {",
                    "        const values = [];",
                    "        for (const key in cache) {",
                    "            const data = cache[key];",
                    "            delete data.metadata;",
                    "            values.push(data);",
                    "        }",
                    "        return values;",
                    "    }",
                    "    toJSON(meta, options = {}) {",
                    "        const isRootObject = meta === undefined || typeof meta === 'string';",
                    "        const output = {};",
                    "        if (isRootObject) {",
                    "            meta = {",
                    "                geometries: {},",
                    "                materials: {},",
                    "                textures: {},",
                    "                images: {},",
                    "                shapes: {},",
                    "                skeletons: {},",
                    "                animations: {},",
                    "                nodes: {},",
                    "            };",
                    "            output.metadata = {",
                    "                version: 4.5,",
                    "                type: 'Object',",
                    "                generator: 'Object3D.toJSON',",
                    "            };",
                    "        }",
                    "        const object = {};",
                    "        object.uuid = this.uuid;",
                    "        object.type = this.type;",
                    "        if (this.name !== '')",
                    "            object.name = this.name;",
                    "        if (this.castShadow === true)",
                    "            object.castShadow = true;",
                    "        if (this.receiveShadow === true)",
                    "            object.receiveShadow = true;",
                    "        if (this.visible === false)",
                    "            object.visible = false;",
                    "        if (this.frustumCulled === false)",
                    "            object.frustumCulled = false;",
                    "        if (this.renderOrder !== 0)",
                    "            object.renderOrder = this.renderOrder;",
                    "        if (JSON.stringify(this.userData) !== '{}')",
                    "            object.userData = this.userData;",
                    "        object.layers = this.layers.mask;",
                    "        object.matrix = this.matrix.toArray();",
                    "        if (this.matrixAutoUpdate === false)",
                    "            object.matrixAutoUpdate = false;",
                    "        if (this.system !== null)",
                    "            object.ps = this.system.toJSON(meta, options);",
                    "        if (this.children.length > 0) {",
                    "            object.children = [];",
                    "            for (let i = 0; i < this.children.length; i++) {",
                    "                if (this.children[i].type !== 'ParticleSystemPreview') {",
                    "                    object.children.push(this.children[i].toJSON(meta).object);",
                    "                }",
                    "            }",
                    "        }",
                    "        if (isRootObject) {",
                    "            const geometries = this.extractFromCache(meta.geometries);",
                    "            const materials = this.extractFromCache(meta.materials);",
                    "            const textures = this.extractFromCache(meta.textures);",
                    "            const images = this.extractFromCache(meta.images);",
                    "            if (geometries.length > 0)",
                    "                output.geometries = geometries;",
                    "            if (materials.length > 0)",
                    "                output.materials = materials;",
                    "            if (textures.length > 0)",
                    "                output.textures = textures;",
                    "            if (images.length > 0)",
                    "                output.images = images;",
                    "        }",
                    "        output.object = object;",
                    "        return output;",
                    "    }",
                    "}",
                    "",
                    "class LinkedListNode {",
                    "    constructor(data) {",
                    "        this.data = data;",
                    "        this.next = null;",
                    "        this.prev = null;",
                    "    }",
                    "    hasPrev() {",
                    "        return this.prev !== null;",
                    "    }",
                    "    hasNext() {",
                    "        return this.next !== null;",
                    "    }",
                    "}",
                    "class LinkedList {",
                    "    constructor() {",
                    "        this.length = 0;",
                    "        this.head = this.tail = null;",
                    "    }",
                    "    isEmpty() {",
                    "        return this.head === null;",
                    "    }",
                    "    clear() {",
                    "        this.length = 0;",
                    "        this.head = this.tail = null;",
                    "    }",
                    "    front() {",
                    "        if (this.head === null)",
                    "            return null;",
                    "        return this.head.data;",
                    "    }",
                    "    back() {",
                    "        if (this.tail === null)",
                    "            return null;",
                    "        return this.tail.data;",
                    "    }",
                    "    dequeue() {",
                    "        if (this.head) {",
                    "            const value = this.head.data;",
                    "            this.head = this.head.next;",
                    "            if (!this.head) {",
                    "                this.tail = null;",
                    "            }",
                    "            else {",
                    "                this.head.prev = null;",
                    "            }",
                    "            this.length--;",
                    "            return value;",
                    "        }",
                    "        return undefined;",
                    "    }",
                    "    pop() {",
                    "        if (this.tail) {",
                    "            const value = this.tail.data;",
                    "            this.tail = this.tail.prev;",
                    "            if (!this.tail) {",
                    "                this.head = null;",
                    "            }",
                    "            else {",
                    "                this.tail.next = null;",
                    "            }",
                    "            this.length--;",
                    "            return value;",
                    "        }",
                    "        return undefined;",
                    "    }",
                    "    queue(data) {",
                    "        const node = new LinkedListNode(data);",
                    "        if (!this.tail) {",
                    "            this.tail = node;",
                    "        }",
                    "        if (this.head) {",
                    "            this.head.prev = node;",
                    "            node.next = this.head;",
                    "        }",
                    "        this.head = node;",
                    "        this.length++;",
                    "    }",
                    "    push(data) {",
                    "        const node = new LinkedListNode(data);",
                    "        if (!this.head) {",
                    "            this.head = node;",
                    "        }",
                    "        if (this.tail) {",
                    "            this.tail.next = node;",
                    "            node.prev = this.tail;",
                    "        }",
                    "        this.tail = node;",
                    "        this.length++;",
                    "    }",
                    "    insertBefore(node, data) {",
                    "        const newNode = new LinkedListNode(data);",
                    "        newNode.next = node;",
                    "        newNode.prev = node.prev;",
                    "        if (newNode.prev !== null) {",
                    "            newNode.prev.next = newNode;",
                    "        }",
                    "        newNode.next.prev = newNode;",
                    "        if (node == this.head) {",
                    "            this.head = newNode;",
                    "        }",
                    "        this.length++;",
                    "    }",
                    "    remove(data) {",
                    "        if (this.head === null || this.tail === null) {",
                    "            return;",
                    "        }",
                    "        let tempNode = this.head;",
                    "        if (data === this.head.data) {",
                    "            this.head = this.head.next;",
                    "        }",
                    "        if (data === this.tail.data) {",
                    "            this.tail = this.tail.prev;",
                    "        }",
                    "        while (tempNode.next !== null && tempNode.data !== data) {",
                    "            tempNode = tempNode.next;",
                    "        }",
                    "        if (tempNode.data === data) {",
                    "            if (tempNode.prev !== null)",
                    "                tempNode.prev.next = tempNode.next;",
                    "            if (tempNode.next !== null)",
                    "                tempNode.next.prev = tempNode.prev;",
                    "            this.length--;",
                    "        }",
                    "    }",
                    "    *values() {",
                    "        let current = this.head;",
                    "        while (current !== null) {",
                    "            yield current.data;",
                    "            current = current.next;",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "class NodeParticle {",
                    "    constructor() {",
                    "        this.position = new THREE.Vector3();",
                    "        this.velocity = new THREE.Vector3();",
                    "        this.age = 0;",
                    "        this.life = 1;",
                    "        this.size = 1;",
                    "        this.rotation = 0;",
                    "        this.color = new THREE.Vector4(1, 1, 1, 1);",
                    "        this.uvTile = 0;",
                    "    }",
                    "    get died() {",
                    "        return this.age >= this.life;",
                    "    }",
                    "    reset() {",
                    "        this.position.set(0, 0, 0);",
                    "        this.velocity.set(0, 0, 0);",
                    "        this.age = 0;",
                    "        this.life = 1;",
                    "        this.size = 1;",
                    "        this.rotation = 0;",
                    "        this.color.set(1, 1, 1, 1);",
                    "        this.uvTile = 0;",
                    "    }",
                    "}",
                    "class SpriteParticle {",
                    "    constructor() {",
                    "        this.startSpeed = 0;",
                    "        this.startColor = new THREE.Vector4();",
                    "        this.startSize = 1;",
                    "        this.position = new THREE.Vector3();",
                    "        this.velocity = new THREE.Vector3();",
                    "        this.age = 0;",
                    "        this.life = 1;",
                    "        this.size = 1;",
                    "        this.speedModifier = 1;",
                    "        this.rotation = 0;",
                    "        this.color = new THREE.Vector4();",
                    "        this.uvTile = 0;",
                    "    }",
                    "    get died() {",
                    "        return this.age >= this.life;",
                    "    }",
                    "}",
                    "class RecordState {",
                    "    constructor(position, size, color) {",
                    "        this.position = position;",
                    "        this.size = size;",
                    "        this.color = color;",
                    "    }",
                    "}",
                    "class TrailParticle {",
                    "    constructor() {",
                    "        this.startSpeed = 0;",
                    "        this.startColor = new THREE.Vector4();",
                    "        this.startSize = 1;",
                    "        this.position = new THREE.Vector3();",
                    "        this.velocity = new THREE.Vector3();",
                    "        this.age = 0;",
                    "        this.life = 1;",
                    "        this.size = 1;",
                    "        this.length = 100;",
                    "        this.speedModifier = 1;",
                    "        this.color = new THREE.Vector4();",
                    "        this.previous = new LinkedList();",
                    "        this.uvTile = 0;",
                    "    }",
                    "    update() {",
                    "        if (this.age <= this.life) {",
                    "            this.previous.push(new RecordState(this.position.clone(), this.size, this.color.clone()));",
                    "        }",
                    "        else {",
                    "            if (this.previous.length > 0) {",
                    "                this.previous.dequeue();",
                    "            }",
                    "        }",
                    "        while (this.previous.length > this.length) {",
                    "            this.previous.dequeue();",
                    "        }",
                    "    }",
                    "    get died() {",
                    "        return this.age >= this.life;",
                    "    }",
                    "    reset() {",
                    "        this.previous.clear();",
                    "    }",
                    "}",
                    "",
                    "class Bezier {",
                    "    constructor(p1, p2, p3, p4) {",
                    "        this.p = [p1, p2, p3, p4];",
                    "    }",
                    "    genValue(t) {",
                    "        const t2 = t * t;",
                    "        const t3 = t * t * t;",
                    "        const mt = 1 - t;",
                    "        const mt2 = mt * mt;",
                    "        const mt3 = mt2 * mt;",
                    "        return this.p[0] * mt3 + this.p[1] * mt2 * t * 3 + this.p[2] * mt * t2 * 3 + this.p[3] * t3;",
                    "    }",
                    "    derivativeCoefficients(points) {",
                    "        const dpoints = [];",
                    "        for (let p = points, c = p.length - 1; c > 0; c--) {",
                    "            const list = [];",
                    "            for (let j = 0; j < c; j++) {",
                    "                const dpt = c * (p[j + 1] - p[j]);",
                    "                list.push(dpt);",
                    "            }",
                    "            dpoints.push(list);",
                    "            p = list;",
                    "        }",
                    "        return dpoints;",
                    "    }",
                    "    getSlope(t) {",
                    "        const p = this.derivativeCoefficients(this.p)[0];",
                    "        const mt = 1 - t;",
                    "        const a = mt * mt;",
                    "        const b = mt * t * 2;",
                    "        const c = t * t;",
                    "        return a * p[0] + b * p[1] + c * p[2];",
                    "    }",
                    "    controlCurve(d0, d1) {",
                    "        this.p[1] = d0 / 3 + this.p[0];",
                    "        this.p[2] = this.p[3] - d1 / 3;",
                    "    }",
                    "    hull(t) {",
                    "        let p = this.p;",
                    "        let _p = [], pt, idx = 0, i = 0, l = 0;",
                    "        const q = [];",
                    "        q[idx++] = p[0];",
                    "        q[idx++] = p[1];",
                    "        q[idx++] = p[2];",
                    "        q[idx++] = p[3];",
                    "        while (p.length > 1) {",
                    "            _p = [];",
                    "            for (i = 0, l = p.length - 1; i < l; i++) {",
                    "                pt = t * p[i] + (1 - t) * p[i + 1];",
                    "                q[idx++] = pt;",
                    "                _p.push(pt);",
                    "            }",
                    "            p = _p;",
                    "        }",
                    "        return q;",
                    "    }",
                    "    split(t) {",
                    "        const q = this.hull(t);",
                    "        const result = {",
                    "            left: new Bezier(q[0], q[4], q[7], q[9]),",
                    "            right: new Bezier(q[9], q[8], q[6], q[3]),",
                    "            span: q",
                    "        };",
                    "        return result;",
                    "    }",
                    "    clone() {",
                    "        return new Bezier(this.p[0], this.p[1], this.p[2], this.p[3]);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            p0: this.p[0],",
                    "            p1: this.p[1],",
                    "            p2: this.p[2],",
                    "            p3: this.p[3],",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new Bezier(json.p0, json.p1, json.p2, json.p3);",
                    "    }",
                    "}",
                    "",
                    "const ColorToJSON = (color) => {",
                    "    return { r: color.x, g: color.y, b: color.z, a: color.w };",
                    "};",
                    "const JSONToColor = (json) => {",
                    "    return new THREE.Vector4(json.r, json.g, json.b, json.a);",
                    "};",
                    "const JSONToValue = (json, type) => {",
                    "    switch (type) {",
                    "        case 'Vector3':",
                    "            return new THREE.Vector3(json.x, json.y, json.z);",
                    "        case 'Vector4':",
                    "            return new THREE.Vector4(json.x, json.y, json.z, json.w);",
                    "        case 'Color':",
                    "            return new THREE.Vector3(json.r, json.g, json.b);",
                    "        case 'Number':",
                    "            return json;",
                    "        default:",
                    "            return json;",
                    "    }",
                    "};",
                    "const ValueToJSON = (value, type) => {",
                    "    switch (type) {",
                    "        case 'Vector3':",
                    "            return { x: value.x, y: value.y, z: value.z };",
                    "        case 'Vector4':",
                    "            return { x: value.x, y: value.y, z: value.z, w: value.w };",
                    "        case 'Color':",
                    "            return { r: value.x, g: value.y, b: value.z };",
                    "        case 'Number':",
                    "            return value;",
                    "        default:",
                    "            return value;",
                    "    }",
                    "};",
                    "",
                    "class RandomColor {",
                    "    constructor(a, b) {",
                    "        this.a = a;",
                    "        this.b = b;",
                    "        this.type = \"value\";",
                    "    }",
                    "    genColor(color) {",
                    "        const rand = Math.random();",
                    "        return color.copy(this.a).lerp(this.b, rand);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: \"RandomColor\",",
                    "            a: ColorToJSON(this.a),",
                    "            b: ColorToJSON(this.b),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new RandomColor(JSONToColor(json.a), JSONToColor(json.b));",
                    "    }",
                    "    clone() {",
                    "        return new RandomColor(this.a.clone(), this.b.clone());",
                    "    }",
                    "}",
                    "",
                    "class ColorRange {",
                    "    constructor(a, b) {",
                    "        this.a = a;",
                    "        this.b = b;",
                    "        this.type = 'value';",
                    "    }",
                    "    genColor(color, t) {",
                    "        return color.copy(this.a).lerp(this.b, Math.random());",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'ColorRange',",
                    "            a: ColorToJSON(this.a),",
                    "            b: ColorToJSON(this.b),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ColorRange(JSONToColor(json.a), JSONToColor(json.b));",
                    "    }",
                    "    clone() {",
                    "        return new ColorRange(this.a.clone(), this.b.clone());",
                    "    }",
                    "}",
                    "",
                    "class ContinuousLinearFunction {",
                    "    constructor(keys, subType) {",
                    "        this.subType = subType;",
                    "        this.type = 'function';",
                    "        this.keys = keys;",
                    "    }",
                    "    findKey(t) {",
                    "        let mid = 0;",
                    "        let left = 0, right = this.keys.length - 1;",
                    "        while (left + 1 < right) {",
                    "            mid = Math.floor((left + right) / 2);",
                    "            if (t < this.getStartX(mid))",
                    "                right = mid - 1;",
                    "            else if (t > this.getEndX(mid))",
                    "                left = mid + 1;",
                    "            else",
                    "                return mid;",
                    "        }",
                    "        for (let i = left; i <= right; i++) {",
                    "            if (t >= this.getStartX(i) && t <= this.getEndX(i))",
                    "                return i;",
                    "        }",
                    "        return -1;",
                    "    }",
                    "    getStartX(index) {",
                    "        return this.keys[index][1];",
                    "    }",
                    "    getEndX(index) {",
                    "        if (index + 1 < this.keys.length)",
                    "            return this.keys[index + 1][1];",
                    "        return 1;",
                    "    }",
                    "    genValue(value, t) {",
                    "        const index = this.findKey(t);",
                    "        if (this.subType === 'Number') {",
                    "            if (index === -1) {",
                    "                return this.keys[0][0];",
                    "            }",
                    "            else if (index + 1 >= this.keys.length) {",
                    "                return this.keys[this.keys.length - 1][0];",
                    "            }",
                    "            return ((this.keys[index + 1][0] - this.keys[index][0]) *",
                    "                ((t - this.getStartX(index)) / (this.getEndX(index) - this.getStartX(index))) +",
                    "                this.keys[index][0]);",
                    "        }",
                    "        else {",
                    "            if (index === -1) {",
                    "                return value.copy(this.keys[0][0]);",
                    "            }",
                    "            if (index + 1 >= this.keys.length) {",
                    "                return value.copy(this.keys[this.keys.length - 1][0]);",
                    "            }",
                    "            return value",
                    "                .copy(this.keys[index][0])",
                    "                .lerp(this.keys[index + 1][0], (t - this.getStartX(index)) / (this.getEndX(index) - this.getStartX(index)));",
                    "        }",
                    "    }",
                    "    toJSON() {",
                    "        this.keys[0][0].constructor.name;",
                    "        return {",
                    "            type: 'CLinearFunction',",
                    "            subType: this.subType,",
                    "            keys: this.keys.map(([color, pos]) => ({ value: ValueToJSON(color, this.subType), pos: pos })),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ContinuousLinearFunction(json.keys.map((pair) => [JSONToValue(pair.value, json.subType), pair.pos]), json.subType);",
                    "    }",
                    "    clone() {",
                    "        if (this.subType === 'Number') {",
                    "            return new ContinuousLinearFunction(this.keys.map(([value, pos]) => [value, pos]), this.subType);",
                    "        }",
                    "        else {",
                    "            return new ContinuousLinearFunction(this.keys.map(([value, pos]) => [value.clone(), pos]), this.subType);",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "const tempVec3 = new THREE.Vector3();",
                    "class Gradient {",
                    "    constructor(color = [",
                    "        [new THREE.Vector3(0, 0, 0), 0],",
                    "        [new THREE.Vector3(1, 1, 1), 0],",
                    "    ], alpha = [",
                    "        [1, 0],",
                    "        [1, 1],",
                    "    ]) {",
                    "        this.type = 'function';",
                    "        this.color = new ContinuousLinearFunction(color, 'Color');",
                    "        this.alpha = new ContinuousLinearFunction(alpha, 'Number');",
                    "    }",
                    "    genColor(color, t) {",
                    "        this.color.genValue(tempVec3, t);",
                    "        return color.set(tempVec3.x, tempVec3.y, tempVec3.z, this.alpha.genValue(1, t));",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'Gradient',",
                    "            color: this.color.toJSON(),",
                    "            alpha: this.alpha.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        if (json.functions) {",
                    "            const keys = json.functions.map((func) => [ColorRange.fromJSON(func.function).a, func.start]);",
                    "            if (json.functions.length > 0) {",
                    "                keys.push([ColorRange.fromJSON(json.functions[json.functions.length - 1].function).b, 1]);",
                    "            }",
                    "            return new Gradient(keys.map((key) => [new THREE.Vector3(key[0].x, key[0].y, key[0].z), key[1]]), keys.map((key) => [key[0].w, key[1]]));",
                    "        }",
                    "        else {",
                    "            const gradient = new Gradient();",
                    "            gradient.alpha = ContinuousLinearFunction.fromJSON(json.alpha);",
                    "            gradient.color = ContinuousLinearFunction.fromJSON(json.color);",
                    "            return gradient;",
                    "        }",
                    "    }",
                    "    clone() {",
                    "        const gradient = new Gradient();",
                    "        gradient.alpha = this.alpha.clone();",
                    "        gradient.color = this.color.clone();",
                    "        return gradient;",
                    "    }",
                    "}",
                    "",
                    "const tempColor = new THREE.Vector4();",
                    "class RandomColorBetweenGradient {",
                    "    constructor(gradient1, gradient2) {",
                    "        this.type = 'memorizedFunction';",
                    "        this.gradient1 = gradient1;",
                    "        this.gradient2 = gradient2;",
                    "    }",
                    "    startGen(memory) {",
                    "        memory.rand = Math.random();",
                    "    }",
                    "    genColor(color, t, memory) {",
                    "        this.gradient1.genColor(color, t);",
                    "        this.gradient2.genColor(tempColor, t);",
                    "        if (memory && memory.rand) {",
                    "            color.lerp(tempColor, memory.rand);",
                    "        }",
                    "        else {",
                    "            color.lerp(tempColor, Math.random());",
                    "        }",
                    "        return color;",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'RandomColorBetweenGradient',",
                    "            gradient1: this.gradient1.toJSON(),",
                    "            gradient2: this.gradient2.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new RandomColorBetweenGradient(Gradient.fromJSON(json.gradient1), Gradient.fromJSON(json.gradient2));",
                    "    }",
                    "    clone() {",
                    "        return new RandomColorBetweenGradient(this.gradient1.clone(), this.gradient2.clone());",
                    "    }",
                    "}",
                    "",
                    "class ConstantColor {",
                    "    constructor(color) {",
                    "        this.color = color;",
                    "        this.type = 'value';",
                    "    }",
                    "    genColor(color) {",
                    "        return color.copy(this.color);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'ConstantColor',",
                    "            color: ColorToJSON(this.color),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ConstantColor(JSONToColor(json.color));",
                    "    }",
                    "    clone() {",
                    "        return new ConstantColor(this.color.clone());",
                    "    }",
                    "}",
                    "function ColorGeneratorFromJSON(json) {",
                    "    switch (json.type) {",
                    "        case 'ConstantColor':",
                    "            return ConstantColor.fromJSON(json);",
                    "        case 'ColorRange':",
                    "            return ColorRange.fromJSON(json);",
                    "        case 'RandomColor':",
                    "            return RandomColor.fromJSON(json);",
                    "        case 'Gradient':",
                    "            return Gradient.fromJSON(json);",
                    "        case 'RandomColorBetweenGradient':",
                    "            return RandomColorBetweenGradient.fromJSON(json);",
                    "        default:",
                    "            return new ConstantColor(new THREE.Vector4(1, 1, 1, 1));",
                    "    }",
                    "}",
                    "",
                    "class ConstantValue {",
                    "    constructor(value) {",
                    "        this.value = value;",
                    "        this.type = 'value';",
                    "    }",
                    "    genValue() {",
                    "        return this.value;",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: \"ConstantValue\",",
                    "            value: this.value",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ConstantValue(json.value);",
                    "    }",
                    "    clone() {",
                    "        return new ConstantValue(this.value);",
                    "    }",
                    "}",
                    "",
                    "class IntervalValue {",
                    "    constructor(a, b) {",
                    "        this.a = a;",
                    "        this.b = b;",
                    "        this.type = 'value';",
                    "    }",
                    "    genValue() {",
                    "        return THREE.MathUtils.lerp(this.a, this.b, Math.random());",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'IntervalValue',",
                    "            a: this.a,",
                    "            b: this.b,",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new IntervalValue(json.a, json.b);",
                    "    }",
                    "    clone() {",
                    "        return new IntervalValue(this.a, this.b);",
                    "    }",
                    "}",
                    "",
                    "class PiecewiseFunction {",
                    "    constructor() {",
                    "        this.functions = new Array();",
                    "    }",
                    "    findFunction(t) {",
                    "        let mid = 0;",
                    "        let left = 0, right = this.functions.length - 1;",
                    "        while (left + 1 < right) {",
                    "            mid = Math.floor((left + right) / 2);",
                    "            if (t < this.getStartX(mid))",
                    "                right = mid - 1;",
                    "            else if (t > this.getEndX(mid))",
                    "                left = mid + 1;",
                    "            else",
                    "                return mid;",
                    "        }",
                    "        for (let i = left; i <= right; i++) {",
                    "            if (t >= this.functions[i][1] && t <= this.getEndX(i))",
                    "                return i;",
                    "        }",
                    "        return -1;",
                    "    }",
                    "    getStartX(index) {",
                    "        return this.functions[index][1];",
                    "    }",
                    "    setStartX(index, x) {",
                    "        if (index > 0)",
                    "            this.functions[index][1] = x;",
                    "    }",
                    "    getEndX(index) {",
                    "        if (index + 1 < this.functions.length)",
                    "            return this.functions[index + 1][1];",
                    "        return 1;",
                    "    }",
                    "    setEndX(index, x) {",
                    "        if (index + 1 < this.functions.length)",
                    "            this.functions[index + 1][1] = x;",
                    "    }",
                    "    insertFunction(t, func) {",
                    "        const index = this.findFunction(t);",
                    "        this.functions.splice(index + 1, 0, [func, t]);",
                    "    }",
                    "    removeFunction(index) {",
                    "        return this.functions.splice(index, 1)[0][0];",
                    "    }",
                    "    getFunction(index) {",
                    "        return this.functions[index][0];",
                    "    }",
                    "    setFunction(index, func) {",
                    "        this.functions[index][0] = func;",
                    "    }",
                    "    get numOfFunctions() {",
                    "        return this.functions.length;",
                    "    }",
                    "}",
                    "",
                    "class PiecewiseBezier extends PiecewiseFunction {",
                    "    constructor(curves = [[new Bezier(0, 1.0 / 3, 1.0 / 3 * 2, 1), 0]]) {",
                    "        super();",
                    "        this.type = \"function\";",
                    "        this.functions = curves;",
                    "    }",
                    "    genValue(t = 0) {",
                    "        const index = this.findFunction(t);",
                    "        if (index === -1) {",
                    "            return 0;",
                    "        }",
                    "        return this.functions[index][0].genValue((t - this.getStartX(index)) / (this.getEndX(index) - this.getStartX(index)));",
                    "    }",
                    "    toSVG(length, segments) {",
                    "        if (segments < 1)",
                    "            return \"\";",
                    "        let result = [\"M\", 0, this.functions[0][0].p[0]].join(\" \");",
                    "        for (let i = 1.0 / segments; i <= 1; i += 1.0 / segments) {",
                    "            result = [result, \"L\", i * length, this.genValue(i)].join(\" \");",
                    "        }",
                    "        return result;",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: \"PiecewiseBezier\",",
                    "            functions: this.functions.map(([bezier, start]) => ({ function: bezier.toJSON(), start: start })),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new PiecewiseBezier(json.functions.map((piecewiseFunction) => ([Bezier.fromJSON(piecewiseFunction.function), piecewiseFunction.start])));",
                    "    }",
                    "    clone() {",
                    "        return new PiecewiseBezier(this.functions.map(([bezier, start]) => ([bezier.clone(), start])));",
                    "    }",
                    "}",
                    "",
                    "function ValueGeneratorFromJSON(json) {",
                    "    switch (json.type) {",
                    "        case 'ConstantValue':",
                    "            return ConstantValue.fromJSON(json);",
                    "        case 'IntervalValue':",
                    "            return IntervalValue.fromJSON(json);",
                    "        case 'PiecewiseBezier':",
                    "            return PiecewiseBezier.fromJSON(json);",
                    "        default:",
                    "            return new ConstantValue(0);",
                    "    }",
                    "}",
                    "",
                    "class RandomQuatGenerator {",
                    "    constructor() {",
                    "        this.type = \"rotation\";",
                    "    }",
                    "    genValue(quat, t) {",
                    "        let x, y, z, u, v, w;",
                    "        do {",
                    "            x = Math.random() * 2 - 1;",
                    "            y = Math.random() * 2 - 1;",
                    "            z = x * x + y * y;",
                    "        } while (z > 1);",
                    "        do {",
                    "            u = Math.random() * 2 - 1;",
                    "            v = Math.random() * 2 - 1;",
                    "            w = u * u + v * v;",
                    "        } while (w > 1);",
                    "        const s = Math.sqrt((1 - z) / w);",
                    "        quat.set(x, y, s * u, s * v);",
                    "        return quat;",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: \"RandomQuat\"",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new RandomQuatGenerator();",
                    "    }",
                    "    clone() {",
                    "        return new RandomQuatGenerator();",
                    "    }",
                    "}",
                    "",
                    "class AxisAngleGenerator {",
                    "    constructor(axis, angle) {",
                    "        this.axis = axis;",
                    "        this.angle = angle;",
                    "        this.type = 'rotation';",
                    "    }",
                    "    genValue(quat, t) {",
                    "        return quat.setFromAxisAngle(this.axis, this.angle.genValue(t));",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'AxisAngle',",
                    "            axis: { x: this.axis.x, y: this.axis.y, z: this.axis.z },",
                    "            angle: this.angle.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new AxisAngleGenerator(new THREE.Vector3(json.axis.x, json.axis.y, json.axis.z), ValueGeneratorFromJSON(json.angle));",
                    "    }",
                    "    clone() {",
                    "        return new AxisAngleGenerator(this.axis.clone(), this.angle.clone());",
                    "    }",
                    "}",
                    "",
                    "class EulerGenerator {",
                    "    constructor(angleX, angleY, angleZ, eulerOrder) {",
                    "        this.angleX = angleX;",
                    "        this.angleY = angleY;",
                    "        this.angleZ = angleZ;",
                    "        this.type = 'rotation';",
                    "        this.eular = new THREE.Euler(0, 0, 0, eulerOrder);",
                    "    }",
                    "    genValue(quat, t) {",
                    "        this.eular.set(this.angleX.genValue(t), this.angleY.genValue(t), this.angleZ.genValue(t));",
                    "        return quat.setFromEuler(this.eular);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'Euler',",
                    "            angleX: this.angleX.toJSON(),",
                    "            angleY: this.angleY.toJSON(),",
                    "            angleZ: this.angleZ.toJSON(),",
                    "            eulerOrder: this.eular.order,",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new EulerGenerator(ValueGeneratorFromJSON(json.angleX), ValueGeneratorFromJSON(json.angleY), ValueGeneratorFromJSON(json.angleZ), json.eulerOrder);",
                    "    }",
                    "    clone() {",
                    "        return new EulerGenerator(this.angleX, this.angleY, this.angleZ, this.eular.order);",
                    "    }",
                    "}",
                    "",
                    "function RotationGeneratorFromJSON(json) {",
                    "    switch (json.type) {",
                    "        case 'AxisAngle':",
                    "            return AxisAngleGenerator.fromJSON(json);",
                    "        case 'Euler':",
                    "            return EulerGenerator.fromJSON(json);",
                    "        case 'RandomQuat':",
                    "            return RandomQuatGenerator.fromJSON(json);",
                    "        default:",
                    "            return new RandomQuatGenerator();",
                    "    }",
                    "}",
                    "",
                    "function GeneratorFromJSON(json) {",
                    "    switch (json.type) {",
                    "        case 'ConstantValue':",
                    "        case 'IntervalValue':",
                    "        case 'PiecewiseBezier':",
                    "            return ValueGeneratorFromJSON(json);",
                    "        case 'AxisAngle':",
                    "        case 'RandomQuat':",
                    "        case 'Euler':",
                    "            return RotationGeneratorFromJSON(json);",
                    "        default:",
                    "            return new ConstantValue(0);",
                    "    }",
                    "}",
                    "",
                    "class ColorOverLife {",
                    "    constructor(color) {",
                    "        this.color = color;",
                    "        this.type = 'ColorOverLife';",
                    "    }",
                    "    initialize(particle) {",
                    "        if (this.color.type === 'memorizedFunction') {",
                    "            particle.colorOverLifeMemory = {};",
                    "            this.color.startGen(particle.colorOverLifeMemory);",
                    "        }",
                    "    }",
                    "    update(particle, delta) {",
                    "        if (this.color.type === 'memorizedFunction') {",
                    "            this.color.genColor(particle.color, particle.age / particle.life, particle.colorOverLifeMemory);",
                    "        }",
                    "        else {",
                    "            this.color.genColor(particle.color, particle.age / particle.life);",
                    "        }",
                    "        particle.color.x *= particle.startColor.x;",
                    "        particle.color.y *= particle.startColor.y;",
                    "        particle.color.z *= particle.startColor.z;",
                    "        particle.color.w *= particle.startColor.w;",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            color: this.color.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ColorOverLife(ColorGeneratorFromJSON(json.color));",
                    "    }",
                    "    clone() {",
                    "        return new ColorOverLife(this.color.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "class RotationOverLife {",
                    "    constructor(angularVelocity) {",
                    "        this.angularVelocity = angularVelocity;",
                    "        this.type = 'RotationOverLife';",
                    "        this.dynamic = !(angularVelocity instanceof ConstantValue || angularVelocity instanceof IntervalValue);",
                    "    }",
                    "    initialize(particle) {",
                    "        this.dynamic = !(this.angularVelocity instanceof ConstantValue || this.angularVelocity instanceof IntervalValue);",
                    "        if (!this.dynamic && typeof particle.rotation === 'number') {",
                    "            particle.angularVelocity = this.angularVelocity.genValue();",
                    "        }",
                    "    }",
                    "    update(particle, delta) {",
                    "        if (!this.dynamic) {",
                    "            if (typeof particle.rotation === 'number') {",
                    "                particle.rotation += delta * particle.angularVelocity;",
                    "            }",
                    "        }",
                    "        else {",
                    "            if (typeof particle.rotation === 'number') {",
                    "                particle.rotation +=",
                    "                    delta * this.angularVelocity.genValue(particle.age / particle.life);",
                    "            }",
                    "        }",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            angularVelocity: this.angularVelocity.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new RotationOverLife(ValueGeneratorFromJSON(json.angularVelocity));",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    clone() {",
                    "        return new RotationOverLife(this.angularVelocity.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "const IdentityQuaternion = new THREE.Quaternion();",
                    "class Rotation3DOverLife {",
                    "    constructor(angularVelocity) {",
                    "        this.angularVelocity = angularVelocity;",
                    "        this.type = 'Rotation3DOverLife';",
                    "        this.tempQuat = new THREE.Quaternion();",
                    "        this.dynamic = !(angularVelocity instanceof RandomQuatGenerator);",
                    "    }",
                    "    initialize(particle) {",
                    "        this.dynamic = !(this.angularVelocity instanceof RandomQuatGenerator);",
                    "        if (particle.rotation instanceof THREE.Quaternion) {",
                    "            particle.angularVelocity = new THREE.Quaternion();",
                    "            this.angularVelocity.genValue(particle.angularVelocity);",
                    "        }",
                    "    }",
                    "    update(particle, delta) {",
                    "        if (particle.rotation instanceof THREE.Quaternion) {",
                    "            if (!this.dynamic) {",
                    "                this.tempQuat.slerpQuaternions(IdentityQuaternion, particle.angularVelocity, delta);",
                    "                particle.rotation.multiply(this.tempQuat);",
                    "            }",
                    "            else {",
                    "                this.angularVelocity.genValue(this.tempQuat, particle.age / particle.life);",
                    "                this.tempQuat.slerpQuaternions(IdentityQuaternion, this.tempQuat, delta);",
                    "                particle.rotation.multiply(this.tempQuat);",
                    "            }",
                    "        }",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            angularVelocity: this.angularVelocity.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new Rotation3DOverLife(RotationGeneratorFromJSON(json.angularVelocity));",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    clone() {",
                    "        return new Rotation3DOverLife(this.angularVelocity.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "class ForceOverLife {",
                    "    initialize(particle) { }",
                    "    constructor(x, y, z) {",
                    "        this.x = x;",
                    "        this.y = y;",
                    "        this.z = z;",
                    "        this.type = 'ForceOverLife';",
                    "        this._temp = new THREE.Vector3();",
                    "    }",
                    "    update(particle, delta) {",
                    "        this._temp.set(this.x.genValue(particle.age / particle.life), this.y.genValue(particle.age / particle.life), this.z.genValue(particle.age / particle.life));",
                    "        particle.velocity.addScaledVector(this._temp, delta);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            x: this.x.toJSON(),",
                    "            y: this.y.toJSON(),",
                    "            z: this.z.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ForceOverLife(ValueGeneratorFromJSON(json.x), ValueGeneratorFromJSON(json.y), ValueGeneratorFromJSON(json.z));",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    clone() {",
                    "        return new ForceOverLife(this.x.clone(), this.y.clone(), this.z.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "class SizeOverLife {",
                    "    initialize(particle) {",
                    "    }",
                    "    constructor(size) {",
                    "        this.size = size;",
                    "        this.type = 'SizeOverLife';",
                    "    }",
                    "    update(particle) {",
                    "        particle.size = particle.startSize * this.size.genValue(particle.age / particle.life);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            size: this.size.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new SizeOverLife(ValueGeneratorFromJSON(json.size));",
                    "    }",
                    "    frameUpdate(delta) {",
                    "    }",
                    "    clone() {",
                    "        return new SizeOverLife(this.size.clone());",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "class SpeedOverLife {",
                    "    initialize(particle) {",
                    "    }",
                    "    constructor(speed) {",
                    "        this.speed = speed;",
                    "        this.type = 'SpeedOverLife';",
                    "    }",
                    "    update(particle) {",
                    "        particle.speedModifier = this.speed.genValue(particle.age / particle.life);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            speed: this.speed.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new SpeedOverLife(ValueGeneratorFromJSON(json.speed));",
                    "    }",
                    "    frameUpdate(delta) {",
                    "    }",
                    "    clone() {",
                    "        return new SpeedOverLife(this.speed.clone());",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "class FrameOverLife {",
                    "    constructor(frame) {",
                    "        this.frame = frame;",
                    "        this.type = 'FrameOverLife';",
                    "    }",
                    "    initialize(particle) {",
                    "        if (!(this.frame instanceof PiecewiseBezier)) {",
                    "            particle.uvTile = Math.floor(this.frame.genValue(0) + 0.001);",
                    "        }",
                    "    }",
                    "    update(particle, delta) {",
                    "        if (this.frame instanceof PiecewiseBezier) {",
                    "            particle.uvTile = Math.floor(this.frame.genValue(particle.age / particle.life) + 0.001);",
                    "        }",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            frame: this.frame.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new FrameOverLife(ValueGeneratorFromJSON(json.frame));",
                    "    }",
                    "    clone() {",
                    "        return new FrameOverLife(this.frame.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "new THREE.Vector3(0, 0, 1);",
                    "class OrbitOverLife {",
                    "    constructor(orbitSpeed, axis = new THREE.Vector3(0, 1, 0)) {",
                    "        this.orbitSpeed = orbitSpeed;",
                    "        this.axis = axis;",
                    "        this.type = 'OrbitOverLife';",
                    "        this.temp = new THREE.Vector3();",
                    "        this.rotation = new THREE.Quaternion();",
                    "        this.line = new THREE.Line3();",
                    "    }",
                    "    initialize(particle) {",
                    "    }",
                    "    update(particle, delta) {",
                    "        this.line.set(new THREE.Vector3(0, 0, 0), this.axis);",
                    "        this.line.closestPointToPoint(particle.position, false, this.temp);",
                    "        this.rotation.setFromAxisAngle(this.axis, this.orbitSpeed.genValue(particle.age / particle.life) * delta);",
                    "        particle.position.sub(this.temp);",
                    "        particle.position.applyQuaternion(this.rotation);",
                    "        particle.position.add(this.temp);",
                    "    }",
                    "    frameUpdate(delta) {",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            orbitSpeed: this.orbitSpeed.toJSON(),",
                    "            axis: [this.axis.x, this.axis.y, this.axis.z],",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new OrbitOverLife(ValueGeneratorFromJSON(json.orbitSpeed), json.axis ? new THREE.Vector3(json.axis[0], json.axis[1], json.axis[2]) : undefined);",
                    "    }",
                    "    clone() {",
                    "        return new OrbitOverLife(this.orbitSpeed.clone());",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "class WidthOverLength {",
                    "    initialize(particle) {",
                    "    }",
                    "    constructor(width) {",
                    "        this.width = width;",
                    "        this.type = 'WidthOverLength';",
                    "    }",
                    "    update(particle) {",
                    "        if (particle instanceof TrailParticle) {",
                    "            const iter = particle.previous.values();",
                    "            for (let i = 0; i < particle.previous.length; i++) {",
                    "                const cur = iter.next();",
                    "                cur.value.size = this.width.genValue((particle.previous.length - i) / particle.length);",
                    "            }",
                    "        }",
                    "    }",
                    "    frameUpdate(delta) {",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            width: this.width.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new WidthOverLength(ValueGeneratorFromJSON(json.width));",
                    "    }",
                    "    clone() {",
                    "        return new WidthOverLength(this.width.clone());",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "class ApplyForce {",
                    "    constructor(direction, magnitude) {",
                    "        this.direction = direction;",
                    "        this.magnitude = magnitude;",
                    "        this.type = 'ApplyForce';",
                    "        this.magnitudeValue = this.magnitude.genValue();",
                    "    }",
                    "    initialize(particle) {",
                    "    }",
                    "    update(particle, delta) {",
                    "        particle.velocity.addScaledVector(this.direction, this.magnitudeValue * delta);",
                    "    }",
                    "    frameUpdate(delta) {",
                    "        this.magnitudeValue = this.magnitude.genValue();",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            direction: [this.direction.x, this.direction.y, this.direction.z],",
                    "            magnitude: this.magnitude.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        var _a;",
                    "        return new ApplyForce(new THREE.Vector3(json.direction[0], json.direction[1], json.direction[2]), ValueGeneratorFromJSON((_a = json.magnitude) !== null && _a !== void 0 ? _a : json.force));",
                    "    }",
                    "    clone() {",
                    "        return new ApplyForce(this.direction.clone(), this.magnitude.clone());",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "class GravityForce {",
                    "    constructor(center, magnitude) {",
                    "        this.center = center;",
                    "        this.magnitude = magnitude;",
                    "        this.type = 'GravityForce';",
                    "        this.temp = new THREE.Vector3();",
                    "    }",
                    "    initialize(particle) {",
                    "    }",
                    "    update(particle, delta) {",
                    "        this.temp.copy(this.center).sub(particle.position).normalize();",
                    "        particle.velocity.addScaledVector(this.temp, this.magnitude / particle.position.distanceToSquared(this.center) * delta);",
                    "    }",
                    "    frameUpdate(delta) {",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            center: [this.center.x, this.center.y, this.center.z],",
                    "            magnitude: this.magnitude,",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new GravityForce(new THREE.Vector3(json.center[0], json.center[1], json.center[2]), json.magnitude);",
                    "    }",
                    "    clone() {",
                    "        return new GravityForce(this.center.clone(), this.magnitude);",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "new THREE.Vector3(0, 0, 1);",
                    "class ChangeEmitDirection {",
                    "    constructor(angle) {",
                    "        this.angle = angle;",
                    "        this.type = 'ChangeEmitDirection';",
                    "        this._temp = new THREE.Vector3();",
                    "        this._q = new THREE.Quaternion();",
                    "    }",
                    "    initialize(particle) {",
                    "        const len = particle.velocity.length();",
                    "        if (len == 0)",
                    "            return;",
                    "        particle.velocity.normalize();",
                    "        if (particle.velocity.x === 0 && particle.velocity.y === 0) {",
                    "            this._temp.set(0, particle.velocity.z, 0);",
                    "        }",
                    "        else {",
                    "            this._temp.set(-particle.velocity.y, particle.velocity.x, 0);",
                    "        }",
                    "        this._q.setFromAxisAngle(this._temp.normalize(), this.angle.genValue());",
                    "        this._temp.copy(particle.velocity);",
                    "        particle.velocity.applyQuaternion(this._q);",
                    "        this._q.setFromAxisAngle(this._temp, Math.random() * Math.PI * 2);",
                    "        particle.velocity.applyQuaternion(this._q);",
                    "        particle.velocity.setLength(len);",
                    "    }",
                    "    update(particle, delta) {",
                    "    }",
                    "    frameUpdate(delta) {",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            angle: this.angle.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ChangeEmitDirection(ValueGeneratorFromJSON(json.angle));",
                    "    }",
                    "    clone() {",
                    "        return new ChangeEmitDirection(this.angle);",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "const VECTOR_ONE = new THREE.Vector3(1, 1, 1);",
                    "const VECTOR_Z = new THREE.Vector3(0, 0, 1);",
                    "gdjs.__particleEmmiter3DExtension.SubParticleEmitMode = void 0;",
                    "(function (SubParticleEmitMode) {",
                    "    SubParticleEmitMode[SubParticleEmitMode[\"Death\"] = 0] = \"Death\";",
                    "    SubParticleEmitMode[SubParticleEmitMode[\"Birth\"] = 1] = \"Birth\";",
                    "    SubParticleEmitMode[SubParticleEmitMode[\"Frame\"] = 2] = \"Frame\";",
                    "})(gdjs.__particleEmmiter3DExtension.SubParticleEmitMode || (gdjs.__particleEmmiter3DExtension.SubParticleEmitMode = {}));",
                    "class EmitSubParticleSystem {",
                    "    constructor(particleSystem, useVelocityAsBasis, subParticleSystem, mode = gdjs.__particleEmmiter3DExtension.SubParticleEmitMode.Frame, emitProbability = 1) {",
                    "        this.particleSystem = particleSystem;",
                    "        this.useVelocityAsBasis = useVelocityAsBasis;",
                    "        this.subParticleSystem = subParticleSystem;",
                    "        this.mode = mode;",
                    "        this.emitProbability = emitProbability;",
                    "        this.type = 'EmitSubParticleSystem';",
                    "        this.q_ = new THREE.Quaternion();",
                    "        this.v_ = new THREE.Vector3();",
                    "        this.v2_ = new THREE.Vector3();",
                    "        this.subEmissions = new Array();",
                    "        if (this.subParticleSystem && this.subParticleSystem.system) {",
                    "            this.subParticleSystem.system.onlyUsedByOther = true;",
                    "        }",
                    "    }",
                    "    initialize(particle) {",
                    "    }",
                    "    update(particle, delta) {",
                    "        if (this.mode === gdjs.__particleEmmiter3DExtension.SubParticleEmitMode.Frame) {",
                    "            this.emit(particle, delta);",
                    "        }",
                    "        else if (this.mode === gdjs.__particleEmmiter3DExtension.SubParticleEmitMode.Birth && particle.age === 0) {",
                    "            this.emit(particle, delta);",
                    "        }",
                    "        else if (this.mode === gdjs.__particleEmmiter3DExtension.SubParticleEmitMode.Death && particle.age + delta >= particle.life) {",
                    "            this.emit(particle, delta);",
                    "        }",
                    "    }",
                    "    emit(particle, delta) {",
                    "        if (!this.subParticleSystem)",
                    "            return;",
                    "        if (Math.random() > this.emitProbability) {",
                    "            return;",
                    "        }",
                    "        const m = new THREE.Matrix4();",
                    "        this.setMatrixFromParticle(m, particle);",
                    "        this.subEmissions.push({",
                    "            burstIndex: 0,",
                    "            burstWaveIndex: 0,",
                    "            time: 0,",
                    "            waitEmiting: 0,",
                    "            matrix: m,",
                    "            travelDistance: 0,",
                    "            particle: particle,",
                    "        });",
                    "    }",
                    "    frameUpdate(delta) {",
                    "        if (!this.subParticleSystem)",
                    "            return;",
                    "        for (let i = 0; i < this.subEmissions.length; i++) {",
                    "            if (this.subEmissions[i].time >= this.subParticleSystem.system.duration) {",
                    "                this.subEmissions[i] = this.subEmissions[this.subEmissions.length - 1];",
                    "                this.subEmissions.length = this.subEmissions.length - 1;",
                    "                i--;",
                    "            }",
                    "            else {",
                    "                let subEmissionState = this.subEmissions[i];",
                    "                if (subEmissionState.particle && subEmissionState.particle.age < subEmissionState.particle.life) {",
                    "                    this.setMatrixFromParticle(subEmissionState.matrix, subEmissionState.particle);",
                    "                }",
                    "                else {",
                    "                    subEmissionState.particle = undefined;",
                    "                }",
                    "                this.subParticleSystem.system.emit(delta, subEmissionState, subEmissionState.matrix);",
                    "            }",
                    "        }",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            subParticleSystem: this.subParticleSystem ? this.subParticleSystem.uuid : '',",
                    "            useVelocityAsBasis: this.useVelocityAsBasis,",
                    "            mode: this.mode,",
                    "            emitProbability: this.emitProbability,",
                    "        };",
                    "    }",
                    "    static fromJSON(json, particleSystem) {",
                    "        return new EmitSubParticleSystem(particleSystem, json.useVelocityAsBasis, json.subParticleSystem, json.mode, json.emitProbability);",
                    "    }",
                    "    clone() {",
                    "        return new EmitSubParticleSystem(this.particleSystem, this.useVelocityAsBasis, this.subParticleSystem, this.mode, this.emitProbability);",
                    "    }",
                    "    reset() { }",
                    "    setMatrixFromParticle(m, particle) {",
                    "        let rotation;",
                    "        if (particle.rotation === undefined || this.useVelocityAsBasis) {",
                    "            if (particle.velocity.x === 0 &&",
                    "                particle.velocity.y === 0 &&",
                    "                (particle.velocity.z === 1 || particle.velocity.z === 0)) {",
                    "                m.set(1, 0, 0, particle.position.x, 0, 1, 0, particle.position.y, 0, 0, 1, particle.position.z, 0, 0, 0, 1);",
                    "            }",
                    "            else {",
                    "                this.v_.copy(VECTOR_Z).cross(particle.velocity);",
                    "                this.v2_.copy(particle.velocity).cross(this.v_);",
                    "                const len = this.v_.length();",
                    "                const len2 = this.v2_.length();",
                    "                m.set(this.v_.x / len, this.v2_.x / len2, particle.velocity.x, particle.position.x, this.v_.y / len, this.v2_.y / len2, particle.velocity.y, particle.position.y, this.v_.z / len, this.v2_.z / len2, particle.velocity.z, particle.position.z, 0, 0, 0, 1);",
                    "            }",
                    "        }",
                    "        else {",
                    "            if (particle.rotation instanceof THREE.Quaternion) {",
                    "                rotation = particle.rotation;",
                    "            }",
                    "            else {",
                    "                this.q_.setFromAxisAngle(VECTOR_Z, particle.rotation);",
                    "                rotation = this.q_;",
                    "            }",
                    "            m.compose(particle.position, rotation, VECTOR_ONE);",
                    "        }",
                    "        if (!this.particleSystem.worldSpace) {",
                    "            m.multiplyMatrices(this.particleSystem.emitter.matrixWorld, m);",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);",
                    "const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;",
                    "const F3 = 1.0 / 3.0;",
                    "const G3 = 1.0 / 6.0;",
                    "const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;",
                    "const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;",
                    "const grad3 = new Float32Array([1, 1, 0,",
                    "    -1, 1, 0,",
                    "    1, -1, 0,",
                    "    -1, -1, 0,",
                    "    1, 0, 1,",
                    "    -1, 0, 1,",
                    "    1, 0, -1,",
                    "    -1, 0, -1,",
                    "    0, 1, 1,",
                    "    0, -1, 1,",
                    "    0, 1, -1,",
                    "    0, -1, -1]);",
                    "const grad4 = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,",
                    "    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,",
                    "    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,",
                    "    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,",
                    "    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,",
                    "    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,",
                    "    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,",
                    "    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);",
                    "class SimplexNoise {",
                    "    constructor(randomOrSeed = Math.random) {",
                    "        const random = typeof randomOrSeed == 'function' ? randomOrSeed : alea(randomOrSeed);",
                    "        this.p = buildPermutationTable(random);",
                    "        this.perm = new Uint8Array(512);",
                    "        this.permMod12 = new Uint8Array(512);",
                    "        for (let i = 0; i < 512; i++) {",
                    "            this.perm[i] = this.p[i & 255];",
                    "            this.permMod12[i] = this.perm[i] % 12;",
                    "        }",
                    "    }",
                    "    noise2D(x, y) {",
                    "        const permMod12 = this.permMod12;",
                    "        const perm = this.perm;",
                    "        let n0 = 0;",
                    "        let n1 = 0;",
                    "        let n2 = 0;",
                    "        const s = (x + y) * F2;",
                    "        const i = Math.floor(x + s);",
                    "        const j = Math.floor(y + s);",
                    "        const t = (i + j) * G2;",
                    "        const X0 = i - t;",
                    "        const Y0 = j - t;",
                    "        const x0 = x - X0;",
                    "        const y0 = y - Y0;",
                    "        let i1, j1;",
                    "        if (x0 > y0) {",
                    "            i1 = 1;",
                    "            j1 = 0;",
                    "        }",
                    "        else {",
                    "            i1 = 0;",
                    "            j1 = 1;",
                    "        }",
                    "        const x1 = x0 - i1 + G2;",
                    "        const y1 = y0 - j1 + G2;",
                    "        const x2 = x0 - 1.0 + 2.0 * G2;",
                    "        const y2 = y0 - 1.0 + 2.0 * G2;",
                    "        const ii = i & 255;",
                    "        const jj = j & 255;",
                    "        let t0 = 0.5 - x0 * x0 - y0 * y0;",
                    "        if (t0 >= 0) {",
                    "            const gi0 = permMod12[ii + perm[jj]] * 3;",
                    "            t0 *= t0;",
                    "            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0);",
                    "        }",
                    "        let t1 = 0.5 - x1 * x1 - y1 * y1;",
                    "        if (t1 >= 0) {",
                    "            const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;",
                    "            t1 *= t1;",
                    "            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);",
                    "        }",
                    "        let t2 = 0.5 - x2 * x2 - y2 * y2;",
                    "        if (t2 >= 0) {",
                    "            const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;",
                    "            t2 *= t2;",
                    "            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);",
                    "        }",
                    "        return 70.0 * (n0 + n1 + n2);",
                    "    }",
                    "    noise3D(x, y, z) {",
                    "        const permMod12 = this.permMod12;",
                    "        const perm = this.perm;",
                    "        let n0, n1, n2, n3;",
                    "        const s = (x + y + z) * F3;",
                    "        const i = Math.floor(x + s);",
                    "        const j = Math.floor(y + s);",
                    "        const k = Math.floor(z + s);",
                    "        const t = (i + j + k) * G3;",
                    "        const X0 = i - t;",
                    "        const Y0 = j - t;",
                    "        const Z0 = k - t;",
                    "        const x0 = x - X0;",
                    "        const y0 = y - Y0;",
                    "        const z0 = z - Z0;",
                    "        let i1, j1, k1;",
                    "        let i2, j2, k2;",
                    "        if (x0 >= y0) {",
                    "            if (y0 >= z0) {",
                    "                i1 = 1;",
                    "                j1 = 0;",
                    "                k1 = 0;",
                    "                i2 = 1;",
                    "                j2 = 1;",
                    "                k2 = 0;",
                    "            }",
                    "            else if (x0 >= z0) {",
                    "                i1 = 1;",
                    "                j1 = 0;",
                    "                k1 = 0;",
                    "                i2 = 1;",
                    "                j2 = 0;",
                    "                k2 = 1;",
                    "            }",
                    "            else {",
                    "                i1 = 0;",
                    "                j1 = 0;",
                    "                k1 = 1;",
                    "                i2 = 1;",
                    "                j2 = 0;",
                    "                k2 = 1;",
                    "            }",
                    "        }",
                    "        else {",
                    "            if (y0 < z0) {",
                    "                i1 = 0;",
                    "                j1 = 0;",
                    "                k1 = 1;",
                    "                i2 = 0;",
                    "                j2 = 1;",
                    "                k2 = 1;",
                    "            }",
                    "            else if (x0 < z0) {",
                    "                i1 = 0;",
                    "                j1 = 1;",
                    "                k1 = 0;",
                    "                i2 = 0;",
                    "                j2 = 1;",
                    "                k2 = 1;",
                    "            }",
                    "            else {",
                    "                i1 = 0;",
                    "                j1 = 1;",
                    "                k1 = 0;",
                    "                i2 = 1;",
                    "                j2 = 1;",
                    "                k2 = 0;",
                    "            }",
                    "        }",
                    "        const x1 = x0 - i1 + G3;",
                    "        const y1 = y0 - j1 + G3;",
                    "        const z1 = z0 - k1 + G3;",
                    "        const x2 = x0 - i2 + 2.0 * G3;",
                    "        const y2 = y0 - j2 + 2.0 * G3;",
                    "        const z2 = z0 - k2 + 2.0 * G3;",
                    "        const x3 = x0 - 1.0 + 3.0 * G3;",
                    "        const y3 = y0 - 1.0 + 3.0 * G3;",
                    "        const z3 = z0 - 1.0 + 3.0 * G3;",
                    "        const ii = i & 255;",
                    "        const jj = j & 255;",
                    "        const kk = k & 255;",
                    "        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;",
                    "        if (t0 < 0)",
                    "            n0 = 0.0;",
                    "        else {",
                    "            const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;",
                    "            t0 *= t0;",
                    "            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);",
                    "        }",
                    "        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;",
                    "        if (t1 < 0)",
                    "            n1 = 0.0;",
                    "        else {",
                    "            const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;",
                    "            t1 *= t1;",
                    "            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);",
                    "        }",
                    "        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;",
                    "        if (t2 < 0)",
                    "            n2 = 0.0;",
                    "        else {",
                    "            const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;",
                    "            t2 *= t2;",
                    "            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);",
                    "        }",
                    "        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;",
                    "        if (t3 < 0)",
                    "            n3 = 0.0;",
                    "        else {",
                    "            const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;",
                    "            t3 *= t3;",
                    "            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);",
                    "        }",
                    "        return 32.0 * (n0 + n1 + n2 + n3);",
                    "    }",
                    "    noise4D(x, y, z, w) {",
                    "        const perm = this.perm;",
                    "        let n0, n1, n2, n3, n4;",
                    "        const s = (x + y + z + w) * F4;",
                    "        const i = Math.floor(x + s);",
                    "        const j = Math.floor(y + s);",
                    "        const k = Math.floor(z + s);",
                    "        const l = Math.floor(w + s);",
                    "        const t = (i + j + k + l) * G4;",
                    "        const X0 = i - t;",
                    "        const Y0 = j - t;",
                    "        const Z0 = k - t;",
                    "        const W0 = l - t;",
                    "        const x0 = x - X0;",
                    "        const y0 = y - Y0;",
                    "        const z0 = z - Z0;",
                    "        const w0 = w - W0;",
                    "        let rankx = 0;",
                    "        let ranky = 0;",
                    "        let rankz = 0;",
                    "        let rankw = 0;",
                    "        if (x0 > y0)",
                    "            rankx++;",
                    "        else",
                    "            ranky++;",
                    "        if (x0 > z0)",
                    "            rankx++;",
                    "        else",
                    "            rankz++;",
                    "        if (x0 > w0)",
                    "            rankx++;",
                    "        else",
                    "            rankw++;",
                    "        if (y0 > z0)",
                    "            ranky++;",
                    "        else",
                    "            rankz++;",
                    "        if (y0 > w0)",
                    "            ranky++;",
                    "        else",
                    "            rankw++;",
                    "        if (z0 > w0)",
                    "            rankz++;",
                    "        else",
                    "            rankw++;",
                    "        const i1 = rankx >= 3 ? 1 : 0;",
                    "        const j1 = ranky >= 3 ? 1 : 0;",
                    "        const k1 = rankz >= 3 ? 1 : 0;",
                    "        const l1 = rankw >= 3 ? 1 : 0;",
                    "        const i2 = rankx >= 2 ? 1 : 0;",
                    "        const j2 = ranky >= 2 ? 1 : 0;",
                    "        const k2 = rankz >= 2 ? 1 : 0;",
                    "        const l2 = rankw >= 2 ? 1 : 0;",
                    "        const i3 = rankx >= 1 ? 1 : 0;",
                    "        const j3 = ranky >= 1 ? 1 : 0;",
                    "        const k3 = rankz >= 1 ? 1 : 0;",
                    "        const l3 = rankw >= 1 ? 1 : 0;",
                    "        const x1 = x0 - i1 + G4;",
                    "        const y1 = y0 - j1 + G4;",
                    "        const z1 = z0 - k1 + G4;",
                    "        const w1 = w0 - l1 + G4;",
                    "        const x2 = x0 - i2 + 2.0 * G4;",
                    "        const y2 = y0 - j2 + 2.0 * G4;",
                    "        const z2 = z0 - k2 + 2.0 * G4;",
                    "        const w2 = w0 - l2 + 2.0 * G4;",
                    "        const x3 = x0 - i3 + 3.0 * G4;",
                    "        const y3 = y0 - j3 + 3.0 * G4;",
                    "        const z3 = z0 - k3 + 3.0 * G4;",
                    "        const w3 = w0 - l3 + 3.0 * G4;",
                    "        const x4 = x0 - 1.0 + 4.0 * G4;",
                    "        const y4 = y0 - 1.0 + 4.0 * G4;",
                    "        const z4 = z0 - 1.0 + 4.0 * G4;",
                    "        const w4 = w0 - 1.0 + 4.0 * G4;",
                    "        const ii = i & 255;",
                    "        const jj = j & 255;",
                    "        const kk = k & 255;",
                    "        const ll = l & 255;",
                    "        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;",
                    "        if (t0 < 0)",
                    "            n0 = 0.0;",
                    "        else {",
                    "            const gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;",
                    "            t0 *= t0;",
                    "            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);",
                    "        }",
                    "        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;",
                    "        if (t1 < 0)",
                    "            n1 = 0.0;",
                    "        else {",
                    "            const gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;",
                    "            t1 *= t1;",
                    "            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);",
                    "        }",
                    "        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;",
                    "        if (t2 < 0)",
                    "            n2 = 0.0;",
                    "        else {",
                    "            const gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;",
                    "            t2 *= t2;",
                    "            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);",
                    "        }",
                    "        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;",
                    "        if (t3 < 0)",
                    "            n3 = 0.0;",
                    "        else {",
                    "            const gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;",
                    "            t3 *= t3;",
                    "            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);",
                    "        }",
                    "        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;",
                    "        if (t4 < 0)",
                    "            n4 = 0.0;",
                    "        else {",
                    "            const gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;",
                    "            t4 *= t4;",
                    "            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);",
                    "        }",
                    "        return 27.0 * (n0 + n1 + n2 + n3 + n4);",
                    "    }",
                    "}",
                    "function buildPermutationTable(random) {",
                    "    const p = new Uint8Array(256);",
                    "    for (let i = 0; i < 256; i++) {",
                    "        p[i] = i;",
                    "    }",
                    "    for (let i = 0; i < 255; i++) {",
                    "        const r = i + ~~(random() * (256 - i));",
                    "        const aux = p[i];",
                    "        p[i] = p[r];",
                    "        p[r] = aux;",
                    "    }",
                    "    return p;",
                    "}",
                    "function alea(seed) {",
                    "    let s0 = 0;",
                    "    let s1 = 0;",
                    "    let s2 = 0;",
                    "    let c = 1;",
                    "    const mash = masher();",
                    "    s0 = mash(' ');",
                    "    s1 = mash(' ');",
                    "    s2 = mash(' ');",
                    "    s0 -= mash(seed);",
                    "    if (s0 < 0) {",
                    "        s0 += 1;",
                    "    }",
                    "    s1 -= mash(seed);",
                    "    if (s1 < 0) {",
                    "        s1 += 1;",
                    "    }",
                    "    s2 -= mash(seed);",
                    "    if (s2 < 0) {",
                    "        s2 += 1;",
                    "    }",
                    "    return function () {",
                    "        const t = 2091639 * s0 + c * 2.3283064365386963e-10;",
                    "        s0 = s1;",
                    "        s1 = s2;",
                    "        return s2 = t - (c = t | 0);",
                    "    };",
                    "}",
                    "function masher() {",
                    "    let n = 0xefc8249d;",
                    "    return function (data) {",
                    "        data = data.toString();",
                    "        for (let i = 0; i < data.length; i++) {",
                    "            n += data.charCodeAt(i);",
                    "            let h = 0.02519603282416938 * n;",
                    "            n = h >>> 0;",
                    "            h -= n;",
                    "            h *= n;",
                    "            n = h >>> 0;",
                    "            h -= n;",
                    "            n += h * 0x100000000;",
                    "        }",
                    "        return (n >>> 0) * 2.3283064365386963e-10;",
                    "    };",
                    "}",
                    "",
                    "class TurbulenceField {",
                    "    constructor(scale, octaves, velocityMultiplier, timeScale) {",
                    "        this.scale = scale;",
                    "        this.octaves = octaves;",
                    "        this.velocityMultiplier = velocityMultiplier;",
                    "        this.timeScale = timeScale;",
                    "        this.type = 'TurbulenceField';",
                    "        this.generator = new SimplexNoise();",
                    "        this.timeOffset = new THREE.Vector3();",
                    "        this.temp = new THREE.Vector3();",
                    "        this.temp2 = new THREE.Vector3();",
                    "        this.timeOffset.x = Math.random() / this.scale.x * this.timeScale.x;",
                    "        this.timeOffset.y = Math.random() / this.scale.y * this.timeScale.y;",
                    "        this.timeOffset.z = Math.random() / this.scale.z * this.timeScale.z;",
                    "    }",
                    "    initialize(particle) {",
                    "    }",
                    "    update(particle, delta) {",
                    "        const x = particle.position.x / this.scale.x;",
                    "        const y = particle.position.y / this.scale.y;",
                    "        const z = particle.position.z / this.scale.z;",
                    "        this.temp.set(0, 0, 0);",
                    "        let lvl = 1;",
                    "        for (let i = 0; i < this.octaves; i++) {",
                    "            this.temp2.set(this.generator.noise4D(x * lvl, y * lvl, z * lvl, this.timeOffset.x * lvl) / lvl, this.generator.noise4D(x * lvl, y * lvl, z * lvl, this.timeOffset.y * lvl) / lvl, this.generator.noise4D(x * lvl, y * lvl, z * lvl, this.timeOffset.z * lvl) / lvl);",
                    "            this.temp.add(this.temp2);",
                    "            lvl *= 2;",
                    "        }",
                    "        this.temp.multiply(this.velocityMultiplier);",
                    "        particle.velocity.addScaledVector(this.temp, delta);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            scale: [this.scale.x, this.scale.y, this.scale.z],",
                    "            octaves: this.octaves,",
                    "            velocityMultiplier: [this.velocityMultiplier.x, this.velocityMultiplier.y, this.velocityMultiplier.z],",
                    "            timeScale: [this.timeScale.x, this.timeScale.y, this.timeScale.z],",
                    "        };",
                    "    }",
                    "    frameUpdate(delta) {",
                    "        this.timeOffset.x += delta * this.timeScale.x;",
                    "        this.timeOffset.y += delta * this.timeScale.y;",
                    "        this.timeOffset.z += delta * this.timeScale.z;",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new TurbulenceField(new THREE.Vector3(json.scale[0], json.scale[1], json.scale[2]), json.octaves, new THREE.Vector3(json.velocityMultiplier[0], json.velocityMultiplier[1], json.velocityMultiplier[2]), new THREE.Vector3(json.timeScale[0], json.timeScale[1], json.timeScale[2]));",
                    "    }",
                    "    clone() {",
                    "        return new TurbulenceField(this.scale.clone(), this.octaves, this.velocityMultiplier.clone(), this.timeScale.clone());",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "function randomInt(a, b) {",
                    "    return Math.floor(Math.random() * (b - a)) + a;",
                    "}",
                    "",
                    "const generators = [];",
                    "const tempV$2 = new THREE.Vector3();",
                    "const tempQ$2 = new THREE.Quaternion();",
                    "class Noise {",
                    "    constructor(frequency, power, positionAmount = new ConstantValue(1), rotationAmount = new ConstantValue(0)) {",
                    "        this.frequency = frequency;",
                    "        this.power = power;",
                    "        this.positionAmount = positionAmount;",
                    "        this.rotationAmount = rotationAmount;",
                    "        this.type = 'Noise';",
                    "        this.duration = 0;",
                    "        if (generators.length === 0) {",
                    "            for (let i = 0; i < 100; i++) {",
                    "                generators.push(new SimplexNoise());",
                    "            }",
                    "        }",
                    "    }",
                    "    initialize(particle) {",
                    "        particle.lastPosNoise = new THREE.Vector3();",
                    "        if (typeof particle.rotation === 'number') {",
                    "            particle.lastRotNoise = 0;",
                    "        }",
                    "        else {",
                    "            particle.lastRotNoise = new THREE.Quaternion();",
                    "        }",
                    "        particle.generatorIndex = [randomInt(0, 100), randomInt(0, 100), randomInt(0, 100), randomInt(0, 100)];",
                    "    }",
                    "    update(particle, _) {",
                    "        let frequency = this.frequency.genValue(particle.age / particle.life);",
                    "        let power = this.power.genValue(particle.age / particle.life);",
                    "        let positionAmount = this.positionAmount.genValue(particle.age / particle.life);",
                    "        let rotationAmount = this.rotationAmount.genValue(particle.age / particle.life);",
                    "        if (positionAmount > 0 && particle.lastPosNoise !== undefined) {",
                    "            particle.position.sub(particle.lastPosNoise);",
                    "            tempV$2.set(generators[particle.generatorIndex[0]].noise2D(0, particle.age * frequency) *",
                    "                power *",
                    "                positionAmount, generators[particle.generatorIndex[1]].noise2D(0, particle.age * frequency) *",
                    "                power *",
                    "                positionAmount, generators[particle.generatorIndex[2]].noise2D(0, particle.age * frequency) *",
                    "                power *",
                    "                positionAmount);",
                    "            particle.position.add(tempV$2);",
                    "            particle.lastPosNoise.copy(tempV$2);",
                    "        }",
                    "        if (rotationAmount > 0 && particle.lastRotNoise !== undefined) {",
                    "            if (typeof particle.rotation === 'number') {",
                    "                particle.rotation -= particle.lastRotNoise;",
                    "                particle.rotation +=",
                    "                    generators[particle.generatorIndex[3]].noise2D(0, particle.age * frequency) *",
                    "                    Math.PI *",
                    "                    power *",
                    "                    rotationAmount;",
                    "            }",
                    "            else {",
                    "                particle.lastRotNoise.invert();",
                    "                particle.rotation.multiply(particle.lastRotNoise);",
                    "                tempQ$2",
                    "                    .set(generators[particle.generatorIndex[0]].noise2D(0, particle.age * frequency) *",
                    "                        power *",
                    "                        rotationAmount, generators[particle.generatorIndex[1]].noise2D(0, particle.age * frequency) *",
                    "                        power *",
                    "                        rotationAmount, generators[particle.generatorIndex[2]].noise2D(0, particle.age * frequency) *",
                    "                        power *",
                    "                        rotationAmount, generators[particle.generatorIndex[3]].noise2D(0, particle.age * frequency) *",
                    "                        power *",
                    "                        rotationAmount)",
                    "                    .normalize();",
                    "                particle.rotation.multiply(tempQ$2);",
                    "                particle.lastRotNoise.copy(tempQ$2);",
                    "            }",
                    "        }",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            frequency: this.frequency.toJSON(),",
                    "            power: this.power.toJSON(),",
                    "            positionAmount: this.positionAmount.toJSON(),",
                    "            rotationAmount: this.rotationAmount.toJSON(),",
                    "        };",
                    "    }",
                    "    frameUpdate(delta) {",
                    "        this.duration += delta;",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new Noise(ValueGeneratorFromJSON(json.frequency), ValueGeneratorFromJSON(json.power), ValueGeneratorFromJSON(json.positionAmount), ValueGeneratorFromJSON(json.rotationAmount));",
                    "    }",
                    "    clone() {",
                    "        return new Noise(this.frequency.clone(), this.power.clone(), this.positionAmount.clone(), this.rotationAmount.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "class TextureSequencer {",
                    "    constructor(scaleX = 0, scaleY = 0, position = new THREE.Vector3()) {",
                    "        this.scaleX = scaleX;",
                    "        this.scaleY = scaleY;",
                    "        this.position = position;",
                    "        this.locations = [];",
                    "    }",
                    "    transform(position, index) {",
                    "        position.x = this.locations[index % this.locations.length].x * this.scaleX + this.position.x;",
                    "        position.y = this.locations[index % this.locations.length].y * this.scaleY + this.position.y;",
                    "        position.z = this.position.z;",
                    "    }",
                    "    static fromJSON(json) {",
                    "        const textureSequencer = new TextureSequencer(json.scaleX, json.scaleY, new THREE.Vector3(json.position[0], json.position[1], json.position[2]));",
                    "        textureSequencer.locations = json.locations.map((loc) => new THREE.Vector2(loc.x, loc.y));",
                    "        return textureSequencer;",
                    "    }",
                    "    clone() {",
                    "        const textureSequencer = new TextureSequencer(this.scaleX, this.scaleY, this.position.clone());",
                    "        textureSequencer.locations = this.locations.map(loc => loc.clone());",
                    "        return textureSequencer;",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            scaleX: this.scaleX,",
                    "            scaleY: this.scaleY,",
                    "            position: this.position,",
                    "            locations: this.locations.map(loc => ({",
                    "                x: loc.x,",
                    "                y: loc.y,",
                    "            }))",
                    "        };",
                    "    }",
                    "    fromImage(img, threshold) {",
                    "        const canvas = document.createElement(\"canvas\");",
                    "        canvas.width = img.width;",
                    "        canvas.height = img.height;",
                    "        const ctx = canvas.getContext(\"2d\");",
                    "        if (!ctx) {",
                    "            return;",
                    "        }",
                    "        ctx.drawImage(img, 0, 0);",
                    "        const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace: \"srgb\" });",
                    "        canvas.remove();",
                    "        this.locations.length = 0;",
                    "        for (let i = 0; i < data.height; i++) {",
                    "            for (let j = 0; j < data.width; j++) {",
                    "                if (data.data[(i * data.width + j) * 4 + 3] > threshold) {",
                    "                    this.locations.push(new THREE.Vector2(j, data.height - i));",
                    "                }",
                    "            }",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "function SequencerFromJSON(json) {",
                    "    switch (json.type) {",
                    "        case 'TextureSequencer':",
                    "            return TextureSequencer.fromJSON(json);",
                    "        default:",
                    "            return new TextureSequencer();",
                    "    }",
                    "}",
                    "",
                    "class ApplySequences {",
                    "    constructor(delayBetweenParticles) {",
                    "        this.type = 'ApplySequences';",
                    "        this.sequencers = [];",
                    "        this.time = 0;",
                    "        this.index = 0;",
                    "        this.pCount = 0;",
                    "        this.tempV = new THREE.Vector3();",
                    "        this.delay = delayBetweenParticles;",
                    "    }",
                    "    initialize(particle) {",
                    "        particle.id = this.pCount;",
                    "        particle.dst = new THREE.Vector3();",
                    "        particle.begin = new THREE.Vector3();",
                    "        particle.inMotion = false;",
                    "        this.pCount++;",
                    "    }",
                    "    reset() {",
                    "        this.time = 0;",
                    "        this.index = 0;",
                    "        this.pCount = 0;",
                    "    }",
                    "    update(particle, delta) {",
                    "        const sequencer = this.sequencers[this.index];",
                    "        const delay = particle.id * this.delay;",
                    "        if (this.time >= sequencer[0].a + delay && this.time <= sequencer[0].b + delay) {",
                    "            if (!particle.inMotion) {",
                    "                particle.inMotion = true;",
                    "                particle.begin.copy(particle.position);",
                    "                sequencer[1].transform(particle.dst, particle.id);",
                    "            }",
                    "            particle.position.lerpVectors(particle.begin, particle.dst, ApplySequences.BEZIER.genValue((this.time - sequencer[0].a - delay) / (sequencer[0].b - sequencer[0].a)));",
                    "        }",
                    "        else if (this.time > sequencer[0].b + delay) {",
                    "            particle.inMotion = false;",
                    "        }",
                    "    }",
                    "    frameUpdate(delta) {",
                    "        while (this.index + 1 < this.sequencers.length && this.time >= this.sequencers[this.index + 1][0].a) {",
                    "            this.index++;",
                    "        }",
                    "        this.time += delta;",
                    "    }",
                    "    appendSequencer(range, sequencer) {",
                    "        this.sequencers.push([range, sequencer]);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            delay: this.delay,",
                    "            sequencers: this.sequencers.map(([range, sequencer]) => ({",
                    "                range: range.toJSON(),",
                    "                sequencer: sequencer.toJSON(),",
                    "            })),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        const seq = new ApplySequences(json.delay);",
                    "        json.sequencers.forEach((sequencerJson) => {",
                    "            seq.sequencers.push([ValueGeneratorFromJSON(sequencerJson.range), SequencerFromJSON(sequencerJson.sequencer)]);",
                    "        });",
                    "        return seq;",
                    "    }",
                    "    clone() {",
                    "        const applySequences = new ApplySequences(this.delay);",
                    "        applySequences.sequencers = this.sequencers.map(seq => [seq[0].clone(), seq[1].clone()]);",
                    "        return applySequences;",
                    "    }",
                    "}",
                    "ApplySequences.BEZIER = new Bezier(0, 0, 1, 1);",
                    "",
                    "let physicsResolver;",
                    "function setPhysicsResolver(resolver) {",
                    "    physicsResolver = resolver;",
                    "}",
                    "function getPhysicsResolver() {",
                    "    return physicsResolver;",
                    "}",
                    "class ApplyCollision {",
                    "    constructor(resolver, bounce) {",
                    "        this.resolver = resolver;",
                    "        this.bounce = bounce;",
                    "        this.type = 'ApplyCollision';",
                    "        this.tempV = new THREE.Vector3();",
                    "    }",
                    "    initialize(particle) {",
                    "    }",
                    "    update(particle, delta) {",
                    "        if (this.resolver.resolve(particle.position, this.tempV)) {",
                    "            particle.velocity.reflect(this.tempV).multiplyScalar(this.bounce);",
                    "        }",
                    "    }",
                    "    frameUpdate(delta) {",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            bounce: this.bounce,",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ApplyCollision(getPhysicsResolver(), json.bounce);",
                    "    }",
                    "    clone() {",
                    "        return new ApplyCollision(this.resolver, this.bounce);",
                    "    }",
                    "    reset() {",
                    "    }",
                    "}",
                    "",
                    "class ColorBySpeed {",
                    "    constructor(color, speedRange) {",
                    "        this.color = color;",
                    "        this.speedRange = speedRange;",
                    "        this.type = 'ColorBySpeed';",
                    "    }",
                    "    initialize(particle) {",
                    "        if (this.color.type === 'memorizedFunction') {",
                    "            particle.colorOverLifeMemory = {};",
                    "            this.color.startGen(particle.colorOverLifeMemory);",
                    "        }",
                    "    }",
                    "    update(particle, delta) {",
                    "        const t = (particle.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);",
                    "        if (this.color.type === 'memorizedFunction') {",
                    "            this.color.genColor(particle.color, t, particle.colorOverLifeMemory);",
                    "        }",
                    "        else {",
                    "            this.color.genColor(particle.color, t);",
                    "        }",
                    "        particle.color.x *= particle.startColor.x;",
                    "        particle.color.y *= particle.startColor.y;",
                    "        particle.color.z *= particle.startColor.z;",
                    "        particle.color.w *= particle.startColor.w;",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            color: this.color.toJSON(),",
                    "            speedRange: this.speedRange.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ColorBySpeed(ColorGeneratorFromJSON(json.color), IntervalValue.fromJSON(json.speedRange));",
                    "    }",
                    "    clone() {",
                    "        return new ColorBySpeed(this.color.clone(), this.speedRange.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "class SizeBySpeed {",
                    "    initialize(particle) { }",
                    "    constructor(size, speedRange) {",
                    "        this.size = size;",
                    "        this.speedRange = speedRange;",
                    "        this.type = 'SizeBySpeed';",
                    "    }",
                    "    update(particle) {",
                    "        const t = (particle.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);",
                    "        particle.size = particle.startSize * this.size.genValue(t);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            size: this.size.toJSON(),",
                    "            speedRange: this.speedRange.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new SizeBySpeed(ValueGeneratorFromJSON(json.size), IntervalValue.fromJSON(json.speedRange));",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    clone() {",
                    "        return new SizeBySpeed(this.size.clone(), this.speedRange.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "class RotationBySpeed {",
                    "    constructor(angularVelocity, speedRange) {",
                    "        this.angularVelocity = angularVelocity;",
                    "        this.speedRange = speedRange;",
                    "        this.type = 'RotationBySpeed';",
                    "        this.tempQuat = new THREE.Quaternion();",
                    "    }",
                    "    initialize(particle) { }",
                    "    update(particle, delta) {",
                    "        const t = (particle.startSpeed - this.speedRange.a) / (this.speedRange.b - this.speedRange.a);",
                    "        particle.rotation += delta * this.angularVelocity.genValue(t);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            angularVelocity: this.angularVelocity.toJSON(),",
                    "            speedRange: this.speedRange.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new RotationBySpeed(ValueGeneratorFromJSON(json.angularVelocity), IntervalValue.fromJSON(json.speedRange));",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    clone() {",
                    "        return new RotationBySpeed(this.angularVelocity.clone(), this.speedRange.clone());",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "class LimitSpeedOverLife {",
                    "    initialize(particle) { }",
                    "    constructor(speed, dampen) {",
                    "        this.speed = speed;",
                    "        this.dampen = dampen;",
                    "        this.type = 'LimitSpeedOverLife';",
                    "    }",
                    "    update(particle, delta) {",
                    "        let speed = particle.velocity.length();",
                    "        let limit = this.speed.genValue(particle.age / particle.life);",
                    "        if (speed > limit) {",
                    "            const percent = (speed - limit) / speed;",
                    "            particle.velocity.multiplyScalar(1 - percent * this.dampen * delta * 20);",
                    "        }",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: this.type,",
                    "            speed: this.speed.toJSON(),",
                    "            dampen: this.dampen,",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new LimitSpeedOverLife(ValueGeneratorFromJSON(json.speed), json.dampen);",
                    "    }",
                    "    frameUpdate(delta) { }",
                    "    clone() {",
                    "        return new LimitSpeedOverLife(this.speed.clone(), this.dampen);",
                    "    }",
                    "    reset() { }",
                    "}",
                    "",
                    "const BehaviorTypes = {",
                    "    ApplyForce: {",
                    "        type: 'ApplyForce',",
                    "        constructor: ApplyForce,",
                    "        params: [",
                    "            ['direction', 'vec3'],",
                    "            ['magnitude', 'value'],",
                    "        ],",
                    "        loadJSON: ApplyForce.fromJSON,",
                    "    },",
                    "    Noise: {",
                    "        type: 'Noise',",
                    "        constructor: Noise,",
                    "        params: [",
                    "            ['frequency', 'value'],",
                    "            ['power', 'value'],",
                    "            ['positionAmount', 'value'],",
                    "            ['rotationAmount', 'value'],",
                    "        ],",
                    "        loadJSON: Noise.fromJSON,",
                    "    },",
                    "    TurbulenceField: {",
                    "        type: 'TurbulenceField',",
                    "        constructor: TurbulenceField,",
                    "        params: [",
                    "            ['scale', 'vec3'],",
                    "            ['octaves', 'number'],",
                    "            ['velocityMultiplier', 'vec3'],",
                    "            ['timeScale', 'vec3'],",
                    "        ],",
                    "        loadJSON: TurbulenceField.fromJSON,",
                    "    },",
                    "    GravityForce: {",
                    "        type: 'GravityForce',",
                    "        constructor: GravityForce,",
                    "        params: [",
                    "            ['center', 'vec3'],",
                    "            ['magnitude', 'number'],",
                    "        ],",
                    "        loadJSON: GravityForce.fromJSON,",
                    "    },",
                    "    ColorOverLife: {",
                    "        type: 'ColorOverLife',",
                    "        constructor: ColorOverLife,",
                    "        params: [['color', 'colorFunc']],",
                    "        loadJSON: ColorOverLife.fromJSON,",
                    "    },",
                    "    RotationOverLife: {",
                    "        type: 'RotationOverLife',",
                    "        constructor: RotationOverLife,",
                    "        params: [['angularVelocity', 'valueFunc']],",
                    "        loadJSON: RotationOverLife.fromJSON,",
                    "    },",
                    "    Rotation3DOverLife: {",
                    "        type: 'Rotation3DOverLife',",
                    "        constructor: Rotation3DOverLife,",
                    "        params: [['angularVelocity', 'rotationFunc']],",
                    "        loadJSON: Rotation3DOverLife.fromJSON,",
                    "    },",
                    "    SizeOverLife: {",
                    "        type: 'SizeOverLife',",
                    "        constructor: SizeOverLife,",
                    "        params: [['size', 'valueFunc']],",
                    "        loadJSON: SizeOverLife.fromJSON,",
                    "    },",
                    "    ColorBySpeed: {",
                    "        type: 'ColorBySpeed',",
                    "        constructor: ColorBySpeed,",
                    "        params: [",
                    "            ['color', 'colorFunc'],",
                    "            ['speedRange', 'range'],",
                    "        ],",
                    "        loadJSON: ColorBySpeed.fromJSON,",
                    "    },",
                    "    RotationBySpeed: {",
                    "        type: 'RotationBySpeed',",
                    "        constructor: RotationBySpeed,",
                    "        params: [",
                    "            ['angularVelocity', 'valueFunc'],",
                    "            ['speedRange', 'range'],",
                    "        ],",
                    "        loadJSON: RotationBySpeed.fromJSON,",
                    "    },",
                    "    SizeBySpeed: {",
                    "        type: 'SizeBySpeed',",
                    "        constructor: SizeBySpeed,",
                    "        params: [",
                    "            ['size', 'valueFunc'],",
                    "            ['speedRange', 'range'],",
                    "        ],",
                    "        loadJSON: SizeBySpeed.fromJSON,",
                    "    },",
                    "    SpeedOverLife: {",
                    "        type: 'SpeedOverLife',",
                    "        constructor: SpeedOverLife,",
                    "        params: [['speed', 'valueFunc']],",
                    "        loadJSON: SpeedOverLife.fromJSON,",
                    "    },",
                    "    FrameOverLife: {",
                    "        type: 'FrameOverLife',",
                    "        constructor: FrameOverLife,",
                    "        params: [['frame', 'valueFunc']],",
                    "        loadJSON: FrameOverLife.fromJSON,",
                    "    },",
                    "    ForceOverLife: {",
                    "        type: 'ForceOverLife',",
                    "        constructor: ForceOverLife,",
                    "        params: [",
                    "            ['x', 'valueFunc'],",
                    "            ['y', 'valueFunc'],",
                    "            ['z', 'valueFunc'],",
                    "        ],",
                    "        loadJSON: ForceOverLife.fromJSON,",
                    "    },",
                    "    OrbitOverLife: {",
                    "        type: 'OrbitOverLife',",
                    "        constructor: OrbitOverLife,",
                    "        params: [",
                    "            ['orbitSpeed', 'valueFunc'],",
                    "            ['axis', 'vec3'],",
                    "        ],",
                    "        loadJSON: OrbitOverLife.fromJSON,",
                    "    },",
                    "    WidthOverLength: {",
                    "        type: 'WidthOverLength',",
                    "        constructor: WidthOverLength,",
                    "        params: [['width', 'valueFunc']],",
                    "        loadJSON: WidthOverLength.fromJSON,",
                    "    },",
                    "    ChangeEmitDirection: {",
                    "        type: 'ChangeEmitDirection',",
                    "        constructor: ChangeEmitDirection,",
                    "        params: [['angle', 'value']],",
                    "        loadJSON: ChangeEmitDirection.fromJSON,",
                    "    },",
                    "    EmitSubParticleSystem: {",
                    "        type: 'EmitSubParticleSystem',",
                    "        constructor: EmitSubParticleSystem,",
                    "        params: [",
                    "            ['particleSystem', 'self'],",
                    "            ['useVelocityAsBasis', 'boolean'],",
                    "            ['subParticleSystem', 'particleSystem'],",
                    "            ['mode', 'number'],",
                    "            ['emitProbability', 'number'],",
                    "        ],",
                    "        loadJSON: EmitSubParticleSystem.fromJSON,",
                    "    },",
                    "    LimitSpeedOverLife: {",
                    "        type: 'LimitSpeedOverLife',",
                    "        constructor: LimitSpeedOverLife,",
                    "        params: [",
                    "            ['speed', 'valueFunc'],",
                    "            ['dampen', 'number'],",
                    "        ],",
                    "        loadJSON: LimitSpeedOverLife.fromJSON,",
                    "    },",
                    "};",
                    "function BehaviorFromJSON(json, particleSystem) {",
                    "    return BehaviorTypes[json.type].loadJSON(json, particleSystem);",
                    "}",
                    "",
                    "gdjs.__particleEmmiter3DExtension.EmitterMode = void 0;",
                    "(function (EmitterMode) {",
                    "    EmitterMode[EmitterMode[\"Random\"] = 0] = \"Random\";",
                    "    EmitterMode[EmitterMode[\"Loop\"] = 1] = \"Loop\";",
                    "    EmitterMode[EmitterMode[\"PingPong\"] = 2] = \"PingPong\";",
                    "    EmitterMode[EmitterMode[\"Burst\"] = 3] = \"Burst\";",
                    "})(gdjs.__particleEmmiter3DExtension.EmitterMode || (gdjs.__particleEmmiter3DExtension.EmitterMode = {}));",
                    "function getValueFromEmitterMode(mode, currentValue, spread) {",
                    "    let u;",
                    "    if (gdjs.__particleEmmiter3DExtension.EmitterMode.Random === mode) {",
                    "        currentValue = Math.random();",
                    "    }",
                    "    if (spread > 0) {",
                    "        u = Math.floor(currentValue / spread) * spread;",
                    "    }",
                    "    else {",
                    "        u = currentValue;",
                    "    }",
                    "    switch (mode) {",
                    "        case gdjs.__particleEmmiter3DExtension.EmitterMode.Loop:",
                    "            u = u % 1;",
                    "            break;",
                    "        case gdjs.__particleEmmiter3DExtension.EmitterMode.PingPong:",
                    "            u = Math.abs((u % 2) - 1);",
                    "            break;",
                    "    }",
                    "    return u;",
                    "}",
                    "",
                    "class ConeEmitter {",
                    "    constructor(parameters = {}) {",
                    "        var _a, _b, _c, _d, _e, _f, _g;",
                    "        this.type = 'cone';",
                    "        this.currentValue = 0;",
                    "        this.radius = (_a = parameters.radius) !== null && _a !== void 0 ? _a : 10;",
                    "        this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2.0 * Math.PI;",
                    "        this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;",
                    "        this.angle = (_d = parameters.angle) !== null && _d !== void 0 ? _d : Math.PI / 6;",
                    "        this.mode = (_e = parameters.mode) !== null && _e !== void 0 ? _e : gdjs.__particleEmmiter3DExtension.EmitterMode.Random;",
                    "        this.spread = (_f = parameters.spread) !== null && _f !== void 0 ? _f : 0;",
                    "        this.speed = (_g = parameters.speed) !== null && _g !== void 0 ? _g : new ConstantValue(1);",
                    "    }",
                    "    update(system, delta) {",
                    "        if (gdjs.__particleEmmiter3DExtension.EmitterMode.Random != this.mode) {",
                    "            this.currentValue += this.speed.genValue(system.emissionState.time / system.duration) * delta;",
                    "        }",
                    "    }",
                    "    initialize(p) {",
                    "        const u = getValueFromEmitterMode(this.mode, this.currentValue, this.spread);",
                    "        const rand = THREE.MathUtils.lerp(1 - this.thickness, 1, Math.random());",
                    "        const theta = u * this.arc;",
                    "        const r = Math.sqrt(rand);",
                    "        const sinTheta = Math.sin(theta);",
                    "        const cosTheta = Math.cos(theta);",
                    "        p.position.x = r * cosTheta;",
                    "        p.position.y = r * sinTheta;",
                    "        p.position.z = 0;",
                    "        const angle = this.angle * r;",
                    "        p.velocity.set(0, 0, Math.cos(angle)).addScaledVector(p.position, Math.sin(angle)).multiplyScalar(p.startSpeed);",
                    "        p.position.multiplyScalar(this.radius);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'cone',",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            angle: this.angle,",
                    "            mode: this.mode,",
                    "            spread: this.spread,",
                    "            speed: this.speed.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new ConeEmitter({",
                    "            radius: json.radius,",
                    "            arc: json.arc,",
                    "            thickness: json.thickness,",
                    "            angle: json.angle,",
                    "            mode: json.mode,",
                    "            speed: json.speed ? ValueGeneratorFromJSON(json.speed) : undefined,",
                    "            spread: json.spread,",
                    "        });",
                    "    }",
                    "    clone() {",
                    "        return new ConeEmitter({",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            angle: this.angle,",
                    "            mode: this.mode,",
                    "            speed: this.speed.clone(),",
                    "            spread: this.spread,",
                    "        });",
                    "    }",
                    "}",
                    "",
                    "class CircleEmitter {",
                    "    constructor(parameters = {}) {",
                    "        var _a, _b, _c, _d, _e, _f;",
                    "        this.type = 'circle';",
                    "        this.currentValue = 0;",
                    "        this.radius = (_a = parameters.radius) !== null && _a !== void 0 ? _a : 10;",
                    "        this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2.0 * Math.PI;",
                    "        this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;",
                    "        this.mode = (_d = parameters.mode) !== null && _d !== void 0 ? _d : gdjs.__particleEmmiter3DExtension.EmitterMode.Random;",
                    "        this.spread = (_e = parameters.spread) !== null && _e !== void 0 ? _e : 0;",
                    "        this.speed = (_f = parameters.speed) !== null && _f !== void 0 ? _f : new ConstantValue(1);",
                    "    }",
                    "    update(system, delta) {",
                    "        this.currentValue += this.speed.genValue(system.emissionState.time / system.duration) * delta;",
                    "    }",
                    "    initialize(p) {",
                    "        const u = getValueFromEmitterMode(this.mode, this.currentValue, this.spread);",
                    "        const r = THREE.MathUtils.lerp(1 - this.thickness, 1, Math.random());",
                    "        const theta = u * this.arc;",
                    "        p.position.x = Math.cos(theta);",
                    "        p.position.y = Math.sin(theta);",
                    "        p.position.z = 0;",
                    "        p.velocity.copy(p.position).multiplyScalar(p.startSpeed);",
                    "        p.position.multiplyScalar(this.radius * r);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'circle',",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            mode: this.mode,",
                    "            spread: this.spread,",
                    "            speed: this.speed.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new CircleEmitter({",
                    "            radius: json.radius,",
                    "            arc: json.arc,",
                    "            thickness: json.thickness,",
                    "            mode: json.mode,",
                    "            speed: json.speed ? ValueGeneratorFromJSON(json.speed) : undefined,",
                    "            spread: json.spread,",
                    "        });",
                    "    }",
                    "    clone() {",
                    "        return new CircleEmitter({",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            mode: this.mode,",
                    "            speed: this.speed.clone(),",
                    "            spread: this.spread,",
                    "        });",
                    "    }",
                    "}",
                    "",
                    "class DonutEmitter {",
                    "    constructor(parameters = {}) {",
                    "        var _a, _b, _c, _d, _e, _f, _g;",
                    "        this.type = 'donut';",
                    "        this.currentValue = 0;",
                    "        this.radius = (_a = parameters.radius) !== null && _a !== void 0 ? _a : 10;",
                    "        this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2.0 * Math.PI;",
                    "        this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;",
                    "        this.donutRadius = (_d = parameters.donutRadius) !== null && _d !== void 0 ? _d : this.radius * 0.2;",
                    "        this.mode = (_e = parameters.mode) !== null && _e !== void 0 ? _e : gdjs.__particleEmmiter3DExtension.EmitterMode.Random;",
                    "        this.spread = (_f = parameters.spread) !== null && _f !== void 0 ? _f : 0;",
                    "        this.speed = (_g = parameters.speed) !== null && _g !== void 0 ? _g : new ConstantValue(1);",
                    "    }",
                    "    update(system, delta) {",
                    "        if (gdjs.__particleEmmiter3DExtension.EmitterMode.Random != this.mode) {",
                    "            this.currentValue += this.speed.genValue(system.emissionState.time / system.duration) * delta;",
                    "        }",
                    "    }",
                    "    initialize(p) {",
                    "        const u = getValueFromEmitterMode(this.mode, this.currentValue, this.spread);",
                    "        const v = Math.random();",
                    "        const rand = THREE.MathUtils.lerp(1 - this.thickness, 1, Math.random());",
                    "        const theta = u * this.arc;",
                    "        const phi = v * Math.PI * 2;",
                    "        const sinTheta = Math.sin(theta);",
                    "        const cosTheta = Math.cos(theta);",
                    "        p.position.x = this.radius * cosTheta;",
                    "        p.position.y = this.radius * sinTheta;",
                    "        p.position.z = 0;",
                    "        p.velocity.z = this.donutRadius * rand * Math.sin(phi);",
                    "        p.velocity.x = this.donutRadius * rand * Math.cos(phi) * cosTheta;",
                    "        p.velocity.y = this.donutRadius * rand * Math.cos(phi) * sinTheta;",
                    "        p.position.add(p.velocity);",
                    "        p.velocity.normalize().multiplyScalar(p.startSpeed);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'donut',",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            donutRadius: this.donutRadius,",
                    "            mode: this.mode,",
                    "            spread: this.spread,",
                    "            speed: this.speed.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new DonutEmitter({",
                    "            radius: json.radius,",
                    "            arc: json.arc,",
                    "            thickness: json.thickness,",
                    "            donutRadius: json.donutRadius,",
                    "            mode: json.mode,",
                    "            speed: json.speed ? ValueGeneratorFromJSON(json.speed) : undefined,",
                    "            spread: json.spread,",
                    "        });",
                    "    }",
                    "    clone() {",
                    "        return new DonutEmitter({",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            donutRadius: this.donutRadius,",
                    "            mode: this.mode,",
                    "            speed: this.speed.clone(),",
                    "            spread: this.spread,",
                    "        });",
                    "    }",
                    "}",
                    "",
                    "class PointEmitter {",
                    "    constructor() {",
                    "        this.type = 'point';",
                    "    }",
                    "    update(system, delta) { }",
                    "    initialize(p) {",
                    "        const u = Math.random();",
                    "        const v = Math.random();",
                    "        const theta = u * Math.PI * 2;",
                    "        const phi = Math.acos(2.0 * v - 1.0);",
                    "        const r = Math.cbrt(Math.random());",
                    "        const sinTheta = Math.sin(theta);",
                    "        const cosTheta = Math.cos(theta);",
                    "        const sinPhi = Math.sin(phi);",
                    "        const cosPhi = Math.cos(phi);",
                    "        p.velocity.x = r * sinPhi * cosTheta;",
                    "        p.velocity.y = r * sinPhi * sinTheta;",
                    "        p.velocity.z = r * cosPhi;",
                    "        p.velocity.multiplyScalar(p.startSpeed);",
                    "        p.position.setScalar(0);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'point',",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new PointEmitter();",
                    "    }",
                    "    clone() {",
                    "        return new PointEmitter();",
                    "    }",
                    "}",
                    "",
                    "class SphereEmitter {",
                    "    constructor(parameters = {}) {",
                    "        var _a, _b, _c, _d, _e, _f;",
                    "        this.type = 'sphere';",
                    "        this.currentValue = 0;",
                    "        this.radius = (_a = parameters.radius) !== null && _a !== void 0 ? _a : 10;",
                    "        this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2.0 * Math.PI;",
                    "        this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;",
                    "        this.mode = (_d = parameters.mode) !== null && _d !== void 0 ? _d : gdjs.__particleEmmiter3DExtension.EmitterMode.Random;",
                    "        this.spread = (_e = parameters.spread) !== null && _e !== void 0 ? _e : 0;",
                    "        this.speed = (_f = parameters.speed) !== null && _f !== void 0 ? _f : new ConstantValue(1);",
                    "    }",
                    "    update(system, delta) {",
                    "        if (gdjs.__particleEmmiter3DExtension.EmitterMode.Random != this.mode) {",
                    "            this.currentValue += this.speed.genValue(system.emissionState.time / system.duration) * delta;",
                    "        }",
                    "    }",
                    "    initialize(p) {",
                    "        const u = getValueFromEmitterMode(this.mode, this.currentValue, this.spread);",
                    "        const v = Math.random();",
                    "        const rand = THREE.MathUtils.lerp(1 - this.thickness, 1, Math.random());",
                    "        const theta = u * this.arc;",
                    "        const phi = Math.acos(2.0 * v - 1.0);",
                    "        const sinTheta = Math.sin(theta);",
                    "        const cosTheta = Math.cos(theta);",
                    "        const sinPhi = Math.sin(phi);",
                    "        const cosPhi = Math.cos(phi);",
                    "        p.position.x = sinPhi * cosTheta;",
                    "        p.position.y = sinPhi * sinTheta;",
                    "        p.position.z = cosPhi;",
                    "        p.velocity.copy(p.position).multiplyScalar(p.startSpeed);",
                    "        p.position.multiplyScalar(this.radius * rand);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'sphere',",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            mode: this.mode,",
                    "            spread: this.spread,",
                    "            speed: this.speed.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new SphereEmitter({",
                    "            radius: json.radius,",
                    "            arc: json.arc,",
                    "            thickness: json.thickness,",
                    "            mode: json.mode,",
                    "            speed: json.speed ? ValueGeneratorFromJSON(json.speed) : undefined,",
                    "            spread: json.spread,",
                    "        });",
                    "    }",
                    "    clone() {",
                    "        return new SphereEmitter({",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            mode: this.mode,",
                    "            speed: this.speed.clone(),",
                    "            spread: this.spread,",
                    "        });",
                    "    }",
                    "}",
                    "",
                    "class HemisphereEmitter {",
                    "    constructor(parameters = {}) {",
                    "        var _a, _b, _c, _d, _e, _f;",
                    "        this.type = 'sphere';",
                    "        this.currentValue = 0;",
                    "        this.radius = (_a = parameters.radius) !== null && _a !== void 0 ? _a : 10;",
                    "        this.arc = (_b = parameters.arc) !== null && _b !== void 0 ? _b : 2.0 * Math.PI;",
                    "        this.thickness = (_c = parameters.thickness) !== null && _c !== void 0 ? _c : 1;",
                    "        this.mode = (_d = parameters.mode) !== null && _d !== void 0 ? _d : gdjs.__particleEmmiter3DExtension.EmitterMode.Random;",
                    "        this.spread = (_e = parameters.spread) !== null && _e !== void 0 ? _e : 0;",
                    "        this.speed = (_f = parameters.speed) !== null && _f !== void 0 ? _f : new ConstantValue(1);",
                    "    }",
                    "    update(system, delta) {",
                    "        if (gdjs.__particleEmmiter3DExtension.EmitterMode.Random != this.mode) {",
                    "            this.currentValue += this.speed.genValue(system.emissionState.time / system.duration) * delta;",
                    "        }",
                    "    }",
                    "    initialize(p) {",
                    "        const u = getValueFromEmitterMode(this.mode, this.currentValue, this.spread);",
                    "        const v = Math.random();",
                    "        const rand = THREE.MathUtils.lerp(1 - this.thickness, 1, Math.random());",
                    "        const theta = u * this.arc;",
                    "        const phi = Math.acos(v);",
                    "        const sinTheta = Math.sin(theta);",
                    "        const cosTheta = Math.cos(theta);",
                    "        const sinPhi = Math.sin(phi);",
                    "        const cosPhi = Math.cos(phi);",
                    "        p.position.x = sinPhi * cosTheta;",
                    "        p.position.y = sinPhi * sinTheta;",
                    "        p.position.z = cosPhi;",
                    "        p.velocity.copy(p.position).multiplyScalar(p.startSpeed);",
                    "        p.position.multiplyScalar(this.radius * rand);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'hemisphere',",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            mode: this.mode,",
                    "            spread: this.spread,",
                    "            speed: this.speed.toJSON(),",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new HemisphereEmitter({",
                    "            radius: json.radius,",
                    "            arc: json.arc,",
                    "            thickness: json.thickness,",
                    "            mode: json.mode,",
                    "            speed: json.speed ? ValueGeneratorFromJSON(json.speed) : undefined,",
                    "            spread: json.spread,",
                    "        });",
                    "    }",
                    "    clone() {",
                    "        return new HemisphereEmitter({",
                    "            radius: this.radius,",
                    "            arc: this.arc,",
                    "            thickness: this.thickness,",
                    "            mode: this.mode,",
                    "            speed: this.speed.clone(),",
                    "            spread: this.spread,",
                    "        });",
                    "    }",
                    "}",
                    "",
                    "class GridEmitter {",
                    "    constructor(parameters = {}) {",
                    "        var _a, _b, _c, _d;",
                    "        this.type = 'grid';",
                    "        this.width = (_a = parameters.width) !== null && _a !== void 0 ? _a : 1;",
                    "        this.height = (_b = parameters.height) !== null && _b !== void 0 ? _b : 1;",
                    "        this.column = (_c = parameters.column) !== null && _c !== void 0 ? _c : 10;",
                    "        this.row = (_d = parameters.row) !== null && _d !== void 0 ? _d : 10;",
                    "    }",
                    "    initialize(p) {",
                    "        const r = Math.floor(Math.random() * this.row);",
                    "        const c = Math.floor(Math.random() * this.column);",
                    "        p.position.x = (c * this.width) / this.column - this.width / 2;",
                    "        p.position.y = (r * this.height) / this.row - this.height / 2;",
                    "        p.position.z = 0;",
                    "        p.velocity.set(0, 0, p.startSpeed);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'grid',",
                    "            width: this.width,",
                    "            height: this.height,",
                    "            column: this.column,",
                    "            row: this.row,",
                    "        };",
                    "    }",
                    "    static fromJSON(json) {",
                    "        return new GridEmitter(json);",
                    "    }",
                    "    clone() {",
                    "        return new GridEmitter({",
                    "            width: this.width,",
                    "            height: this.height,",
                    "            column: this.column,",
                    "            row: this.row,",
                    "        });",
                    "    }",
                    "    update(system, delta) { }",
                    "}",
                    "",
                    "class MeshSurfaceEmitter {",
                    "    get geometry() {",
                    "        return this._geometry;",
                    "    }",
                    "    set geometry(geometry) {",
                    "        this._geometry = geometry;",
                    "        if (geometry === undefined) {",
                    "            return;",
                    "        }",
                    "        if (typeof geometry === 'string') {",
                    "            return;",
                    "        }",
                    "        const tri = new THREE.Triangle();",
                    "        this._triangleIndexToArea.length = 0;",
                    "        let area = 0;",
                    "        if (!geometry.getIndex()) {",
                    "            return;",
                    "        }",
                    "        const array = geometry.getIndex().array;",
                    "        const triCount = array.length / 3;",
                    "        this._triangleIndexToArea.push(0);",
                    "        for (let i = 0; i < triCount; i++) {",
                    "            tri.setFromAttributeAndIndices(geometry.getAttribute('position'), array[i * 3], array[i * 3 + 1], array[i * 3 + 2]);",
                    "            area += tri.getArea();",
                    "            this._triangleIndexToArea.push(area);",
                    "        }",
                    "        geometry.userData.triangleIndexToArea = this._triangleIndexToArea;",
                    "    }",
                    "    constructor(geometry) {",
                    "        this.type = 'mesh_surface';",
                    "        this._triangleIndexToArea = [];",
                    "        this._tempA = new THREE.Vector3();",
                    "        this._tempB = new THREE.Vector3();",
                    "        this._tempC = new THREE.Vector3();",
                    "        if (!geometry) {",
                    "            return;",
                    "        }",
                    "        this.geometry = geometry;",
                    "    }",
                    "    initialize(p) {",
                    "        const geometry = this._geometry;",
                    "        if (!geometry || geometry.getIndex() === null) {",
                    "            p.position.set(0, 0, 0);",
                    "            p.velocity.set(0, 0, 1).multiplyScalar(p.startSpeed);",
                    "            return;",
                    "        }",
                    "        const triCount = this._triangleIndexToArea.length - 1;",
                    "        let left = 0, right = triCount;",
                    "        const target = Math.random() * this._triangleIndexToArea[triCount];",
                    "        while (left + 1 < right) {",
                    "            const mid = Math.floor((left + right) / 2);",
                    "            if (target < this._triangleIndexToArea[mid]) {",
                    "                right = mid;",
                    "            }",
                    "            else {",
                    "                left = mid;",
                    "            }",
                    "        }",
                    "        let u1 = Math.random();",
                    "        let u2 = Math.random();",
                    "        if (u1 + u2 > 1) {",
                    "            u1 = 1 - u1;",
                    "            u2 = 1 - u2;",
                    "        }",
                    "        const index1 = geometry.getIndex().array[left * 3];",
                    "        const index2 = geometry.getIndex().array[left * 3 + 1];",
                    "        const index3 = geometry.getIndex().array[left * 3 + 2];",
                    "        const positionBuffer = geometry.getAttribute('position');",
                    "        this._tempA.fromBufferAttribute(positionBuffer, index1);",
                    "        this._tempB.fromBufferAttribute(positionBuffer, index2);",
                    "        this._tempC.fromBufferAttribute(positionBuffer, index3);",
                    "        this._tempB.sub(this._tempA);",
                    "        this._tempC.sub(this._tempA);",
                    "        this._tempA.addScaledVector(this._tempB, u1).addScaledVector(this._tempC, u2);",
                    "        p.position.copy(this._tempA);",
                    "        this._tempA.copy(this._tempB).cross(this._tempC).normalize();",
                    "        p.velocity.copy(this._tempA).normalize().multiplyScalar(p.startSpeed);",
                    "    }",
                    "    toJSON() {",
                    "        return {",
                    "            type: 'mesh_surface',",
                    "            mesh: this._geometry ? this._geometry.uuid : '',",
                    "        };",
                    "    }",
                    "    static fromJSON(json, meta) {",
                    "        return new MeshSurfaceEmitter(meta.geometries[json.geometry]);",
                    "    }",
                    "    clone() {",
                    "        return new MeshSurfaceEmitter(this._geometry);",
                    "    }",
                    "    update(system, delta) { }",
                    "}",
                    "",
                    "const EmitterShapes = {",
                    "    circle: {",
                    "        type: 'circle',",
                    "        params: [",
                    "            ['radius', 'number'],",
                    "            ['arc', 'radian'],",
                    "            ['thickness', 'number'],",
                    "            ['mode', 'emitterMode'],",
                    "            ['spread', 'number'],",
                    "            ['speed', 'valueFunc'],",
                    "        ],",
                    "        constructor: CircleEmitter,",
                    "        loadJSON: CircleEmitter.fromJSON,",
                    "    },",
                    "    cone: {",
                    "        type: 'cone',",
                    "        params: [",
                    "            ['radius', 'number'],",
                    "            ['arc', 'radian'],",
                    "            ['thickness', 'number'],",
                    "            ['angle', 'radian'],",
                    "            ['mode', 'emitterMode'],",
                    "            ['spread', 'number'],",
                    "            ['speed', 'valueFunc'],",
                    "        ],",
                    "        constructor: ConeEmitter,",
                    "        loadJSON: ConeEmitter.fromJSON,",
                    "    },",
                    "    donut: {",
                    "        type: 'donut',",
                    "        params: [",
                    "            ['radius', 'number'],",
                    "            ['arc', 'radian'],",
                    "            ['thickness', 'number'],",
                    "            ['donutRadius', 'number'],",
                    "            ['mode', 'emitterMode'],",
                    "            ['spread', 'number'],",
                    "            ['speed', 'valueFunc'],",
                    "        ],",
                    "        constructor: DonutEmitter,",
                    "        loadJSON: DonutEmitter.fromJSON,",
                    "    },",
                    "    point: { type: 'point', params: [], constructor: PointEmitter, loadJSON: PointEmitter.fromJSON },",
                    "    sphere: {",
                    "        type: 'sphere',",
                    "        params: [",
                    "            ['radius', 'number'],",
                    "            ['arc', 'radian'],",
                    "            ['thickness', 'number'],",
                    "            ['angle', 'radian'],",
                    "            ['mode', 'emitterMode'],",
                    "            ['spread', 'number'],",
                    "            ['speed', 'valueFunc'],",
                    "        ],",
                    "        constructor: SphereEmitter,",
                    "        loadJSON: SphereEmitter.fromJSON,",
                    "    },",
                    "    hemisphere: {",
                    "        type: 'hemisphere',",
                    "        params: [",
                    "            ['radius', 'number'],",
                    "            ['arc', 'radian'],",
                    "            ['thickness', 'number'],",
                    "            ['angle', 'radian'],",
                    "            ['mode', 'emitterMode'],",
                    "            ['spread', 'number'],",
                    "            ['speed', 'valueFunc'],",
                    "        ],",
                    "        constructor: HemisphereEmitter,",
                    "        loadJSON: HemisphereEmitter.fromJSON,",
                    "    },",
                    "    grid: {",
                    "        type: 'grid',",
                    "        params: [",
                    "            ['width', 'number'],",
                    "            ['height', 'number'],",
                    "            ['rows', 'number'],",
                    "            ['column', 'number'],",
                    "        ],",
                    "        constructor: GridEmitter,",
                    "        loadJSON: GridEmitter.fromJSON,",
                    "    },",
                    "    mesh_surface: {",
                    "        type: 'mesh_surface',",
                    "        params: [['geometry', 'geometry']],",
                    "        constructor: MeshSurfaceEmitter,",
                    "        loadJSON: MeshSurfaceEmitter.fromJSON,",
                    "    },",
                    "};",
                    "function EmitterFromJSON(json, meta) {",
                    "    return EmitterShapes[json.type].loadJSON(json, meta);",
                    "}",
                    "",
                    "gdjs.__particleEmmiter3DExtension.RenderMode = void 0;",
                    "(function (RenderMode) {",
                    "    RenderMode[RenderMode[\"BillBoard\"] = 0] = \"BillBoard\";",
                    "    RenderMode[RenderMode[\"StretchedBillBoard\"] = 1] = \"StretchedBillBoard\";",
                    "    RenderMode[RenderMode[\"Mesh\"] = 2] = \"Mesh\";",
                    "    RenderMode[RenderMode[\"Trail\"] = 3] = \"Trail\";",
                    "    RenderMode[RenderMode[\"HorizontalBillBoard\"] = 4] = \"HorizontalBillBoard\";",
                    "    RenderMode[RenderMode[\"VerticalBillBoard\"] = 5] = \"VerticalBillBoard\";",
                    "})(gdjs.__particleEmmiter3DExtension.RenderMode || (gdjs.__particleEmmiter3DExtension.RenderMode = {}));",
                    "class VFXBatch extends THREE.Mesh {",
                    "    constructor(settings) {",
                    "        super();",
                    "        this.type = 'VFXBatch';",
                    "        this.maxParticles = 1000;",
                    "        this.systems = new Set();",
                    "        const layers = new THREE.Layers();",
                    "        layers.mask = settings.layers.mask;",
                    "        const newMat = settings.material.clone();",
                    "        newMat.defines = {};",
                    "        Object.assign(newMat.defines, settings.material.defines);",
                    "        this.settings = {",
                    "            instancingGeometry: settings.instancingGeometry,",
                    "            renderMode: settings.renderMode,",
                    "            renderOrder: settings.renderOrder,",
                    "            material: newMat,",
                    "            uTileCount: settings.uTileCount,",
                    "            vTileCount: settings.vTileCount,",
                    "            layers: layers,",
                    "        };",
                    "        this.frustumCulled = false;",
                    "        this.renderOrder = this.settings.renderOrder;",
                    "    }",
                    "    addSystem(system) {",
                    "        this.systems.add(system);",
                    "    }",
                    "    removeSystem(system) {",
                    "        this.systems.delete(system);",
                    "    }",
                    "}",
                    "",
                    "const UP = new THREE.Vector3(0, 0, 1);",
                    "const tempQ$1 = new THREE.Quaternion();",
                    "const tempV$1 = new THREE.Vector3();",
                    "const tempV2$1 = new THREE.Vector3();",
                    "new THREE.Vector3();",
                    "const PREWARM_FPS$1 = 60;",
                    "const DEFAULT_GEOMETRY$1 = new THREE.PlaneGeometry(1, 1, 1, 1);",
                    "class ParticleSystem {",
                    "    set time(time) {",
                    "        this.emissionState.time = time;",
                    "    }",
                    "    get time() {",
                    "        return this.emissionState.time;",
                    "    }",
                    "    get layers() {",
                    "        return this.rendererSettings.layers;",
                    "    }",
                    "    get texture() {",
                    "        return this.rendererSettings.material.map;",
                    "    }",
                    "    set texture(texture) {",
                    "        this.rendererSettings.material.map = texture;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get material() {",
                    "        return this.rendererSettings.material;",
                    "    }",
                    "    set material(material) {",
                    "        this.rendererSettings.material = material;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get uTileCount() {",
                    "        return this.rendererSettings.uTileCount;",
                    "    }",
                    "    set uTileCount(u) {",
                    "        this.rendererSettings.uTileCount = u;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get vTileCount() {",
                    "        return this.rendererSettings.vTileCount;",
                    "    }",
                    "    set vTileCount(v) {",
                    "        this.rendererSettings.vTileCount = v;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get instancingGeometry() {",
                    "        return this.rendererSettings.instancingGeometry;",
                    "    }",
                    "    set instancingGeometry(geometry) {",
                    "        this.restart();",
                    "        this.particles.length = 0;",
                    "        this.rendererSettings.instancingGeometry = geometry;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get renderMode() {",
                    "        return this.rendererSettings.renderMode;",
                    "    }",
                    "    set renderMode(renderMode) {",
                    "        if ((this.rendererSettings.renderMode != gdjs.__particleEmmiter3DExtension.RenderMode.Trail && renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) ||",
                    "            (this.rendererSettings.renderMode == gdjs.__particleEmmiter3DExtension.RenderMode.Trail && renderMode !== gdjs.__particleEmmiter3DExtension.RenderMode.Trail)) {",
                    "            this.restart();",
                    "            this.particles.length = 0;",
                    "        }",
                    "        if (this.rendererSettings.renderMode !== renderMode) {",
                    "            switch (renderMode) {",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.Trail:",
                    "                    this.rendererEmitterSettings = {",
                    "                        startLength: new ConstantValue(30),",
                    "                        followLocalOrigin: false,",
                    "                    };",
                    "                    break;",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.Mesh:",
                    "                    this.rendererEmitterSettings = {",
                    "                        geometry: new THREE.PlaneGeometry(1, 1),",
                    "                    };",
                    "                    this.startRotation = new AxisAngleGenerator(new THREE.Vector3(0, 1, 0), new ConstantValue(0));",
                    "                    break;",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard:",
                    "                    this.rendererEmitterSettings = { speedFactor: 0, lengthFactor: 2 };",
                    "                    if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "                        this.startRotation = new ConstantValue(0);",
                    "                    }",
                    "                    break;",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard:",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard:",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard:",
                    "                    this.rendererEmitterSettings = {};",
                    "                    if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "                        this.startRotation = new ConstantValue(0);",
                    "                    }",
                    "                    break;",
                    "            }",
                    "        }",
                    "        this.rendererSettings.renderMode = renderMode;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get renderOrder() {",
                    "        return this.rendererSettings.renderOrder;",
                    "    }",
                    "    set renderOrder(renderOrder) {",
                    "        this.rendererSettings.renderOrder = renderOrder;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get blending() {",
                    "        return this.rendererSettings.material.blending;",
                    "    }",
                    "    set blending(blending) {",
                    "        this.rendererSettings.material.blending = blending;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    constructor(parameters) {",
                    "        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;",
                    "        this.temp = new THREE.Vector3();",
                    "        this.travelDistance = 0;",
                    "        this.normalMatrix = new THREE.Matrix3();",
                    "        this.firstTimeUpdate = true;",
                    "        this.autoDestroy = parameters.autoDestroy === undefined ? false : parameters.autoDestroy;",
                    "        this.duration = (_a = parameters.duration) !== null && _a !== void 0 ? _a : 1;",
                    "        this.looping = parameters.looping === undefined ? true : parameters.looping;",
                    "        this.prewarm = parameters.prewarm === undefined ? false : parameters.prewarm;",
                    "        this.startLife = (_b = parameters.startLife) !== null && _b !== void 0 ? _b : new ConstantValue(5);",
                    "        this.startSpeed = (_c = parameters.startSpeed) !== null && _c !== void 0 ? _c : new ConstantValue(0);",
                    "        this.startRotation = (_d = parameters.startRotation) !== null && _d !== void 0 ? _d : new ConstantValue(0);",
                    "        this.startSize = (_e = parameters.startSize) !== null && _e !== void 0 ? _e : new ConstantValue(1);",
                    "        this.startColor = (_f = parameters.startColor) !== null && _f !== void 0 ? _f : new ConstantColor(new THREE.Vector4(1, 1, 1, 1));",
                    "        this.emissionOverTime = (_g = parameters.emissionOverTime) !== null && _g !== void 0 ? _g : new ConstantValue(10);",
                    "        this.emissionOverDistance = (_h = parameters.emissionOverDistance) !== null && _h !== void 0 ? _h : new ConstantValue(0);",
                    "        this.emissionBursts = (_j = parameters.emissionBursts) !== null && _j !== void 0 ? _j : [];",
                    "        this.onlyUsedByOther = (_k = parameters.onlyUsedByOther) !== null && _k !== void 0 ? _k : false;",
                    "        this.emitterShape = (_l = parameters.shape) !== null && _l !== void 0 ? _l : new SphereEmitter();",
                    "        this.behaviors = (_m = parameters.behaviors) !== null && _m !== void 0 ? _m : new Array();",
                    "        this.worldSpace = (_o = parameters.worldSpace) !== null && _o !== void 0 ? _o : false;",
                    "        this.rendererEmitterSettings = (_p = parameters.rendererEmitterSettings) !== null && _p !== void 0 ? _p : {};",
                    "        if (parameters.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard) {",
                    "            const stretchedBillboardSettings = this.rendererEmitterSettings;",
                    "            if (parameters.speedFactor !== undefined) {",
                    "                stretchedBillboardSettings.speedFactor = parameters.speedFactor;",
                    "            }",
                    "            stretchedBillboardSettings.speedFactor = (_q = stretchedBillboardSettings.speedFactor) !== null && _q !== void 0 ? _q : 0;",
                    "            stretchedBillboardSettings.lengthFactor = (_r = stretchedBillboardSettings.lengthFactor) !== null && _r !== void 0 ? _r : 0;",
                    "        }",
                    "        this.rendererSettings = {",
                    "            instancingGeometry: (_s = parameters.instancingGeometry) !== null && _s !== void 0 ? _s : DEFAULT_GEOMETRY$1,",
                    "            renderMode: (_t = parameters.renderMode) !== null && _t !== void 0 ? _t : gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard,",
                    "            renderOrder: (_u = parameters.renderOrder) !== null && _u !== void 0 ? _u : 0,",
                    "            material: parameters.material,",
                    "            uTileCount: (_v = parameters.uTileCount) !== null && _v !== void 0 ? _v : 1,",
                    "            vTileCount: (_w = parameters.vTileCount) !== null && _w !== void 0 ? _w : 1,",
                    "            layers: (_x = parameters.layers) !== null && _x !== void 0 ? _x : new THREE.Layers(),",
                    "        };",
                    "        this.neededToUpdateRender = true;",
                    "        this.particles = new Array();",
                    "        this.startTileIndex = parameters.startTileIndex || new ConstantValue(0);",
                    "        this.emitter = new ParticleEmitter(this);",
                    "        this.paused = false;",
                    "        this.particleNum = 0;",
                    "        this.emissionState = {",
                    "            burstIndex: 0,",
                    "            burstWaveIndex: 0,",
                    "            time: 0,",
                    "            waitEmiting: 0,",
                    "            travelDistance: 0,",
                    "        };",
                    "        this.emitEnded = false;",
                    "        this.markForDestroy = false;",
                    "        this.prewarmed = false;",
                    "    }",
                    "    pause() {",
                    "        this.paused = true;",
                    "    }",
                    "    play() {",
                    "        this.paused = false;",
                    "    }",
                    "    spawn(count, emissionState, matrix) {",
                    "        tempQ$1.setFromRotationMatrix(matrix);",
                    "        const translation = tempV$1;",
                    "        const quaternion = tempQ$1;",
                    "        const scale = tempV2$1;",
                    "        matrix.decompose(translation, quaternion, scale);",
                    "        for (let i = 0; i < count; i++) {",
                    "            this.particleNum++;",
                    "            while (this.particles.length < this.particleNum) {",
                    "                if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "                    this.particles.push(new TrailParticle());",
                    "                }",
                    "                else {",
                    "                    this.particles.push(new SpriteParticle());",
                    "                }",
                    "            }",
                    "            const particle = this.particles[this.particleNum - 1];",
                    "            particle.speedModifier = 1;",
                    "            this.startColor.genColor(particle.startColor, this.emissionState.time, {});",
                    "            particle.color.copy(particle.startColor);",
                    "            particle.startSpeed = this.startSpeed.genValue(emissionState.time / this.duration);",
                    "            particle.life = this.startLife.genValue(emissionState.time / this.duration);",
                    "            particle.age = 0;",
                    "            particle.startSize = this.startSize.genValue(emissionState.time / this.duration);",
                    "            particle.uvTile = Math.floor(this.startTileIndex.genValue() + 0.001);",
                    "            particle.size = particle.startSize;",
                    "            if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh ||",
                    "                this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard ||",
                    "                this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard ||",
                    "                this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard ||",
                    "                this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard) {",
                    "                const sprite = particle;",
                    "                if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "                    if (!(sprite.rotation instanceof THREE.Quaternion)) {",
                    "                        sprite.rotation = new THREE.Quaternion();",
                    "                    }",
                    "                    if (this.startRotation.type === 'rotation') {",
                    "                        this.startRotation.genValue(sprite.rotation, emissionState.time / this.duration);",
                    "                    }",
                    "                    else {",
                    "                        sprite.rotation.setFromAxisAngle(UP, this.startRotation.genValue((emissionState.time / this.duration)));",
                    "                    }",
                    "                }",
                    "                else {",
                    "                    if (this.startRotation.type === 'rotation') {",
                    "                        sprite.rotation = 0;",
                    "                    }",
                    "                    else {",
                    "                        sprite.rotation = this.startRotation.genValue(emissionState.time / this.duration);",
                    "                    }",
                    "                }",
                    "            }",
                    "            else if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "                const trail = particle;",
                    "                trail.length = this.rendererEmitterSettings.startLength.genValue(emissionState.time / this.duration);",
                    "            }",
                    "            this.emitterShape.initialize(particle);",
                    "            if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail &&",
                    "                this.rendererEmitterSettings.followLocalOrigin) {",
                    "                const trail = particle;",
                    "                trail.localPosition = new THREE.Vector3().copy(trail.position);",
                    "            }",
                    "            if (this.worldSpace) {",
                    "                particle.position.applyMatrix4(matrix);",
                    "                particle.startSize =",
                    "                    (particle.startSize * (Math.abs(scale.x) + Math.abs(scale.y) + Math.abs(scale.z))) / 3;",
                    "                particle.size = particle.startSize;",
                    "                particle.velocity.multiply(scale).applyMatrix3(this.normalMatrix);",
                    "                if (particle.rotation && particle.rotation instanceof THREE.Quaternion) {",
                    "                    particle.rotation.multiplyQuaternions(tempQ$1, particle.rotation);",
                    "                }",
                    "            }",
                    "            else {",
                    "                if (this.onlyUsedByOther) {",
                    "                    particle.parentMatrix = matrix;",
                    "                }",
                    "            }",
                    "            for (let j = 0; j < this.behaviors.length; j++) {",
                    "                this.behaviors[j].initialize(particle);",
                    "            }",
                    "        }",
                    "    }",
                    "    endEmit() {",
                    "        this.emitEnded = true;",
                    "        if (this.autoDestroy) {",
                    "            this.markForDestroy = true;",
                    "        }",
                    "    }",
                    "    dispose() {",
                    "        if (this._renderer)",
                    "            this._renderer.deleteSystem(this);",
                    "        this.emitter.dispose();",
                    "        if (this.emitter.parent)",
                    "            this.emitter.parent.remove(this.emitter);",
                    "    }",
                    "    restart() {",
                    "        this.paused = false;",
                    "        this.particleNum = 0;",
                    "        this.emissionState.burstIndex = 0;",
                    "        this.emissionState.burstWaveIndex = 0;",
                    "        this.emissionState.time = 0;",
                    "        this.emissionState.waitEmiting = 0;",
                    "        this.behaviors.forEach((behavior) => {",
                    "            behavior.reset();",
                    "        });",
                    "        this.emitEnded = false;",
                    "        this.markForDestroy = false;",
                    "        this.prewarmed = false;",
                    "    }",
                    "    update(delta) {",
                    "        if (this.paused)",
                    "            return;",
                    "        let currentParent = this.emitter;",
                    "        while (currentParent.parent) {",
                    "            currentParent = currentParent.parent;",
                    "        }",
                    "        if (currentParent.type !== 'Scene') {",
                    "            this.dispose();",
                    "            return;",
                    "        }",
                    "        if (this.firstTimeUpdate) {",
                    "            this.firstTimeUpdate = false;",
                    "            this.emitter.updateWorldMatrix(true, false);",
                    "        }",
                    "        if (this.emitEnded && this.particleNum === 0) {",
                    "            if (this.markForDestroy && this.emitter.parent)",
                    "                this.dispose();",
                    "            return;",
                    "        }",
                    "        if (this.looping && this.prewarm && !this.prewarmed) {",
                    "            this.prewarmed = true;",
                    "            for (let i = 0; i < this.duration * PREWARM_FPS$1; i++) {",
                    "                this.update(1.0 / PREWARM_FPS$1);",
                    "            }",
                    "        }",
                    "        if (delta > 0.1) {",
                    "            delta = 0.1;",
                    "        }",
                    "        if (this.neededToUpdateRender) {",
                    "            if (this._renderer)",
                    "                this._renderer.updateSystem(this);",
                    "            this.neededToUpdateRender = false;",
                    "        }",
                    "        if (!this.onlyUsedByOther) {",
                    "            this.emit(delta, this.emissionState, this.emitter.matrixWorld);",
                    "        }",
                    "        this.emitterShape.update(this, delta);",
                    "        for (let j = 0; j < this.behaviors.length; j++) {",
                    "            for (let i = 0; i < this.particleNum; i++) {",
                    "                if (!this.particles[i].died) {",
                    "                    this.behaviors[j].update(this.particles[i], delta);",
                    "                }",
                    "            }",
                    "            this.behaviors[j].frameUpdate(delta);",
                    "        }",
                    "        for (let i = 0; i < this.particleNum; i++) {",
                    "            if (this.rendererEmitterSettings.followLocalOrigin &&",
                    "                this.particles[i].localPosition) {",
                    "                this.particles[i].position.copy(this.particles[i].localPosition);",
                    "                if (this.particles[i].parentMatrix) {",
                    "                    this.particles[i].position.applyMatrix4(this.particles[i].parentMatrix);",
                    "                }",
                    "                else {",
                    "                    this.particles[i].position.applyMatrix4(this.emitter.matrixWorld);",
                    "                }",
                    "            }",
                    "            else {",
                    "                this.particles[i].position.addScaledVector(this.particles[i].velocity, delta * this.particles[i].speedModifier);",
                    "            }",
                    "            this.particles[i].age += delta;",
                    "        }",
                    "        if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "            for (let i = 0; i < this.particleNum; i++) {",
                    "                const particle = this.particles[i];",
                    "                particle.update();",
                    "            }",
                    "        }",
                    "        for (let i = 0; i < this.particleNum; i++) {",
                    "            const particle = this.particles[i];",
                    "            if (particle.died && (!(particle instanceof TrailParticle) || particle.previous.length === 0)) {",
                    "                this.particles[i] = this.particles[this.particleNum - 1];",
                    "                this.particles[this.particleNum - 1] = particle;",
                    "                this.particleNum--;",
                    "                i--;",
                    "            }",
                    "        }",
                    "    }",
                    "    emit(delta, emissionState, emitterMatrix) {",
                    "        if (emissionState.time > this.duration) {",
                    "            if (this.looping) {",
                    "                emissionState.time -= this.duration;",
                    "                emissionState.burstIndex = 0;",
                    "                this.behaviors.forEach((behavior) => {",
                    "                    behavior.reset();",
                    "                });",
                    "            }",
                    "            else {",
                    "                if (!this.emitEnded && !this.onlyUsedByOther) {",
                    "                    this.endEmit();",
                    "                }",
                    "            }",
                    "        }",
                    "        this.normalMatrix.getNormalMatrix(emitterMatrix);",
                    "        const totalSpawn = Math.ceil(emissionState.waitEmiting);",
                    "        this.spawn(totalSpawn, emissionState, emitterMatrix);",
                    "        emissionState.waitEmiting -= totalSpawn;",
                    "        while (emissionState.burstIndex < this.emissionBursts.length &&",
                    "            this.emissionBursts[emissionState.burstIndex].time <= emissionState.time) {",
                    "            if (Math.random() < this.emissionBursts[emissionState.burstIndex].probability) {",
                    "                const count = this.emissionBursts[emissionState.burstIndex].count.genValue(this.time);",
                    "                this.spawn(count, emissionState, emitterMatrix);",
                    "            }",
                    "            emissionState.burstIndex++;",
                    "        }",
                    "        if (!this.emitEnded) {",
                    "            emissionState.waitEmiting += delta * this.emissionOverTime.genValue(emissionState.time / this.duration);",
                    "            if (emissionState.previousWorldPos != undefined) {",
                    "                this.temp.set(emitterMatrix.elements[12], emitterMatrix.elements[13], emitterMatrix.elements[14]);",
                    "                emissionState.travelDistance += emissionState.previousWorldPos.distanceTo(this.temp);",
                    "                const emitPerMeter = this.emissionOverDistance.genValue(emissionState.time / this.duration);",
                    "                if (emissionState.travelDistance * emitPerMeter > 0) {",
                    "                    const count = Math.floor(emissionState.travelDistance * emitPerMeter);",
                    "                    emissionState.travelDistance -= count / emitPerMeter;",
                    "                    emissionState.waitEmiting += count;",
                    "                }",
                    "            }",
                    "        }",
                    "        if (emissionState.previousWorldPos === undefined)",
                    "            emissionState.previousWorldPos = new THREE.Vector3();",
                    "        emissionState.previousWorldPos.set(emitterMatrix.elements[12], emitterMatrix.elements[13], emitterMatrix.elements[14]);",
                    "        emissionState.time += delta;",
                    "    }",
                    "    toJSON(meta, options = {}) {",
                    "        const isRootObject = meta === undefined || typeof meta === 'string';",
                    "        if (isRootObject) {",
                    "            meta = {",
                    "                geometries: {},",
                    "                materials: {},",
                    "                textures: {},",
                    "                images: {},",
                    "                shapes: {},",
                    "                skeletons: {},",
                    "                animations: {},",
                    "                nodes: {},",
                    "            };",
                    "        }",
                    "        meta.materials[this.rendererSettings.material.uuid] = this.rendererSettings.material.toJSON(meta);",
                    "        if (options.useUrlForImage) {",
                    "            if (this.texture.source !== undefined) {",
                    "                const image = this.texture.source;",
                    "                meta.images[image.uuid] = {",
                    "                    uuid: image.uuid,",
                    "                    url: this.texture.image.url,",
                    "                };",
                    "            }",
                    "        }",
                    "        let rendererSettingsJSON;",
                    "        if (this.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "            rendererSettingsJSON = {",
                    "                startLength: this.rendererEmitterSettings.startLength.toJSON(),",
                    "                followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin,",
                    "            };",
                    "        }",
                    "        else if (this.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "            rendererSettingsJSON = {};",
                    "        }",
                    "        else if (this.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard) {",
                    "            rendererSettingsJSON = {",
                    "                speedFactor: this.rendererEmitterSettings.speedFactor,",
                    "                lengthFactor: this.rendererEmitterSettings.lengthFactor,",
                    "            };",
                    "        }",
                    "        else {",
                    "            rendererSettingsJSON = {};",
                    "        }",
                    "        const geometry = this.rendererSettings.instancingGeometry;",
                    "        if (meta.geometries && !meta.geometries[geometry.uuid]) {",
                    "            meta.geometries[geometry.uuid] = geometry.toJSON();",
                    "        }",
                    "        return {",
                    "            version: '2.0',",
                    "            autoDestroy: this.autoDestroy,",
                    "            looping: this.looping,",
                    "            prewarm: this.prewarm,",
                    "            duration: this.duration,",
                    "            shape: this.emitterShape.toJSON(),",
                    "            startLife: this.startLife.toJSON(),",
                    "            startSpeed: this.startSpeed.toJSON(),",
                    "            startRotation: this.startRotation.toJSON(),",
                    "            startSize: this.startSize.toJSON(),",
                    "            startColor: this.startColor.toJSON(),",
                    "            emissionOverTime: this.emissionOverTime.toJSON(),",
                    "            emissionOverDistance: this.emissionOverDistance.toJSON(),",
                    "            emissionBursts: this.emissionBursts.map((burst) => ({",
                    "                time: burst.time,",
                    "                count: burst.count.toJSON(),",
                    "                probability: burst.probability,",
                    "                interval: burst.interval,",
                    "                cycle: burst.cycle,",
                    "            })),",
                    "            onlyUsedByOther: this.onlyUsedByOther,",
                    "            instancingGeometry: this.rendererSettings.instancingGeometry.uuid,",
                    "            renderOrder: this.renderOrder,",
                    "            renderMode: this.renderMode,",
                    "            rendererEmitterSettings: rendererSettingsJSON,",
                    "            material: this.rendererSettings.material.uuid,",
                    "            layers: this.layers.mask,",
                    "            startTileIndex: this.startTileIndex.toJSON(),",
                    "            uTileCount: this.uTileCount,",
                    "            vTileCount: this.vTileCount,",
                    "            behaviors: this.behaviors.map((behavior) => behavior.toJSON()),",
                    "            worldSpace: this.worldSpace,",
                    "        };",
                    "    }",
                    "    static fromJSON(json, meta, dependencies) {",
                    "        var _a, _b;",
                    "        const shape = EmitterFromJSON(json.shape, meta);",
                    "        let rendererEmitterSettings;",
                    "        if (json.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "            let trailSettings = json.rendererEmitterSettings;",
                    "            rendererEmitterSettings = {",
                    "                startLength: trailSettings.startLength != undefined",
                    "                    ? ValueGeneratorFromJSON(trailSettings.startLength)",
                    "                    : new ConstantValue(30),",
                    "                followLocalOrigin: trailSettings.followLocalOrigin,",
                    "            };",
                    "        }",
                    "        else if (json.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "            rendererEmitterSettings = {};",
                    "        }",
                    "        else if (json.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard) {",
                    "            rendererEmitterSettings = json.rendererEmitterSettings;",
                    "            if (json.speedFactor != undefined) {",
                    "                rendererEmitterSettings.speedFactor = json.speedFactor;",
                    "            }",
                    "        }",
                    "        else {",
                    "            rendererEmitterSettings = {};",
                    "        }",
                    "        const layers = new THREE.Layers();",
                    "        if (json.layers) {",
                    "            layers.mask = json.layers;",
                    "        }",
                    "        const ps = new ParticleSystem({",
                    "            autoDestroy: json.autoDestroy,",
                    "            looping: json.looping,",
                    "            prewarm: json.prewarm,",
                    "            duration: json.duration,",
                    "            shape: shape,",
                    "            startLife: ValueGeneratorFromJSON(json.startLife),",
                    "            startSpeed: ValueGeneratorFromJSON(json.startSpeed),",
                    "            startRotation: GeneratorFromJSON(json.startRotation),",
                    "            startSize: ValueGeneratorFromJSON(json.startSize),",
                    "            startColor: ColorGeneratorFromJSON(json.startColor),",
                    "            emissionOverTime: ValueGeneratorFromJSON(json.emissionOverTime),",
                    "            emissionOverDistance: ValueGeneratorFromJSON(json.emissionOverDistance),",
                    "            emissionBursts: (_a = json.emissionBursts) === null || _a === void 0 ? void 0 : _a.map((burst) => ({",
                    "                time: burst.time,",
                    "                count: typeof burst.count === 'number'",
                    "                    ? new ConstantValue(burst.count)",
                    "                    : ValueGeneratorFromJSON(burst.count),",
                    "                probability: burst.probability,",
                    "                interval: burst.interval,",
                    "                cycle: burst.cycle,",
                    "            })),",
                    "            onlyUsedByOther: json.onlyUsedByOther,",
                    "            instancingGeometry: meta.geometries[json.instancingGeometry],",
                    "            renderMode: json.renderMode,",
                    "            rendererEmitterSettings: rendererEmitterSettings,",
                    "            renderOrder: json.renderOrder,",
                    "            layers: layers,",
                    "            material: json.material",
                    "                ? meta.materials[json.material]",
                    "                : json.texture",
                    "                    ? new THREE.MeshBasicMaterial({",
                    "                        map: meta.textures[json.texture],",
                    "                        transparent: (_b = json.transparent) !== null && _b !== void 0 ? _b : true,",
                    "                        blending: json.blending,",
                    "                        side: THREE.DoubleSide,",
                    "                    })",
                    "                    : new THREE.MeshBasicMaterial({",
                    "                        color: 0xffffff,",
                    "                        transparent: true,",
                    "                        blending: THREE.AdditiveBlending,",
                    "                        side: THREE.DoubleSide,",
                    "                    }),",
                    "            startTileIndex: typeof json.startTileIndex === 'number'",
                    "                ? new ConstantValue(json.startTileIndex)",
                    "                : ValueGeneratorFromJSON(json.startTileIndex),",
                    "            uTileCount: json.uTileCount,",
                    "            vTileCount: json.vTileCount,",
                    "            behaviors: [],",
                    "            worldSpace: json.worldSpace,",
                    "        });",
                    "        ps.behaviors = json.behaviors.map((behaviorJson) => {",
                    "            const behavior = BehaviorFromJSON(behaviorJson, ps);",
                    "            if (behavior.type === 'EmitSubParticleSystem') {",
                    "                dependencies[behaviorJson.subParticleSystem] = behavior;",
                    "            }",
                    "            return behavior;",
                    "        });",
                    "        return ps;",
                    "    }",
                    "    addBehavior(behavior) {",
                    "        this.behaviors.push(behavior);",
                    "    }",
                    "    getRendererSettings() {",
                    "        return this.rendererSettings;",
                    "    }",
                    "    clone() {",
                    "        const newEmissionBursts = [];",
                    "        for (const emissionBurst of this.emissionBursts) {",
                    "            const newEmissionBurst = {};",
                    "            Object.assign(newEmissionBurst, emissionBurst);",
                    "            newEmissionBursts.push(newEmissionBurst);",
                    "        }",
                    "        const newBehaviors = [];",
                    "        for (const behavior of this.behaviors) {",
                    "            newBehaviors.push(behavior.clone());",
                    "        }",
                    "        let rendererEmitterSettings;",
                    "        if (this.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "            rendererEmitterSettings = {",
                    "                startLength: this.rendererEmitterSettings.startLength.clone(),",
                    "                followLocalOrigin: this.rendererEmitterSettings.followLocalOrigin,",
                    "            };",
                    "        }",
                    "        else {",
                    "            rendererEmitterSettings = {};",
                    "        }",
                    "        const layers = new THREE.Layers();",
                    "        layers.mask = this.layers.mask;",
                    "        return new ParticleSystem({",
                    "            autoDestroy: this.autoDestroy,",
                    "            looping: this.looping,",
                    "            duration: this.duration,",
                    "            shape: this.emitterShape.clone(),",
                    "            startLife: this.startLife.clone(),",
                    "            startSpeed: this.startSpeed.clone(),",
                    "            startRotation: this.startRotation.clone(),",
                    "            startSize: this.startSize.clone(),",
                    "            startColor: this.startColor.clone(),",
                    "            emissionOverTime: this.emissionOverTime.clone(),",
                    "            emissionOverDistance: this.emissionOverDistance.clone(),",
                    "            emissionBursts: newEmissionBursts,",
                    "            onlyUsedByOther: this.onlyUsedByOther,",
                    "            instancingGeometry: this.rendererSettings.instancingGeometry,",
                    "            renderMode: this.renderMode,",
                    "            renderOrder: this.renderOrder,",
                    "            rendererEmitterSettings: rendererEmitterSettings,",
                    "            material: this.rendererSettings.material,",
                    "            startTileIndex: this.startTileIndex,",
                    "            uTileCount: this.uTileCount,",
                    "            vTileCount: this.vTileCount,",
                    "            behaviors: newBehaviors,",
                    "            worldSpace: this.worldSpace,",
                    "            layers: layers,",
                    "        });",
                    "    }",
                    "}",
                    "",
                    "var particle_frag = `",
                    "",
                    "#include <common>",
                    "#include <uv_pars_fragment>",
                    "#include <color_pars_fragment>",
                    "#include <map_pars_fragment>",
                    "#include <logdepthbuf_pars_fragment>",
                    "#include <clipping_planes_pars_fragment>",
                    "#include <alphatest_pars_fragment>",
                    "",
                    "void main() {",
                    "",
                    "    #include <clipping_planes_fragment>",
                    "    ",
                    "    vec3 outgoingLight = vec3( 0.0 );",
                    "    vec4 diffuseColor = vColor;",
                    "    ",
                    "    #include <logdepthbuf_fragment>",
                    "    ",
                    "    #ifdef USE_MAP",
                    "    diffuseColor *= texture2D( map, vMapUv);",
                    "    #endif",
                    "    ",
                    "    #include <alphatest_fragment>",
                    "",
                    "    outgoingLight = diffuseColor.rgb;",
                    "    ",
                    "    #ifdef USE_COLOR_AS_ALPHA",
                    "    gl_FragColor = vec4( outgoingLight, diffuseColor.r );",
                    "    #else",
                    "    gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    "    #endif",
                    "    ",
                    "    ",
                    "    #include <tonemapping_fragment>",
                    "",
                    "}",
                    "`;",
                    "",
                    "var particle_physics_frag = `",
                    "#define STANDARD",
                    "#ifdef PHYSICAL",
                    "#define IOR",
                    "#define SPECULAR",
                    "#endif",
                    "uniform vec3 diffuse;",
                    "uniform vec3 emissive;",
                    "uniform float roughness;",
                    "uniform float metalness;",
                    "uniform float opacity;",
                    "#ifdef IOR",
                    "uniform float ior;",
                    "#endif",
                    "#ifdef SPECULAR",
                    "uniform float specularIntensity;",
                    "uniform vec3 specularColor;",
                    "#ifdef USE_SPECULARINTENSITYMAP",
                    "uniform sampler2D specularIntensityMap;",
                    "#endif",
                    "#ifdef USE_SPECULARCOLORMAP",
                    "uniform sampler2D specularColorMap;",
                    "#endif",
                    "#endif",
                    "#ifdef USE_CLEARCOAT",
                    "uniform float clearcoat;",
                    "uniform float clearcoatRoughness;",
                    "#endif",
                    "#ifdef USE_IRIDESCENCE",
                    "uniform float iridescence;",
                    "uniform float iridescenceIOR;",
                    "uniform float iridescenceThicknessMinimum;",
                    "uniform float iridescenceThicknessMaximum;",
                    "#endif",
                    "#ifdef USE_SHEEN",
                    "uniform vec3 sheenColor;",
                    "uniform float sheenRoughness;",
                    "#ifdef USE_SHEENCOLORMAP",
                    "uniform sampler2D sheenColorMap;",
                    "#endif",
                    "#ifdef USE_SHEENROUGHNESSMAP",
                    "uniform sampler2D sheenRoughnessMap;",
                    "#endif",
                    "#endif",
                    "",
                    "varying vec3 vViewPosition;",
                    "#include <common>",
                    "#include <packing>",
                    "#include <dithering_pars_fragment>",
                    "#include <color_pars_fragment>",
                    "#include <uv_pars_fragment>",
                    "#include <map_pars_fragment>",
                    "#include <alphamap_pars_fragment>",
                    "#include <alphatest_pars_fragment>",
                    "#include <aomap_pars_fragment>",
                    "#include <lightmap_pars_fragment>",
                    "#include <emissivemap_pars_fragment>",
                    "#include <bsdfs>",
                    "#include <iridescence_fragment>",
                    "#include <cube_uv_reflection_fragment>",
                    "#include <envmap_common_pars_fragment>",
                    "#include <envmap_physical_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <lights_pars_begin>",
                    "#include <normal_pars_fragment>",
                    "#include <lights_physical_pars_fragment>",
                    "#include <transmission_pars_fragment>",
                    "#include <shadowmap_pars_fragment>",
                    "#include <bumpmap_pars_fragment>",
                    "#include <normalmap_pars_fragment>",
                    "#include <clearcoat_pars_fragment>",
                    "#include <iridescence_pars_fragment>",
                    "#include <roughnessmap_pars_fragment>",
                    "#include <metalnessmap_pars_fragment>",
                    "#include <logdepthbuf_pars_fragment>",
                    "#include <clipping_planes_pars_fragment>",
                    "",
                    "void main() {",
                    "    #include <clipping_planes_fragment>",
                    "    vec4 diffuseColor = vec4( diffuse, opacity );",
                    "    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
                    "    vec3 totalEmissiveRadiance = emissive;",
                    "    #include <logdepthbuf_fragment>",
                    "    #include <map_fragment>",
                    "    #include <color_fragment>",
                    "    #include <alphamap_fragment>",
                    "    #include <alphatest_fragment>",
                    "    #include <roughnessmap_fragment>",
                    "    #include <metalnessmap_fragment>",
                    "    #include <normal_fragment_begin>",
                    "    #include <normal_fragment_maps>",
                    "    #include <clearcoat_normal_fragment_begin>",
                    "    #include <clearcoat_normal_fragment_maps>",
                    "    #include <emissivemap_fragment>",
                    "    // accumulation",
                    "    #include <lights_physical_fragment>",
                    "    #include <lights_fragment_begin>",
                    "    #include <lights_fragment_maps>",
                    "    #include <lights_fragment_end>",
                    "    // modulation",
                    "    #include <aomap_fragment>",
                    "    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;",
                    "    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;",
                    "    #include <transmission_fragment>",
                    "    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;",
                    "    #ifdef USE_SHEEN",
                    "    // Sheen energy compensation approximation calculation can be found at the end of",
                    "        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing",
                    "        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );",
                    "        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;",
                    "    #endif",
                    "    #ifdef USE_CLEARCOAT",
                    "        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );",
                    "        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );",
                    "        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;",
                    "    #endif",
                    "    #include <output_fragment>",
                    "    #include <tonemapping_fragment>",
                    "    #include <encodings_fragment>",
                    "    #include <fog_fragment>",
                    "    #include <premultiplied_alpha_fragment>",
                    "    #include <dithering_fragment>",
                    "}`;",
                    "",
                    "var uv_vertex_tile = `",
                    "",
                    "    #ifdef UV_TILE",
                    "        float col = mod(uvTile, tileCount.x);",
                    "        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);",
                    "        ",
                    "        mat3 tileTransform = mat3(",
                    "          1.0 / tileCount.x, 0.0, 0.0,",
                    "          0.0, 1.0 / tileCount.y, 0.0, ",
                    "          col / tileCount.x, row / tileCount.y, 1.0);",
                    "    #else",
                    "        mat3 tileTransform = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);",
                    "    #endif",
                    "",
                    "#if defined( USE_UV ) || defined( USE_ANISOTROPY )",
                    "",
                    "vUv = (tileTransform *vec3( uv, 1 )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_MAP",
                    "",
                    "vMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_ALPHAMAP",
                    "",
                    "vAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_LIGHTMAP",
                    "",
                    "vLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_AOMAP",
                    "",
                    "vAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_BUMPMAP",
                    "",
                    "vBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_NORMALMAP",
                    "",
                    "vNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_DISPLACEMENTMAP",
                    "",
                    "vDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_EMISSIVEMAP",
                    "",
                    "vEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_METALNESSMAP",
                    "",
                    "vMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_ROUGHNESSMAP",
                    "",
                    "vRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_ANISOTROPYMAP",
                    "",
                    "vAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_CLEARCOATMAP",
                    "",
                    "vClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_CLEARCOAT_NORMALMAP",
                    "",
                    "vClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_CLEARCOAT_ROUGHNESSMAP",
                    "",
                    "vClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_IRIDESCENCEMAP",
                    "",
                    "vIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_IRIDESCENCE_THICKNESSMAP",
                    "",
                    "vIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_SHEEN_COLORMAP",
                    "",
                    "vSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_SHEEN_ROUGHNESSMAP",
                    "",
                    "vSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_SPECULARMAP",
                    "",
                    "vSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_SPECULAR_COLORMAP",
                    "",
                    "vSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_SPECULAR_INTENSITYMAP",
                    "",
                    "vSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_TRANSMISSIONMAP",
                    "",
                    "vTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "#ifdef USE_THICKNESSMAP",
                    "",
                    "vThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;",
                    "",
                    "#endif",
                    "`;",
                    "",
                    "var particle_vert = `",
                    "#include <common>",
                    "#include <color_pars_vertex>",
                    "#include <uv_pars_vertex>",
                    "#include <logdepthbuf_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                    "",
                    "attribute vec3 offset;",
                    "attribute float rotation;",
                    "attribute float size;",
                    "attribute float uvTile;",
                    "",
                    "#ifdef UV_TILE",
                    "uniform vec2 tileCount;",
                    "#endif",
                    "",
                    "void main() {",
                    "",
                    "    ${uv_vertex_tile}",
                    "\t",
                    "    vec2 alignedPosition = ( position.xy ) * size;",
                    "    ",
                    "    vec2 rotatedPosition;",
                    "    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;",
                    "    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;",
                    "#ifdef HORIZONTAL",
                    "    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );",
                    "    mvPosition.x += rotatedPosition.x;",
                    "    mvPosition.z -= rotatedPosition.y;",
                    "    mvPosition = viewMatrix * mvPosition;",
                    "#elif defined(VERTICAL)",
                    "    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );",
                    "    mvPosition.y += rotatedPosition.y;",
                    "    mvPosition = viewMatrix * mvPosition;",
                    "    mvPosition.x += rotatedPosition.x;",
                    "#else",
                    "    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );",
                    "    mvPosition.xy += rotatedPosition;",
                    "#endif",
                    "",
                    "\tvColor = color;",
                    "",
                    "\tgl_Position = projectionMatrix * mvPosition;",
                    "",
                    "\t#include <logdepthbuf_vertex>",
                    "\t#include <clipping_planes_vertex>",
                    "",
                    "}",
                    "`;",
                    "",
                    "var local_particle_vert = `",
                    "#include <common>",
                    "#include <uv_pars_vertex>",
                    "#include <color_pars_vertex>",
                    "#include <logdepthbuf_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                    "",
                    "attribute vec3 offset;",
                    "attribute vec4 rotation;",
                    "attribute float size;",
                    "// attribute vec4 color;",
                    "attribute float uvTile;",
                    "",
                    "#ifdef UV_TILE",
                    "uniform vec2 tileCount;",
                    "#endif",
                    "",
                    "void main() {",
                    "",
                    "    ${uv_vertex_tile}",
                    "    ",
                    "    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;",
                    "    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;",
                    "    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;",
                    "    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;",
                    "    float sx = size, sy = size, sz = size;",
                    "    ",
                    "    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column",
                    "                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column",
                    "                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column",
                    "                      offset.x, offset.y, offset.z, 1.0);",
                    "    ",
                    "    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));",
                    "",
                    "\tvColor = color;",
                    "",
                    "\tgl_Position = projectionMatrix * mvPosition;",
                    "",
                    "\t#include <logdepthbuf_vertex>",
                    "\t#include <clipping_planes_vertex>",
                    "",
                    "}",
                    "`;",
                    "",
                    "var local_particle_physics_vert = `",
                    "#define STANDARD",
                    "varying vec3 vViewPosition;",
                    "#ifdef USE_TRANSMISSION",
                    "\tvarying vec3 vWorldPosition;",
                    "#endif",
                    "#include <common>",
                    "#include <uv_pars_vertex>",
                    "",
                    "attribute vec3 offset;",
                    "attribute vec4 rotation;",
                    "attribute float size;",
                    "attribute float uvTile;",
                    "",
                    "#ifdef UV_TILE",
                    "uniform vec2 tileCount;",
                    "#endif",
                    "",
                    "#include <displacementmap_pars_vertex>",
                    "#include <color_pars_vertex>",
                    "#include <fog_pars_vertex>",
                    "#include <normal_pars_vertex>",
                    "#include <morphtarget_pars_vertex>",
                    "#include <skinning_pars_vertex>",
                    "#include <shadowmap_pars_vertex>",
                    "#include <logdepthbuf_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                    "",
                    "void main() {",
                    "    ${uv_vertex_tile}",
                    "",
                    "    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;",
                    "    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;",
                    "    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;",
                    "    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;",
                    "    float sx = size, sy = size, sz = size;",
                    "",
                    "    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column",
                    "                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column",
                    "                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column",
                    "                      offset.x, offset.y, offset.z, 1.0);",
                    "",
                    "\t#include <color_vertex>",
                    "\t#include <morphcolor_vertex>",
                    "\t#include <beginnormal_vertex>",
                    "\t#include <morphnormal_vertex>",
                    "\t#include <skinbase_vertex>",
                    "\t#include <skinnormal_vertex>",
                    "",
                    "\t// replace defaultnormal_vertex",
                    "\tvec3 transformedNormal = objectNormal;",
                    "    mat3 m = mat3( particleMatrix );",
                    "    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );",
                    "    transformedNormal = m * transformedNormal;",
                    "    transformedNormal = normalMatrix * transformedNormal;",
                    "    #ifdef FLIP_SIDED",
                    "        transformedNormal = - transformedNormal;",
                    "    #endif",
                    "    #ifdef USE_TANGENT",
                    "        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;",
                    "        #ifdef FLIP_SIDED",
                    "        transformedTangent = - transformedTangent;",
                    "        #endif",
                    "    #endif",
                    "",
                    "\t#include <normal_vertex>",
                    "\t#include <begin_vertex>",
                    "\t#include <morphtarget_vertex>",
                    "\t#include <skinning_vertex>",
                    "\t#include <displacementmap_vertex>",
                    "",
                    "\t// replace include <project_vertex>",
                    "  vec4 mvPosition = vec4( transformed, 1.0 );",
                    "  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);",
                    "\tgl_Position = projectionMatrix * mvPosition;",
                    "",
                    "\t#include <logdepthbuf_vertex>",
                    "\t#include <clipping_planes_vertex>",
                    "\t",
                    "\tvViewPosition = - mvPosition.xyz;",
                    "\t",
                    "\t#include <worldpos_vertex>",
                    "\t#include <shadowmap_vertex>",
                    "\t#include <fog_vertex>",
                    "#ifdef USE_TRANSMISSION",
                    "\tvWorldPosition = worldPosition.xyz;",
                    "#endif",
                    "}",
                    "`;",
                    "",
                    "var stretched_bb_particle_vert = `",
                    "#include <common>",
                    "#include <uv_pars_vertex>",
                    "#include <color_pars_vertex>",
                    "#include <logdepthbuf_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                    "",
                    "attribute vec3 offset;",
                    "attribute float rotation;",
                    "attribute float size;",
                    "attribute vec4 velocity;",
                    "attribute float uvTile;",
                    "",
                    "#ifdef UV_TILE",
                    "uniform vec2 tileCount;",
                    "#endif",
                    "",
                    "uniform float speedFactor;",
                    "",
                    "void main() {",
                    "",
                    "    ${uv_vertex_tile}",
                    "    ",
                    "    float lengthFactor = velocity.w;",
                    "#ifdef USE_SKEW",
                    "    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );",
                    "    vec3 viewVelocity = normalMatrix * velocity.xyz;",
                    "",
                    "    vec3 scaledPos = vec3(position.xy * size, position.z);",
                    "    float vlength = length(viewVelocity);",
                    "    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;",
                    "    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / size + lengthFactor / vlength);",
                    "#else",
                    "    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );",
                    "    vec3 viewVelocity = normalMatrix * velocity.xyz;",
                    "    float vlength = length(viewVelocity); ",
                    "    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * size; // switch the cross to  match unity implementation",
                    "    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * size; // minus position.x to match unity implementation",
                    "#endif",
                    "\tvColor = color;",
                    "\tgl_Position = projectionMatrix * mvPosition;",
                    "\t#include <logdepthbuf_vertex>",
                    "\t#include <clipping_planes_vertex>",
                    "}",
                    "`;",
                    "",
                    "function getMaterialUVChannelName(value) {",
                    "    if (value === 0)",
                    "        return 'uv';",
                    "    return `uv${value}`;",
                    "}",
                    "",
                    "new THREE.Vector3(0, 0, 1);",
                    "class SpriteBatch extends VFXBatch {",
                    "    constructor(settings) {",
                    "        super(settings);",
                    "        this.vector_ = new THREE.Vector3();",
                    "        this.vector2_ = new THREE.Vector3();",
                    "        this.vector3_ = new THREE.Vector3();",
                    "        this.quaternion_ = new THREE.Quaternion();",
                    "        this.quaternion2_ = new THREE.Quaternion();",
                    "        this.quaternion3_ = new THREE.Quaternion();",
                    "        this.rotationMat_ = new THREE.Matrix3();",
                    "        this.rotationMat2_ = new THREE.Matrix3();",
                    "        this.maxParticles = 1000;",
                    "        this.setupBuffers();",
                    "        this.rebuildMaterial();",
                    "    }",
                    "    buildExpandableBuffers() {",
                    "        this.offsetBuffer = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles * 3), 3);",
                    "        this.offsetBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('offset', this.offsetBuffer);",
                    "        this.colorBuffer = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles * 4), 4);",
                    "        this.colorBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('color', this.colorBuffer);",
                    "        if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "            this.rotationBuffer = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles * 4), 4);",
                    "            this.rotationBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "            this.geometry.setAttribute('rotation', this.rotationBuffer);",
                    "        }",
                    "        else if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard ||",
                    "            this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard ||",
                    "            this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard ||",
                    "            this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard) {",
                    "            this.rotationBuffer = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles), 1);",
                    "            this.rotationBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "            this.geometry.setAttribute('rotation', this.rotationBuffer);",
                    "        }",
                    "        this.sizeBuffer = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles), 1);",
                    "        this.sizeBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('size', this.sizeBuffer);",
                    "        this.uvTileBuffer = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles), 1);",
                    "        this.uvTileBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('uvTile', this.uvTileBuffer);",
                    "        if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard) {",
                    "            this.velocityBuffer = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles * 4), 4);",
                    "            this.velocityBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "            this.geometry.setAttribute('velocity', this.velocityBuffer);",
                    "        }",
                    "    }",
                    "    setupBuffers() {",
                    "        if (this.geometry)",
                    "            this.geometry.dispose();",
                    "        this.geometry = new THREE.InstancedBufferGeometry();",
                    "        this.geometry.setIndex(this.settings.instancingGeometry.getIndex());",
                    "        if (this.settings.instancingGeometry.hasAttribute('normal')) {",
                    "            this.geometry.setAttribute('normal', this.settings.instancingGeometry.getAttribute('normal'));",
                    "        }",
                    "        this.geometry.setAttribute('position', this.settings.instancingGeometry.getAttribute('position'));",
                    "        this.geometry.setAttribute('uv', this.settings.instancingGeometry.getAttribute('uv'));",
                    "        this.buildExpandableBuffers();",
                    "    }",
                    "    expandBuffers(target) {",
                    "        while (target >= this.maxParticles) {",
                    "            this.maxParticles *= 2;",
                    "        }",
                    "        this.setupBuffers();",
                    "    }",
                    "    rebuildMaterial() {",
                    "        this.layers.mask = this.settings.layers.mask;",
                    "        let uniforms;",
                    "        const defines = {};",
                    "        if (this.settings.material.type === 'MeshStandardMaterial' ||",
                    "            this.settings.material.type === 'MeshPhysicalMaterial') {",
                    "            const mat = this.settings.material;",
                    "            uniforms = THREE.UniformsUtils.merge([",
                    "                THREE.UniformsLib.common,",
                    "                THREE.UniformsLib.envmap,",
                    "                THREE.UniformsLib.aomap,",
                    "                THREE.UniformsLib.lightmap,",
                    "                THREE.UniformsLib.emissivemap,",
                    "                THREE.UniformsLib.bumpmap,",
                    "                THREE.UniformsLib.normalmap,",
                    "                THREE.UniformsLib.displacementmap,",
                    "                THREE.UniformsLib.roughnessmap,",
                    "                THREE.UniformsLib.metalnessmap,",
                    "                THREE.UniformsLib.fog,",
                    "                THREE.UniformsLib.lights,",
                    "                {",
                    "                    emissive: { value: new THREE.Color(0x000000) },",
                    "                    roughness: { value: 1.0 },",
                    "                    metalness: { value: 0.0 },",
                    "                    envMapIntensity: { value: 1 },",
                    "                },",
                    "            ]);",
                    "            uniforms['diffuse'].value = mat.color;",
                    "            uniforms['opacity'].value = mat.opacity;",
                    "            uniforms['emissive'].value = mat.emissive;",
                    "            uniforms['roughness'].value = mat.roughness;",
                    "            uniforms['metalness'].value = mat.metalness;",
                    "            if (mat.envMap) {",
                    "                uniforms['envMap'].value = mat.envMap;",
                    "                uniforms['envMapIntensity'].value = mat.envMapIntensity;",
                    "            }",
                    "            if (mat.normalMap) {",
                    "                uniforms['normalMap'].value = mat.normalMap;",
                    "                uniforms['normalScale'].value = mat.normalScale;",
                    "            }",
                    "            if (mat.roughnessMap) {",
                    "                uniforms['roughnessMap'].value = mat.roughnessMap;",
                    "            }",
                    "            if (mat.metalnessMap) {",
                    "                uniforms['metalnessMap'].value = mat.metalnessMap;",
                    "            }",
                    "            if (mat.map) {",
                    "                uniforms['map'] = new THREE.Uniform(mat.map);",
                    "            }",
                    "        }",
                    "        else {",
                    "            uniforms = {};",
                    "            uniforms['map'] = new THREE.Uniform(this.settings.material.map);",
                    "        }",
                    "        if (this.settings.material.alphaTest) {",
                    "            defines['USE_ALPHATEST'] = '';",
                    "            uniforms['alphaTest'] = new THREE.Uniform(this.settings.material.alphaTest);",
                    "        }",
                    "        defines['USE_UV'] = '';",
                    "        const uTileCount = this.settings.uTileCount;",
                    "        const vTileCount = this.settings.vTileCount;",
                    "        if (uTileCount > 1 || vTileCount > 1) {",
                    "            defines['UV_TILE'] = '';",
                    "            uniforms['tileCount'] = new THREE.Uniform(new THREE.Vector2(uTileCount, vTileCount));",
                    "        }",
                    "        if (this.settings.material.defines &&",
                    "            this.settings.material.defines['USE_COLOR_AS_ALPHA'] !== undefined) {",
                    "            defines['USE_COLOR_AS_ALPHA'] = '';",
                    "        }",
                    "        if (this.settings.material.normalMap) {",
                    "            defines['USE_NORMALMAP'] = '';",
                    "            defines['NORMALMAP_UV'] = getMaterialUVChannelName(this.settings.material.normalMap.channel);",
                    "            uniforms['normalMapTransform'] = new THREE.Uniform(new THREE.Matrix3().copy(this.settings.material.normalMap.matrix));",
                    "        }",
                    "        if (this.settings.material.map) {",
                    "            defines['USE_MAP'] = '';",
                    "            defines['MAP_UV'] = getMaterialUVChannelName(this.settings.material.map.channel);",
                    "            uniforms['mapTransform'] = new THREE.Uniform(new THREE.Matrix3().copy(this.settings.material.map.matrix));",
                    "        }",
                    "        defines['USE_COLOR_ALPHA'] = '';",
                    "        let needLights = false;",
                    "        if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard ||",
                    "            this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard ||",
                    "            this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard ||",
                    "            this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "            let vertexShader;",
                    "            let fragmentShader;",
                    "            if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "                if (this.settings.material.type === 'MeshStandardMaterial' ||",
                    "                    this.settings.material.type === 'MeshPhysicalMaterial') {",
                    "                    defines['USE_COLOR'] = '';",
                    "                    vertexShader = local_particle_physics_vert;",
                    "                    fragmentShader = particle_physics_frag;",
                    "                    needLights = true;",
                    "                }",
                    "                else {",
                    "                    vertexShader = local_particle_vert;",
                    "                    fragmentShader = particle_frag;",
                    "                }",
                    "            }",
                    "            else {",
                    "                vertexShader = particle_vert;",
                    "                fragmentShader = particle_frag;",
                    "            }",
                    "            if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard) {",
                    "                defines['VERTICAL'] = '';",
                    "            }",
                    "            else if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard) {",
                    "                defines['HORIZONTAL'] = '';",
                    "            }",
                    "            this.material = new THREE.ShaderMaterial({",
                    "                uniforms: uniforms,",
                    "                defines: defines,",
                    "                vertexShader: vertexShader,",
                    "                fragmentShader: fragmentShader,",
                    "                transparent: this.settings.material.transparent,",
                    "                depthWrite: !this.settings.material.transparent,",
                    "                blending: this.settings.material.blending,",
                    "                side: this.settings.material.side,",
                    "                alphaTest: this.settings.material.alphaTest,",
                    "                lights: needLights,",
                    "            });",
                    "        }",
                    "        else if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard) {",
                    "            uniforms['speedFactor'] = new THREE.Uniform(1.0);",
                    "            this.material = new THREE.ShaderMaterial({",
                    "                uniforms: uniforms,",
                    "                defines: defines,",
                    "                vertexShader: stretched_bb_particle_vert,",
                    "                fragmentShader: particle_frag,",
                    "                transparent: this.settings.material.transparent,",
                    "                depthWrite: !this.settings.material.transparent,",
                    "                blending: this.settings.material.blending,",
                    "                side: this.settings.material.side,",
                    "                alphaTest: this.settings.material.alphaTest,",
                    "            });",
                    "        }",
                    "        else {",
                    "            throw new Error('render mode unavailable');",
                    "        }",
                    "    }",
                    "    update() {",
                    "        let index = 0;",
                    "        let particleCount = 0;",
                    "        this.systems.forEach((system) => {",
                    "            particleCount += system.particleNum;",
                    "        });",
                    "        if (particleCount > this.maxParticles) {",
                    "            this.expandBuffers(particleCount);",
                    "        }",
                    "        this.systems.forEach((system) => {",
                    "            const particles = system.particles;",
                    "            const particleNum = system.particleNum;",
                    "            const rotation = this.quaternion2_;",
                    "            const translation = this.vector2_;",
                    "            const scale = this.vector3_;",
                    "            system.emitter.matrixWorld.decompose(translation, rotation, scale);",
                    "            this.rotationMat_.setFromMatrix4(system.emitter.matrixWorld);",
                    "            for (let j = 0; j < particleNum; j++ , index++) {",
                    "                const particle = particles[j];",
                    "                if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "                    let q;",
                    "                    if (system.worldSpace) {",
                    "                        q = particle.rotation;",
                    "                    }",
                    "                    else {",
                    "                        let parentQ;",
                    "                        if (particle.parentMatrix) {",
                    "                            parentQ = this.quaternion3_.setFromRotationMatrix(particle.parentMatrix);",
                    "                        }",
                    "                        else {",
                    "                            parentQ = rotation;",
                    "                        }",
                    "                        q = this.quaternion_;",
                    "                        q.copy(particle.rotation).multiply(parentQ);",
                    "                    }",
                    "                    this.rotationBuffer.setXYZW(index, q.x, q.y, q.z, q.w);",
                    "                }",
                    "                else if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard ||",
                    "                    this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard ||",
                    "                    this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard ||",
                    "                    this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard) {",
                    "                    this.rotationBuffer.setX(index, particle.rotation);",
                    "                }",
                    "                let vec;",
                    "                if (system.worldSpace) {",
                    "                    vec = particle.position;",
                    "                }",
                    "                else {",
                    "                    vec = this.vector_;",
                    "                    if (particle.parentMatrix) {",
                    "                        vec.copy(particle.position).applyMatrix4(particle.parentMatrix);",
                    "                    }",
                    "                    else {",
                    "                        vec.copy(particle.position).applyMatrix4(system.emitter.matrixWorld);",
                    "                    }",
                    "                }",
                    "                this.offsetBuffer.setXYZ(index, vec.x, vec.y, vec.z);",
                    "                this.colorBuffer.setXYZW(index, particle.color.x, particle.color.y, particle.color.z, particle.color.w);",
                    "                if (system.worldSpace) {",
                    "                    this.sizeBuffer.setX(index, particle.size);",
                    "                }",
                    "                else {",
                    "                    if (particle.parentMatrix) {",
                    "                        this.sizeBuffer.setX(index, particle.size);",
                    "                    }",
                    "                    else {",
                    "                        this.sizeBuffer.setX(index, (particle.size * (Math.abs(scale.x) + Math.abs(scale.y) + Math.abs(scale.z))) / 3);",
                    "                    }",
                    "                }",
                    "                this.uvTileBuffer.setX(index, particle.uvTile);",
                    "                if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard && this.velocityBuffer) {",
                    "                    let speedFactor = system.rendererEmitterSettings.speedFactor;",
                    "                    if (speedFactor === 0)",
                    "                        speedFactor = 0.001;",
                    "                    const lengthFactor = system.rendererEmitterSettings.lengthFactor;",
                    "                    let vec;",
                    "                    if (system.worldSpace) {",
                    "                        vec = particle.velocity;",
                    "                    }",
                    "                    else {",
                    "                        vec = this.vector_;",
                    "                        if (particle.parentMatrix) {",
                    "                            this.rotationMat2_.setFromMatrix4(particle.parentMatrix);",
                    "                            vec.copy(particle.velocity).applyMatrix3(this.rotationMat2_);",
                    "                        }",
                    "                        else {",
                    "                            vec.copy(particle.velocity).applyMatrix3(this.rotationMat_);",
                    "                        }",
                    "                    }",
                    "                    this.velocityBuffer.setXYZW(index, vec.x * speedFactor, vec.y * speedFactor, vec.z * speedFactor, lengthFactor);",
                    "                }",
                    "            }",
                    "        });",
                    "        this.geometry.instanceCount = index;",
                    "        if (index > 0) {",
                    "            this.offsetBuffer.updateRange.count = index * 3;",
                    "            this.offsetBuffer.needsUpdate = true;",
                    "            this.sizeBuffer.updateRange.count = index;",
                    "            this.sizeBuffer.needsUpdate = true;",
                    "            this.colorBuffer.updateRange.count = index * 4;",
                    "            this.colorBuffer.needsUpdate = true;",
                    "            this.uvTileBuffer.updateRange.count = index;",
                    "            this.uvTileBuffer.needsUpdate = true;",
                    "            if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard && this.velocityBuffer) {",
                    "                this.velocityBuffer.updateRange.count = index * 4;",
                    "                this.velocityBuffer.needsUpdate = true;",
                    "            }",
                    "            if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Mesh) {",
                    "                this.rotationBuffer.updateRange.count = index * 4;",
                    "                this.rotationBuffer.needsUpdate = true;",
                    "            }",
                    "            else if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard ||",
                    "                this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard ||",
                    "                this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard ||",
                    "                this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard) {",
                    "                this.rotationBuffer.updateRange.count = index;",
                    "                this.rotationBuffer.needsUpdate = true;",
                    "            }",
                    "        }",
                    "    }",
                    "    dispose() {",
                    "        this.geometry.dispose();",
                    "    }",
                    "}",
                    "",
                    "var trail_frag = `",
                    "",
                    "#include <common>",
                    "#include <uv_pars_fragment>",
                    "#include <map_pars_fragment>",
                    "#include <fog_pars_fragment>",
                    "#include <logdepthbuf_pars_fragment>",
                    "#include <clipping_planes_pars_fragment>",
                    "",
                    "uniform sampler2D alphaMap;",
                    "uniform float useAlphaMap;",
                    "uniform float visibility;",
                    "uniform float alphaTest;",
                    "uniform vec2 repeat;",
                    "",
                    "varying vec4 vColor;",
                    "    ",
                    "void main() {",
                    "    #include <clipping_planes_fragment>",
                    "    #include <logdepthbuf_fragment>",
                    "",
                    "    vec4 c = vColor;",
                    "    ",
                    "    #ifdef USE_MAP",
                    "    #ifdef USE_COLOR_AS_ALPHA",
                    "    vec4 tex = texture2D( map, vUv * repeat );",
                    "    c *= vec4(tex.rgb, tex.r);",
                    "    #else",
                    "    c *= texture2D( map, vUv * repeat );",
                    "    #endif",
                    "    #endif",
                    "    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUv * repeat ).a;",
                    "    if( c.a < alphaTest ) discard;",
                    "    gl_FragColor = c;",
                    "",
                    "    #include <fog_fragment>",
                    "    #include <tonemapping_fragment>",
                    "}`;",
                    "",
                    "var trail_vert = `",
                    "#include <common>",
                    "#include <uv_pars_vertex>",
                    "#include <color_pars_vertex>",
                    "#include <clipping_planes_pars_vertex>",
                    "#include <logdepthbuf_pars_vertex>",
                    "#include <fog_pars_vertex>",
                    "",
                    "attribute vec3 previous;",
                    "attribute vec3 next;",
                    "attribute float side;",
                    "attribute float width;",
                    "",
                    "uniform vec2 resolution;",
                    "uniform float lineWidth;",
                    "uniform float sizeAttenuation;",
                    "    ",
                    "vec2 fix(vec4 i, float aspect) {",
                    "    vec2 res = i.xy / i.w;",
                    "    res.x *= aspect;",
                    "    return res;",
                    "}",
                    "    ",
                    "void main() {",
                    "",
                    "    ${uv_vertex_tile}",
                    "    ",
                    "    float aspect = resolution.x / resolution.y;",
                    "",
                    "    vColor = color;",
                    "",
                    "    mat4 m = projectionMatrix * modelViewMatrix;",
                    "    vec4 finalPosition = m * vec4( position, 1.0 );",
                    "    vec4 prevPos = m * vec4( previous, 1.0 );",
                    "    vec4 nextPos = m * vec4( next, 1.0 );",
                    "",
                    "    vec2 currentP = fix( finalPosition, aspect );",
                    "    vec2 prevP = fix( prevPos, aspect );",
                    "    vec2 nextP = fix( nextPos, aspect );",
                    "",
                    "    float w = lineWidth * width;",
                    "",
                    "    vec2 dir;",
                    "    if( nextP == currentP ) dir = normalize( currentP - prevP );",
                    "    else if( prevP == currentP ) dir = normalize( nextP - currentP );",
                    "    else {",
                    "        vec2 dir1 = normalize( currentP - prevP );",
                    "        vec2 dir2 = normalize( nextP - currentP );",
                    "        dir = normalize( dir1 + dir2 );",
                    "",
                    "        vec2 perp = vec2( -dir1.y, dir1.x );",
                    "        vec2 miter = vec2( -dir.y, dir.x );",
                    "        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );",
                    "",
                    "    }",
                    "",
                    "    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;",
                    "    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );",
                    "    normal.xy *= .5 * w;",
                    "    normal *= projectionMatrix;",
                    "    if( sizeAttenuation == 0. ) {",
                    "        normal.xy *= finalPosition.w;",
                    "        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;",
                    "    }",
                    "",
                    "    finalPosition.xy += normal.xy * side;",
                    "",
                    "    gl_Position = finalPosition;",
                    "",
                    "\t#include <logdepthbuf_vertex>",
                    "\t#include <clipping_planes_vertex>",
                    "\t",
                    "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
                    "    ",
                    "\t#include <fog_vertex>",
                    "}`;",
                    "",
                    "new THREE.Vector3(0, 0, 1);",
                    "class TrailBatch extends VFXBatch {",
                    "    constructor(settings) {",
                    "        super(settings);",
                    "        this.vector_ = new THREE.Vector3();",
                    "        this.vector2_ = new THREE.Vector3();",
                    "        this.vector3_ = new THREE.Vector3();",
                    "        this.quaternion_ = new THREE.Quaternion();",
                    "        this.maxParticles = 10000;",
                    "        this.setupBuffers();",
                    "        this.rebuildMaterial();",
                    "    }",
                    "    setupBuffers() {",
                    "        if (this.geometry)",
                    "            this.geometry.dispose();",
                    "        this.geometry = new THREE.BufferGeometry();",
                    "        this.indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.maxParticles * 6), 1);",
                    "        this.indexBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setIndex(this.indexBuffer);",
                    "        this.positionBuffer = new THREE.BufferAttribute(new Float32Array(this.maxParticles * 6), 3);",
                    "        this.positionBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('position', this.positionBuffer);",
                    "        this.previousBuffer = new THREE.BufferAttribute(new Float32Array(this.maxParticles * 6), 3);",
                    "        this.previousBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('previous', this.previousBuffer);",
                    "        this.nextBuffer = new THREE.BufferAttribute(new Float32Array(this.maxParticles * 6), 3);",
                    "        this.nextBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('next', this.nextBuffer);",
                    "        this.widthBuffer = new THREE.BufferAttribute(new Float32Array(this.maxParticles * 2), 1);",
                    "        this.widthBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('width', this.widthBuffer);",
                    "        this.sideBuffer = new THREE.BufferAttribute(new Float32Array(this.maxParticles * 2), 1);",
                    "        this.sideBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('side', this.sideBuffer);",
                    "        this.uvBuffer = new THREE.BufferAttribute(new Float32Array(this.maxParticles * 4), 2);",
                    "        this.uvBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('uv', this.uvBuffer);",
                    "        this.colorBuffer = new THREE.BufferAttribute(new Float32Array(this.maxParticles * 8), 4);",
                    "        this.colorBuffer.setUsage(THREE.DynamicDrawUsage);",
                    "        this.geometry.setAttribute('color', this.colorBuffer);",
                    "    }",
                    "    expandBuffers(target) {",
                    "        while (target >= this.maxParticles) {",
                    "            this.maxParticles *= 2;",
                    "        }",
                    "        this.setupBuffers();",
                    "    }",
                    "    rebuildMaterial() {",
                    "        this.layers.mask = this.settings.layers.mask;",
                    "        const uniforms = {",
                    "            lineWidth: { value: 1 },",
                    "            map: { value: null },",
                    "            useMap: { value: 0 },",
                    "            alphaMap: { value: null },",
                    "            useAlphaMap: { value: 0 },",
                    "            resolution: { value: new THREE.Vector2(1, 1) },",
                    "            sizeAttenuation: { value: 1 },",
                    "            visibility: { value: 1 },",
                    "            alphaTest: { value: 0 },",
                    "            repeat: { value: new THREE.Vector2(1, 1) },",
                    "        };",
                    "        const defines = {};",
                    "        defines['USE_UV'] = '';",
                    "        defines['USE_COLOR_ALPHA'] = '';",
                    "        if (this.settings.material.map) {",
                    "            defines['USE_MAP'] = '';",
                    "            defines['MAP_UV'] = getMaterialUVChannelName(this.settings.material.map.channel);",
                    "            uniforms['map'] = new THREE.Uniform(this.settings.material.map);",
                    "            uniforms['mapTransform'] = new THREE.Uniform(new THREE.Matrix3().copy(this.settings.material.map.matrix));",
                    "        }",
                    "        if (this.settings.material.defines &&",
                    "            this.settings.material.defines['USE_COLOR_AS_ALPHA'] !== undefined) {",
                    "            defines['USE_COLOR_AS_ALPHA'] = '';",
                    "        }",
                    "        if (this.settings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "            this.material = new THREE.ShaderMaterial({",
                    "                uniforms: uniforms,",
                    "                defines: defines,",
                    "                vertexShader: trail_vert,",
                    "                fragmentShader: trail_frag,",
                    "                transparent: this.settings.material.transparent,",
                    "                depthWrite: !this.settings.material.transparent,",
                    "                side: this.settings.material.side,",
                    "                blending: this.settings.material.blending || THREE.AdditiveBlending,",
                    "            });",
                    "        }",
                    "        else {",
                    "            throw new Error('render mode unavailable');",
                    "        }",
                    "    }",
                    "    update() {",
                    "        let index = 0;",
                    "        let triangles = 0;",
                    "        let particleCount = 0;",
                    "        this.systems.forEach((system) => {",
                    "            for (let j = 0; j < system.particleNum; j++) {",
                    "                particleCount += system.particles[j].previous.length * 2;",
                    "            }",
                    "        });",
                    "        if (particleCount > this.maxParticles) {",
                    "            this.expandBuffers(particleCount);",
                    "        }",
                    "        this.systems.forEach((system) => {",
                    "            const rotation = this.quaternion_;",
                    "            const translation = this.vector2_;",
                    "            const scale = this.vector3_;",
                    "            system.emitter.matrixWorld.decompose(translation, rotation, scale);",
                    "            const particles = system.particles;",
                    "            const particleNum = system.particleNum;",
                    "            const uTileCount = this.settings.uTileCount;",
                    "            const vTileCount = this.settings.vTileCount;",
                    "            const tileWidth = 1 / uTileCount;",
                    "            const tileHeight = 1 / vTileCount;",
                    "            for (let j = 0; j < particleNum; j++) {",
                    "                const particle = particles[j];",
                    "                const col = particle.uvTile % vTileCount;",
                    "                const row = Math.floor(particle.uvTile / vTileCount + 0.001);",
                    "                const iter = particle.previous.values();",
                    "                let curIter = iter.next();",
                    "                let previous = curIter.value;",
                    "                let current = previous;",
                    "                if (!curIter.done)",
                    "                    curIter = iter.next();",
                    "                let next;",
                    "                if (curIter.value !== undefined) {",
                    "                    next = curIter.value;",
                    "                }",
                    "                else {",
                    "                    next = current;",
                    "                }",
                    "                for (let i = 0; i < particle.previous.length; i++ , index += 2) {",
                    "                    this.positionBuffer.setXYZ(index, current.position.x, current.position.y, current.position.z);",
                    "                    this.positionBuffer.setXYZ(index + 1, current.position.x, current.position.y, current.position.z);",
                    "                    if (system.worldSpace) {",
                    "                        this.positionBuffer.setXYZ(index, current.position.x, current.position.y, current.position.z);",
                    "                        this.positionBuffer.setXYZ(index + 1, current.position.x, current.position.y, current.position.z);",
                    "                    }",
                    "                    else {",
                    "                        if (particle.parentMatrix) {",
                    "                            this.vector_.copy(current.position).applyMatrix4(particle.parentMatrix);",
                    "                        }",
                    "                        else {",
                    "                            this.vector_.copy(current.position).applyMatrix4(system.emitter.matrixWorld);",
                    "                        }",
                    "                        this.positionBuffer.setXYZ(index, this.vector_.x, this.vector_.y, this.vector_.z);",
                    "                        this.positionBuffer.setXYZ(index + 1, this.vector_.x, this.vector_.y, this.vector_.z);",
                    "                    }",
                    "                    if (system.worldSpace) {",
                    "                        this.previousBuffer.setXYZ(index, previous.position.x, previous.position.y, previous.position.z);",
                    "                        this.previousBuffer.setXYZ(index + 1, previous.position.x, previous.position.y, previous.position.z);",
                    "                    }",
                    "                    else {",
                    "                        if (particle.parentMatrix) {",
                    "                            this.vector_.copy(previous.position).applyMatrix4(particle.parentMatrix);",
                    "                        }",
                    "                        else {",
                    "                            this.vector_.copy(previous.position).applyMatrix4(system.emitter.matrixWorld);",
                    "                        }",
                    "                        this.previousBuffer.setXYZ(index, this.vector_.x, this.vector_.y, this.vector_.z);",
                    "                        this.previousBuffer.setXYZ(index + 1, this.vector_.x, this.vector_.y, this.vector_.z);",
                    "                    }",
                    "                    if (system.worldSpace) {",
                    "                        this.nextBuffer.setXYZ(index, next.position.x, next.position.y, next.position.z);",
                    "                        this.nextBuffer.setXYZ(index + 1, next.position.x, next.position.y, next.position.z);",
                    "                    }",
                    "                    else {",
                    "                        if (particle.parentMatrix) {",
                    "                            this.vector_.copy(next.position).applyMatrix4(particle.parentMatrix);",
                    "                        }",
                    "                        else {",
                    "                            this.vector_.copy(next.position).applyMatrix4(system.emitter.matrixWorld);",
                    "                        }",
                    "                        this.nextBuffer.setXYZ(index, this.vector_.x, this.vector_.y, this.vector_.z);",
                    "                        this.nextBuffer.setXYZ(index + 1, this.vector_.x, this.vector_.y, this.vector_.z);",
                    "                    }",
                    "                    this.sideBuffer.setX(index, -1);",
                    "                    this.sideBuffer.setX(index + 1, 1);",
                    "                    if (system.worldSpace) {",
                    "                        this.widthBuffer.setX(index, current.size);",
                    "                        this.widthBuffer.setX(index + 1, current.size);",
                    "                    }",
                    "                    else {",
                    "                        if (particle.parentMatrix) {",
                    "                            this.widthBuffer.setX(index, current.size);",
                    "                            this.widthBuffer.setX(index + 1, current.size);",
                    "                        }",
                    "                        else {",
                    "                            const objectScale = (Math.abs(scale.x) + Math.abs(scale.y) + Math.abs(scale.z)) / 3;",
                    "                            this.widthBuffer.setX(index, current.size * objectScale);",
                    "                            this.widthBuffer.setX(index + 1, current.size * objectScale);",
                    "                        }",
                    "                    }",
                    "                    this.uvBuffer.setXY(index, (i / particle.previous.length + col) * tileWidth, (vTileCount - row - 1) * tileHeight);",
                    "                    this.uvBuffer.setXY(index + 1, (i / particle.previous.length + col) * tileWidth, (vTileCount - row) * tileHeight);",
                    "                    this.colorBuffer.setXYZW(index, current.color.x, current.color.y, current.color.z, current.color.w);",
                    "                    this.colorBuffer.setXYZW(index + 1, current.color.x, current.color.y, current.color.z, current.color.w);",
                    "                    if (i + 1 < particle.previous.length) {",
                    "                        this.indexBuffer.setX(triangles * 3, index);",
                    "                        this.indexBuffer.setX(triangles * 3 + 1, index + 1);",
                    "                        this.indexBuffer.setX(triangles * 3 + 2, index + 2);",
                    "                        triangles++;",
                    "                        this.indexBuffer.setX(triangles * 3, index + 2);",
                    "                        this.indexBuffer.setX(triangles * 3 + 1, index + 1);",
                    "                        this.indexBuffer.setX(triangles * 3 + 2, index + 3);",
                    "                        triangles++;",
                    "                    }",
                    "                    previous = current;",
                    "                    current = next;",
                    "                    if (!curIter.done) {",
                    "                        curIter = iter.next();",
                    "                        if (curIter.value !== undefined) {",
                    "                            next = curIter.value;",
                    "                        }",
                    "                    }",
                    "                }",
                    "            }",
                    "        });",
                    "        this.positionBuffer.updateRange.count = index * 3;",
                    "        this.positionBuffer.needsUpdate = true;",
                    "        this.previousBuffer.updateRange.count = index * 3;",
                    "        this.previousBuffer.needsUpdate = true;",
                    "        this.nextBuffer.updateRange.count = index * 3;",
                    "        this.nextBuffer.needsUpdate = true;",
                    "        this.sideBuffer.updateRange.count = index;",
                    "        this.sideBuffer.needsUpdate = true;",
                    "        this.widthBuffer.updateRange.count = index;",
                    "        this.widthBuffer.needsUpdate = true;",
                    "        this.uvBuffer.updateRange.count = index * 2;",
                    "        this.uvBuffer.needsUpdate = true;",
                    "        this.colorBuffer.updateRange.count = index * 4;",
                    "        this.colorBuffer.needsUpdate = true;",
                    "        this.indexBuffer.updateRange.count = triangles * 3;",
                    "        this.indexBuffer.needsUpdate = true;",
                    "        this.geometry.setDrawRange(0, triangles * 3);",
                    "    }",
                    "    dispose() {",
                    "        this.geometry.dispose();",
                    "    }",
                    "}",
                    "",
                    "class BatchedRenderer extends THREE.Object3D {",
                    "    constructor() {",
                    "        super();",
                    "        this.batches = [];",
                    "        this.systemToBatchIndex = new Map();",
                    "        this.type = 'BatchedRenderer';",
                    "    }",
                    "    static equals(a, b) {",
                    "        return (a.material.side === b.material.side &&",
                    "            a.material.blending === b.material.blending &&",
                    "            a.material.transparent === b.material.transparent &&",
                    "            a.material.type === b.material.type &&",
                    "            a.material.alphaTest === b.material.alphaTest &&",
                    "            a.material.map === b.material.map &&",
                    "            a.renderMode === b.renderMode &&",
                    "            a.uTileCount === b.uTileCount &&",
                    "            a.vTileCount === b.vTileCount &&",
                    "            a.instancingGeometry === b.instancingGeometry &&",
                    "            a.renderOrder === b.renderOrder &&",
                    "            a.layers.mask === b.layers.mask);",
                    "    }",
                    "    addSystem(system) {",
                    "        system._renderer = this;",
                    "        const settings = system.getRendererSettings();",
                    "        for (let i = 0; i < this.batches.length; i++) {",
                    "            if (BatchedRenderer.equals(this.batches[i].settings, settings)) {",
                    "                this.batches[i].addSystem(system);",
                    "                this.systemToBatchIndex.set(system, i);",
                    "                return;",
                    "            }",
                    "        }",
                    "        let batch;",
                    "        switch (settings.renderMode) {",
                    "            case gdjs.__particleEmmiter3DExtension.RenderMode.Trail:",
                    "                batch = new TrailBatch(settings);",
                    "                break;",
                    "            case gdjs.__particleEmmiter3DExtension.RenderMode.Mesh:",
                    "            case gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard:",
                    "            case gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard:",
                    "            case gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard:",
                    "            case gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard:",
                    "                batch = new SpriteBatch(settings);",
                    "                break;",
                    "        }",
                    "        batch.addSystem(system);",
                    "        this.batches.push(batch);",
                    "        this.systemToBatchIndex.set(system, this.batches.length - 1);",
                    "        this.add(batch);",
                    "    }",
                    "    deleteSystem(system) {",
                    "        const batchIndex = this.systemToBatchIndex.get(system);",
                    "        if (batchIndex != undefined) {",
                    "            this.batches[batchIndex].removeSystem(system);",
                    "            this.systemToBatchIndex.delete(system);",
                    "        }",
                    "    }",
                    "    updateSystem(system) {",
                    "        this.deleteSystem(system);",
                    "        this.addSystem(system);",
                    "    }",
                    "    update(delta) {",
                    "        this.systemToBatchIndex.forEach((value, ps) => {",
                    "            ps.update(delta);",
                    "        });",
                    "        for (let i = 0; i < this.batches.length; i++) {",
                    "            this.batches[i].update();",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "const BatchedParticleRenderer = BatchedRenderer;",
                    "",
                    "class QuarksLoader extends THREE.ObjectLoader {",
                    "    constructor(manager) {",
                    "        super(manager);",
                    "    }",
                    "    linkReference(object) {",
                    "        const objectsMap = {};",
                    "        object.traverse(function (child) {",
                    "            objectsMap[child.uuid] = child;",
                    "        });",
                    "        object.traverse(function (child) {",
                    "            if (child.type === 'ParticleEmitter') {",
                    "                const system = child.system;",
                    "                system.emitterShape;",
                    "                for (let i = 0; i < system.behaviors.length; i++) {",
                    "                    if (system.behaviors[i] instanceof EmitSubParticleSystem) {",
                    "                        system.behaviors[i].subParticleSystem = objectsMap[system.behaviors[i].subParticleSystem];",
                    "                    }",
                    "                }",
                    "            }",
                    "        });",
                    "    }",
                    "    parse(json, onLoad) {",
                    "        const object = super.parse(json, onLoad);",
                    "        this.linkReference(object);",
                    "        return object;",
                    "    }",
                    "    parseObject(data, geometries, materials, textures, animations) {",
                    "        let object;",
                    "        function getGeometry(name) {",
                    "            if (geometries[name] === undefined) {",
                    "                console.warn('THREE.ObjectLoader: Undefined geometry', name);",
                    "            }",
                    "            return geometries[name];",
                    "        }",
                    "        function getMaterial(name) {",
                    "            if (name === undefined)",
                    "                return undefined;",
                    "            if (Array.isArray(name)) {",
                    "                const array = [];",
                    "                for (let i = 0, l = name.length; i < l; i++) {",
                    "                    const uuid = name[i];",
                    "                    if (materials[uuid] === undefined) {",
                    "                        console.warn('THREE.ObjectLoader: Undefined material', uuid);",
                    "                    }",
                    "                    array.push(materials[uuid]);",
                    "                }",
                    "                return array;",
                    "            }",
                    "            if (materials[name] === undefined) {",
                    "                console.warn('THREE.ObjectLoader: Undefined material', name);",
                    "            }",
                    "            return materials[name];",
                    "        }",
                    "        function getTexture(uuid) {",
                    "            if (textures[uuid] === undefined) {",
                    "                console.warn('THREE.ObjectLoader: Undefined texture', uuid);",
                    "            }",
                    "            return textures[uuid];",
                    "        }",
                    "        let geometry, material;",
                    "        const meta = {",
                    "            textures: textures,",
                    "            geometries: geometries,",
                    "            materials: materials,",
                    "        };",
                    "        const dependencies = {};",
                    "        switch (data.type) {",
                    "            case 'ParticleEmitter':",
                    "                object = ParticleSystem.fromJSON(data.ps, meta, dependencies).emitter;",
                    "                break;",
                    "            case 'Scene':",
                    "                object = new THREE.Scene();",
                    "                if (data.background !== undefined) {",
                    "                    if (Number.isInteger(data.background)) {",
                    "                        object.background = new THREE.Color(data.background);",
                    "                    }",
                    "                    else {",
                    "                        object.background = getTexture(data.background);",
                    "                    }",
                    "                }",
                    "                if (data.environment !== undefined) {",
                    "                    object.environment = getTexture(data.environment);",
                    "                }",
                    "                if (data.fog !== undefined) {",
                    "                    if (data.fog.type === 'Fog') {",
                    "                        object.fog = new THREE.Fog(data.fog.color, data.fog.near, data.fog.far);",
                    "                    }",
                    "                    else if (data.fog.type === 'FogExp2') {",
                    "                        object.fog = new THREE.FogExp2(data.fog.color, data.fog.density);",
                    "                    }",
                    "                }",
                    "                if (data.backgroundBlurriness !== undefined)",
                    "                    object.backgroundBlurriness = data.backgroundBlurriness;",
                    "                break;",
                    "            case 'PerspectiveCamera':",
                    "                object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);",
                    "                if (data.focus !== undefined)",
                    "                    object.focus = data.focus;",
                    "                if (data.zoom !== undefined)",
                    "                    object.zoom = data.zoom;",
                    "                if (data.filmGauge !== undefined)",
                    "                    object.filmGauge = data.filmGauge;",
                    "                if (data.filmOffset !== undefined)",
                    "                    object.filmOffset = data.filmOffset;",
                    "                if (data.view !== undefined)",
                    "                    object.view = Object.assign({}, data.view);",
                    "                break;",
                    "            case 'OrthographicCamera':",
                    "                object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);",
                    "                if (data.zoom !== undefined)",
                    "                    object.zoom = data.zoom;",
                    "                if (data.view !== undefined)",
                    "                    object.view = Object.assign({}, data.view);",
                    "                break;",
                    "            case 'AmbientLight':",
                    "                object = new THREE.AmbientLight(data.color, data.intensity);",
                    "                break;",
                    "            case 'DirectionalLight':",
                    "                object = new THREE.DirectionalLight(data.color, data.intensity);",
                    "                break;",
                    "            case 'PointLight':",
                    "                object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);",
                    "                break;",
                    "            case 'RectAreaLight':",
                    "                object = new THREE.RectAreaLight(data.color, data.intensity, data.width, data.height);",
                    "                break;",
                    "            case 'SpotLight':",
                    "                object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);",
                    "                break;",
                    "            case 'HemisphereLight':",
                    "                object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);",
                    "                break;",
                    "            case 'LightProbe':",
                    "                object = new THREE.LightProbe().fromJSON(data);",
                    "                break;",
                    "            case 'SkinnedMesh':",
                    "                geometry = getGeometry(data.geometry);",
                    "                material = getMaterial(data.material);",
                    "                object = new THREE.SkinnedMesh(geometry, material);",
                    "                if (data.bindMode !== undefined)",
                    "                    object.bindMode = data.bindMode;",
                    "                if (data.bindMatrix !== undefined)",
                    "                    object.bindMatrix.fromArray(data.bindMatrix);",
                    "                if (data.skeleton !== undefined)",
                    "                    object.skeleton = data.skeleton;",
                    "                break;",
                    "            case 'Mesh':",
                    "                geometry = getGeometry(data.geometry);",
                    "                material = getMaterial(data.material);",
                    "                object = new THREE.Mesh(geometry, material);",
                    "                break;",
                    "            case 'InstancedMesh': {",
                    "                geometry = getGeometry(data.geometry);",
                    "                material = getMaterial(data.material);",
                    "                const count = data.count;",
                    "                const instanceMatrix = data.instanceMatrix;",
                    "                const instanceColor = data.instanceColor;",
                    "                object = new THREE.InstancedMesh(geometry, material, count);",
                    "                object.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);",
                    "                if (instanceColor !== undefined)",
                    "                    object.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);",
                    "                break;",
                    "            }",
                    "            case 'LOD':",
                    "                object = new THREE.LOD();",
                    "                break;",
                    "            case 'Line':",
                    "                object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material));",
                    "                break;",
                    "            case 'LineLoop':",
                    "                object = new THREE.LineLoop(getGeometry(data.geometry), getMaterial(data.material));",
                    "                break;",
                    "            case 'LineSegments':",
                    "                object = new THREE.LineSegments(getGeometry(data.geometry), getMaterial(data.material));",
                    "                break;",
                    "            case 'PointCloud':",
                    "            case 'Points':",
                    "                object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));",
                    "                break;",
                    "            case 'Sprite':",
                    "                object = new THREE.Sprite(getMaterial(data.material));",
                    "                break;",
                    "            case 'Group':",
                    "                object = new THREE.Group();",
                    "                break;",
                    "            case 'Bone':",
                    "                object = new THREE.Bone();",
                    "                break;",
                    "            default:",
                    "                object = new THREE.Object3D();",
                    "        }",
                    "        object.uuid = data.uuid;",
                    "        if (data.name !== undefined)",
                    "            object.name = data.name;",
                    "        if (data.matrix !== undefined) {",
                    "            object.matrix.fromArray(data.matrix);",
                    "            if (data.matrixAutoUpdate !== undefined)",
                    "                object.matrixAutoUpdate = data.matrixAutoUpdate;",
                    "            if (object.matrixAutoUpdate)",
                    "                object.matrix.decompose(object.position, object.quaternion, object.scale);",
                    "        }",
                    "        else {",
                    "            if (data.position !== undefined)",
                    "                object.position.fromArray(data.position);",
                    "            if (data.rotation !== undefined)",
                    "                object.rotation.fromArray(data.rotation);",
                    "            if (data.quaternion !== undefined)",
                    "                object.quaternion.fromArray(data.quaternion);",
                    "            if (data.scale !== undefined)",
                    "                object.scale.fromArray(data.scale);",
                    "        }",
                    "        if (data.castShadow !== undefined)",
                    "            object.castShadow = data.castShadow;",
                    "        if (data.receiveShadow !== undefined)",
                    "            object.receiveShadow = data.receiveShadow;",
                    "        if (data.shadow) {",
                    "            if (data.shadow.bias !== undefined)",
                    "                object.shadow.bias = data.shadow.bias;",
                    "            if (data.shadow.normalBias !== undefined)",
                    "                object.normalBias = data.shadow.normalBias;",
                    "            if (data.shadow.radius !== undefined)",
                    "                object.radius = data.shadow.radius;",
                    "            if (data.shadow.mapSize !== undefined)",
                    "                object.mapSize.fromArray(data.shadow.mapSize);",
                    "            if (data.shadow.camera !== undefined) {",
                    "                object.camera = this.parseObject(data.shadow.camera);",
                    "            }",
                    "        }",
                    "        if (data.visible !== undefined)",
                    "            object.visible = data.visible;",
                    "        if (data.frustumCulled !== undefined)",
                    "            object.frustumCulled = data.frustumCulled;",
                    "        if (data.renderOrder !== undefined)",
                    "            object.renderOrder = data.renderOrder;",
                    "        if (data.userData !== undefined)",
                    "            object.userData = data.userData;",
                    "        if (data.layers !== undefined)",
                    "            object.layers.mask = data.layers;",
                    "        if (data.children !== undefined) {",
                    "            const children = data.children;",
                    "            for (let i = 0; i < children.length; i++) {",
                    "                object.add(this.parseObject(children[i], geometries, materials, textures, animations));",
                    "            }",
                    "        }",
                    "        if (data.animations !== undefined) {",
                    "            const objectAnimations = data.animations;",
                    "            for (let i = 0; i < objectAnimations.length; i++) {",
                    "                const uuid = objectAnimations[i];",
                    "                object.animations.push(animations[uuid]);",
                    "            }",
                    "        }",
                    "        if (data.type === 'LOD') {",
                    "            if (data.autoUpdate !== undefined)",
                    "                object.autoUpdate = data.autoUpdate;",
                    "            const levels = data.levels;",
                    "            for (let l = 0; l < levels.length; l++) {",
                    "                const level = levels[l];",
                    "                const child = object.getObjectByProperty('uuid', level.object);",
                    "                if (child !== undefined) {",
                    "                    object.addLevel(child, level.distance);",
                    "                }",
                    "            }",
                    "        }",
                    "        return object;",
                    "    }",
                    "}",
                    "",
                    "const Plugins = [];",
                    "function loadPlugin(plugin) {",
                    "    const existing = Plugins.find((item) => item.id === plugin.id);",
                    "    if (!existing) {",
                    "        plugin.initialize();",
                    "        for (const emitterShape of plugin.emitterShapes) {",
                    "            if (!EmitterShapes[emitterShape.type]) {",
                    "                EmitterShapes[emitterShape.type] = emitterShape;",
                    "            }",
                    "        }",
                    "        for (const behavior of plugin.behaviors) {",
                    "            if (!BehaviorTypes[behavior.type]) {",
                    "                BehaviorTypes[behavior.type] = behavior;",
                    "            }",
                    "        }",
                    "    }",
                    "}",
                    "function unloadPlugin(pluginId) {",
                    "    const plugin = Plugins.find((item) => item.id === pluginId);",
                    "    if (plugin) {",
                    "        for (const emitterShape of plugin.emitterShapes) {",
                    "            if (EmitterShapes[emitterShape.type]) {",
                    "                delete EmitterShapes[emitterShape.type];",
                    "            }",
                    "        }",
                    "        for (const behavior of plugin.behaviors) {",
                    "            if (BehaviorTypes[behavior.type]) {",
                    "                delete BehaviorTypes[behavior.type];",
                    "            }",
                    "        }",
                    "    }",
                    "}",
                    "",
                    "gdjs.__particleEmmiter3DExtension.NodeValueType = void 0;",
                    "(function (NodeValueType) {",
                    "    NodeValueType[NodeValueType[\"Number\"] = 0] = \"Number\";",
                    "    NodeValueType[NodeValueType[\"Vec2\"] = 1] = \"Vec2\";",
                    "    NodeValueType[NodeValueType[\"Vec3\"] = 2] = \"Vec3\";",
                    "    NodeValueType[NodeValueType[\"Vec4\"] = 3] = \"Vec4\";",
                    "    NodeValueType[NodeValueType[\"Boolean\"] = 4] = \"Boolean\";",
                    "    NodeValueType[NodeValueType[\"AnyType\"] = 5] = \"AnyType\";",
                    "    NodeValueType[NodeValueType[\"NullableAnyType\"] = 6] = \"NullableAnyType\";",
                    "    NodeValueType[NodeValueType[\"EventStream\"] = 7] = \"EventStream\";",
                    "})(gdjs.__particleEmmiter3DExtension.NodeValueType || (gdjs.__particleEmmiter3DExtension.NodeValueType = {}));",
                    "const genDefaultForNodeValueType = (type) => {",
                    "    switch (type) {",
                    "        case gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean:",
                    "            return false;",
                    "        case gdjs.__particleEmmiter3DExtension.NodeValueType.Number:",
                    "            return 0;",
                    "        case gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2:",
                    "            return new THREE.Vector2();",
                    "        case gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3:",
                    "            return new THREE.Vector3();",
                    "        case gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4:",
                    "            return new THREE.Vector4();",
                    "        case gdjs.__particleEmmiter3DExtension.NodeValueType.AnyType:",
                    "            return 0;",
                    "        case gdjs.__particleEmmiter3DExtension.NodeValueType.NullableAnyType:",
                    "            return undefined;",
                    "    }",
                    "};",
                    "",
                    "class Node {",
                    "    constructor(type, signatureIndex = -1, data = {}) {",
                    "        this.inputs = [];",
                    "        this.outputs = [];",
                    "        this.signatureIndex = -1;",
                    "        this.position = new THREE.Vector2();",
                    "        this.outputValues = [];",
                    "        this.id = '' + Math.round(Math.random() * 100000);",
                    "        this.type = type;",
                    "        this.signatureIndex = signatureIndex;",
                    "        this.data = data;",
                    "        const realIndex = signatureIndex === -1 ? 0 : signatureIndex;",
                    "        for (let i = 0; i < type.nodeTypeSignatures[realIndex].inputTypes.length; i++) {",
                    "            this.inputs.push(undefined);",
                    "        }",
                    "        for (let i = 0; i < type.nodeTypeSignatures[realIndex].outputTypes.length; i++) {",
                    "            this.outputs.push([]);",
                    "            this.outputValues.push(genDefaultForNodeValueType(type.nodeTypeSignatures[realIndex].outputTypes[i]));",
                    "        }",
                    "    }",
                    "    get inputTypes() {",
                    "        const signatureIndex = this.signatureIndex === -1 ? 0 : this.signatureIndex;",
                    "        return this.type.nodeTypeSignatures[signatureIndex].inputTypes;",
                    "    }",
                    "    get outputTypes() {",
                    "        const signatureIndex = this.signatureIndex === -1 ? 0 : this.signatureIndex;",
                    "        return this.type.nodeTypeSignatures[signatureIndex].outputTypes;",
                    "    }",
                    "    func(context, inputs, outputs) {",
                    "        const signatureIndex = this.signatureIndex === -1 ? 0 : this.signatureIndex;",
                    "        this.type.nodeTypeSignatures[signatureIndex].func(context, this.data, inputs, outputs);",
                    "    }",
                    "}",
                    "class Wire {",
                    "    constructor(input, inputIndex, output, outputIndex) {",
                    "        this.input = input;",
                    "        this.inputIndex = inputIndex;",
                    "        this.input.outputs[inputIndex].push(this);",
                    "        this.output = output;",
                    "        this.outputIndex = outputIndex;",
                    "        this.output.inputs[outputIndex] = this;",
                    "    }",
                    "}",
                    "",
                    "class BaseCompiler {",
                    "    constructor() {",
                    "        this.visited = new Set();",
                    "        BaseCompiler.Instance = this;",
                    "    }",
                    "    buildExecutionOrder(graph, context) {",
                    "        graph.nodesInOrder.length = 0;",
                    "        this.visited.clear();",
                    "        for (let i = 0; i < graph.outputNodes.length; i++) {",
                    "            const node = graph.outputNodes[i];",
                    "            if (node.inputs[0] !== undefined) {",
                    "                this._traverse(node, graph, context);",
                    "            }",
                    "        }",
                    "        graph.compiled = true;",
                    "    }",
                    "    _traverse(node, graph, context) {",
                    "        this.visited.add(node.id);",
                    "        for (let i = 0; i < node.inputs.length; i++) {",
                    "            if (node.inputs[i] instanceof Wire) {",
                    "                const inputNode = node.inputs[i].input;",
                    "                if (!this.visited.has(inputNode.id)) {",
                    "                    this._traverse(inputNode, graph, context);",
                    "                }",
                    "            }",
                    "            else if (node.inputs[i] !== undefined);",
                    "            else;",
                    "        }",
                    "        graph.nodesInOrder.push(node);",
                    "    }",
                    "}",
                    "",
                    "class Interpreter extends BaseCompiler {",
                    "    constructor() {",
                    "        super();",
                    "    }",
                    "    executeCompiledGraph(graph, context) {",
                    "        const nodes = graph.nodesInOrder;",
                    "        for (let i = 0; i < nodes.length; i++) {",
                    "            const inputValues = [];",
                    "            const node = nodes[i];",
                    "            for (let j = 0; j < node.inputs.length; j++) {",
                    "                if (node.inputs[j] instanceof Wire) {",
                    "                    inputValues.push(node.inputs[j].input.outputValues[node.inputs[j].inputIndex]);",
                    "                }",
                    "                else if (node.inputs[j] !== undefined) {",
                    "                    inputValues.push(node.inputs[j].getValue(context));",
                    "                }",
                    "                else {",
                    "                    inputValues.push(undefined);",
                    "                }",
                    "            }",
                    "            node.func(context, inputValues, node.outputValues);",
                    "        }",
                    "    }",
                    "    run(graph, context) {",
                    "        if (!graph.compiled) {",
                    "            this.buildExecutionOrder(graph, context);",
                    "        }",
                    "        this.executeCompiledGraph(graph, context);",
                    "    }",
                    "}",
                    "",
                    "class NodeType {",
                    "    constructor(name) {",
                    "        this.nodeTypeSignatures = [];",
                    "        this.name = name;",
                    "    }",
                    "    addSignature(inputTypes, outputTypes, func) {",
                    "        this.nodeTypeSignatures.push({",
                    "            inputTypes: inputTypes,",
                    "            outputTypes: outputTypes,",
                    "            func: func,",
                    "        });",
                    "    }",
                    "}",
                    "class GraphNodeType extends NodeType {",
                    "    constructor(nodeGraph) {",
                    "        const inputTypes = [];",
                    "        for (let i = 0; i < nodeGraph.inputNodes.length; i++) {",
                    "            if (nodeGraph.inputNodes[i].type.name === 'input') {",
                    "                inputTypes.push(nodeGraph.inputNodes[i].data.type);",
                    "            }",
                    "        }",
                    "        const outputTypes = [];",
                    "        for (let i = 0; i < nodeGraph.outputNodes.length; i++) {",
                    "            if (nodeGraph.outputNodes[i].type.name === 'output') {",
                    "                outputTypes.push(nodeGraph.outputNodes[i].data.type);",
                    "            }",
                    "        }",
                    "        super(nodeGraph.name);",
                    "        this.addSignature(inputTypes, outputTypes, (context, data, inputs, outputs) => {",
                    "            context.inputs = inputs;",
                    "            context.outputs = outputs;",
                    "            Interpreter.Instance.run(nodeGraph, context);",
                    "        });",
                    "        this.nodeGraph = nodeGraph;",
                    "    }",
                    "}",
                    "",
                    "const NodeTypes = {};",
                    "const addNode = new NodeType('add');",
                    "addNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] + inputs[1];",
                    "});",
                    "addNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0].addVectors(inputs[0], inputs[1]);",
                    "});",
                    "addNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].addVectors(inputs[0], inputs[1]);",
                    "});",
                    "addNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0].addVectors(inputs[0], inputs[1]);",
                    "});",
                    "NodeTypes['add'] = addNode;",
                    "const subNode = new NodeType('sub');",
                    "subNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] - inputs[1];",
                    "});",
                    "subNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0].subVectors(inputs[0], inputs[1]);",
                    "});",
                    "subNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].subVectors(inputs[0], inputs[1]);",
                    "});",
                    "subNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0].subVectors(inputs[0], inputs[1]);",
                    "});",
                    "NodeTypes['sub'] = subNode;",
                    "const mulNode = new NodeType('mul');",
                    "mulNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] * inputs[1];",
                    "});",
                    "mulNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).multiplyScalar(inputs[1]);",
                    "});",
                    "mulNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).multiplyScalar(inputs[1]);",
                    "});",
                    "mulNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).multiplyScalar(inputs[1]);",
                    "});",
                    "NodeTypes['mul'] = mulNode;",
                    "const divNode = new NodeType('div');",
                    "divNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] / inputs[1];",
                    "});",
                    "divNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).divideScalar(inputs[1]);",
                    "});",
                    "divNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).divideScalar(inputs[1]);",
                    "});",
                    "divNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).divideScalar(inputs[1]);",
                    "});",
                    "NodeTypes['div'] = divNode;",
                    "const sinNode = new NodeType('sin');",
                    "sinNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.sin(inputs[0]);",
                    "});",
                    "NodeTypes['sin'] = sinNode;",
                    "const cosNode = new NodeType('cos');",
                    "cosNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.cos(inputs[0]);",
                    "});",
                    "NodeTypes['cos'] = cosNode;",
                    "const tanNode = new NodeType('tan');",
                    "tanNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.tan(inputs[0]);",
                    "});",
                    "NodeTypes['tan'] = tanNode;",
                    "const absNode = new NodeType('abs');",
                    "absNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.abs(inputs[0]);",
                    "});",
                    "NodeTypes['abs'] = absNode;",
                    "const minNode = new NodeType('min');",
                    "minNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.min(inputs[0], inputs[1]);",
                    "});",
                    "NodeTypes['min'] = minNode;",
                    "const maxNode = new NodeType('max');",
                    "maxNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.max(inputs[0], inputs[1]);",
                    "});",
                    "NodeTypes['max'] = maxNode;",
                    "const dot = new NodeType('dot');",
                    "dot.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].dot(inputs[1]);",
                    "});",
                    "dot.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].dot(inputs[1]);",
                    "});",
                    "dot.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].dot(inputs[1]);",
                    "});",
                    "NodeTypes['dot'] = dot;",
                    "const cross = new NodeType('cross');",
                    "cross.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].crossVectors(inputs[0], inputs[1]);",
                    "});",
                    "NodeTypes['cross'] = cross;",
                    "const length = new NodeType('length');",
                    "length.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].length();",
                    "});",
                    "length.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].length();",
                    "});",
                    "length.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].length();",
                    "});",
                    "NodeTypes['length'] = length;",
                    "const lengthSq = new NodeType('lengthSq');",
                    "lengthSq.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].lengthSq();",
                    "});",
                    "lengthSq.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].lengthSq();",
                    "});",
                    "lengthSq.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].lengthSq();",
                    "});",
                    "NodeTypes['lengthSq'] = lengthSq;",
                    "const normalize = new NodeType('normalize');",
                    "normalize.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).normalize();",
                    "});",
                    "normalize.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).normalize();",
                    "});",
                    "normalize.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0].copy(inputs[0]).normalize();",
                    "});",
                    "NodeTypes['normalize'] = normalize;",
                    "const distance = new NodeType('distance');",
                    "distance.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].distanceTo(inputs[1]);",
                    "});",
                    "distance.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].distanceTo(inputs[1]);",
                    "});",
                    "NodeTypes['distance'] = distance;",
                    "const andNode = new NodeType('and');",
                    "andNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean, gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] && inputs[1];",
                    "});",
                    "NodeTypes['and'] = andNode;",
                    "const orNode = new NodeType('or');",
                    "orNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean, gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] || inputs[1];",
                    "});",
                    "NodeTypes['or'] = orNode;",
                    "const notNode = new NodeType('not');",
                    "notNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = !inputs[0];",
                    "});",
                    "NodeTypes['not'] = notNode;",
                    "const equalNode = new NodeType('equal');",
                    "equalNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] === inputs[1];",
                    "});",
                    "equalNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].equals(inputs[1]);",
                    "});",
                    "equalNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].equals(inputs[1]);",
                    "});",
                    "equalNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].equals(inputs[1]);",
                    "});",
                    "NodeTypes['equal'] = equalNode;",
                    "const lessThanNode = new NodeType('lessThan');",
                    "lessThanNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] < inputs[1];",
                    "});",
                    "NodeTypes['lessThan'] = lessThanNode;",
                    "const greaterThanNode = new NodeType('greaterThan');",
                    "greaterThanNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] > inputs[1];",
                    "});",
                    "NodeTypes['greaterThan'] = greaterThanNode;",
                    "const lessThanOrEqualNode = new NodeType('lessThanOrEqual');",
                    "lessThanOrEqualNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] <= inputs[1];",
                    "});",
                    "NodeTypes['lessThanOrEqual'] = lessThanOrEqualNode;",
                    "const greaterThanOrEqualNode = new NodeType('greaterThanOrEqual');",
                    "greaterThanOrEqualNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] >= inputs[1];",
                    "});",
                    "NodeTypes['greaterThanOrEqual'] = greaterThanOrEqualNode;",
                    "const ifNode = new NodeType('if');",
                    "ifNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean, gdjs.__particleEmmiter3DExtension.NodeValueType.AnyType, gdjs.__particleEmmiter3DExtension.NodeValueType.AnyType], [gdjs.__particleEmmiter3DExtension.NodeValueType.AnyType], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0] ? inputs[1] : inputs[2];",
                    "});",
                    "NodeTypes['if'] = ifNode;",
                    "const numberNode = new NodeType('number');",
                    "numberNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = data.value;",
                    "});",
                    "NodeTypes['number'] = numberNode;",
                    "const vec2Node = new NodeType('vec2');",
                    "vec2Node.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0].x = inputs[0];",
                    "    outputs[0].y = inputs[1];",
                    "});",
                    "NodeTypes['vec2'] = vec2Node;",
                    "const vec3Node = new NodeType('vec3');",
                    "vec3Node.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].x = inputs[0];",
                    "    outputs[0].y = inputs[1];",
                    "    outputs[0].z = inputs[2];",
                    "});",
                    "NodeTypes['vec3'] = vec3Node;",
                    "const vec4Node = new NodeType('vec4');",
                    "vec4Node.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0].x = inputs[0];",
                    "    outputs[0].y = inputs[1];",
                    "    outputs[0].z = inputs[2];",
                    "    outputs[0].w = inputs[3];",
                    "});",
                    "NodeTypes['vec4'] = vec4Node;",
                    "const splitVec2Node = new NodeType('splitVec2');",
                    "splitVec2Node.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].x;",
                    "    outputs[1] = inputs[0].y;",
                    "});",
                    "NodeTypes['splitVec2'] = splitVec2Node;",
                    "const splitVec3Node = new NodeType('splitVec3');",
                    "splitVec3Node.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].x;",
                    "    outputs[1] = inputs[0].y;",
                    "    outputs[2] = inputs[0].z;",
                    "});",
                    "NodeTypes['splitVec3'] = splitVec3Node;",
                    "const splitVec4Node = new NodeType('splitVec4');",
                    "splitVec4Node.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0].x;",
                    "    outputs[1] = inputs[0].y;",
                    "    outputs[2] = inputs[0].z;",
                    "    outputs[3] = inputs[0].w;",
                    "});",
                    "NodeTypes['splitVec4'] = splitVec4Node;",
                    "const boolNode = new NodeType('bool');",
                    "boolNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = data.value;",
                    "});",
                    "NodeTypes['bool'] = boolNode;",
                    "const particlePropertyNode = new NodeType('particleProperty');",
                    "particlePropertyNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.NullableAnyType], [gdjs.__particleEmmiter3DExtension.NodeValueType.NullableAnyType], (context, data, inputs, outputs) => {",
                    "    if (inputs[0] !== undefined) {",
                    "        if (typeof inputs[0] === 'object') {",
                    "            context.particle[data.property].copy(inputs[0]);",
                    "        }",
                    "        else {",
                    "            context.particle[data.property] = inputs[0];",
                    "        }",
                    "    }",
                    "    if (context.particle[data.property] !== undefined) {",
                    "        if (typeof outputs[0] === 'object') {",
                    "            outputs[0].copy(context.particle[data.property]);",
                    "        }",
                    "        else {",
                    "            outputs[0] = context.particle[data.property];",
                    "        }",
                    "    }",
                    "});",
                    "NodeTypes['particleProperty'] = particlePropertyNode;",
                    "const emitNode = new NodeType('emit');",
                    "emitNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.EventStream], [], (context, data, inputs, outputs) => {",
                    "    const arr = inputs[0];",
                    "    for (let i = 0; i < arr.length; i++) {",
                    "        context.signal(i, arr[i]);",
                    "    }",
                    "});",
                    "NodeTypes['emit'] = emitNode;",
                    "const graphPropertyNode = new NodeType('graphProperty');",
                    "graphPropertyNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.NullableAnyType], [gdjs.__particleEmmiter3DExtension.NodeValueType.NullableAnyType], (context, data, inputs, outputs) => {",
                    "    if (inputs[0] !== undefined) {",
                    "        if (typeof inputs[0] === 'object') {",
                    "            context.graph[data.property].copy(inputs[0]);",
                    "        }",
                    "        else {",
                    "            context.graph[data.property] = inputs[0];",
                    "        }",
                    "    }",
                    "    if (context.graph[data.property] !== undefined) {",
                    "        if (typeof outputs[0] === 'object') {",
                    "            outputs[0].copy(context.graph[data.property]);",
                    "        }",
                    "        else {",
                    "            outputs[0] = context.graph[data.property];",
                    "        }",
                    "    }",
                    "});",
                    "NodeTypes['graphProperty'] = graphPropertyNode;",
                    "const startEventNode = new NodeType('startEvent');",
                    "startEventNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.EventStream], (context, data, inputs, outputs) => {",
                    "    outputs[0] = [{ type: 'start' }];",
                    "});",
                    "NodeTypes['startEvent'] = startEventNode;",
                    "const repeaterNode = new NodeType('repeater');",
                    "repeaterNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.EventStream, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.EventStream], (context, data, inputs, outputs) => {",
                    "    const arr = inputs[0];",
                    "    const count = inputs[1];",
                    "    const result = [];",
                    "    for (let j = 0; j < arr.length; j++) {",
                    "        for (let i = 0; i < count; i++) {",
                    "            result.push(arr[j]);",
                    "        }",
                    "    }",
                    "    outputs[0] = result;",
                    "});",
                    "NodeTypes['repeater'] = repeaterNode;",
                    "const timeNode = new NodeType('time');",
                    "timeNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = context.emissionState.time;",
                    "});",
                    "NodeTypes['time'] = timeNode;",
                    "const deltaNode = new NodeType('delta');",
                    "deltaNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = context.delta;",
                    "});",
                    "NodeTypes['delta'] = deltaNode;",
                    "const outputNode = new NodeType('output');",
                    "outputNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0];",
                    "});",
                    "outputNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0];",
                    "});",
                    "outputNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0];",
                    "});",
                    "outputNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0];",
                    "});",
                    "outputNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], [gdjs.__particleEmmiter3DExtension.NodeValueType.Boolean], (context, data, inputs, outputs) => {",
                    "    outputs[0] = inputs[0];",
                    "});",
                    "NodeTypes['output'] = outputNode;",
                    "const lerpNode = new NodeType('lerp');",
                    "lerpNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] =",
                    "        inputs[0] * (1 - inputs[2]) + inputs[1] * inputs[2];",
                    "});",
                    "lerpNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    outputs[0].lerpVectors(inputs[0], inputs[1], inputs[2]);",
                    "});",
                    "lerpNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    outputs[0].lerpVectors(inputs[0], inputs[1], inputs[2]);",
                    "});",
                    "lerpNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    outputs[0].lerpVectors(inputs[0], inputs[1], inputs[2]);",
                    "});",
                    "NodeTypes['lerp'] = lerpNode;",
                    "const normalD = (x) => {",
                    "    return (1 / Math.sqrt(2 * Math.PI)) * Math.exp(x * x * -0.5);",
                    "};",
                    "const normalDistributionNode = new NodeType('normDistrib');",
                    "normalDistributionNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = normalD(inputs[0]);",
                    "});",
                    "NodeTypes['normDistrib'] = normalDistributionNode;",
                    "const normcdfNode = new NodeType('normcdf');",
                    "normcdfNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    let x = inputs[0];",
                    "    const a1 = 0.254829592;",
                    "    const a2 = -0.284496736;",
                    "    const a3 = 1.421413741;",
                    "    const a4 = -1.453152027;",
                    "    const a5 = 1.061405429;",
                    "    const p = 0.3275911;",
                    "    let sign = 1;",
                    "    if (x < 0)",
                    "        sign = -1;",
                    "    x = Math.abs(x) / Math.sqrt(2.0);",
                    "    const t = 1.0 / (1.0 + p * x);",
                    "    const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);",
                    "    outputs[0] = 0.5 * (1.0 + sign * y);",
                    "});",
                    "NodeTypes['normcdf'] = normcdfNode;",
                    "const normcdfInvNode = new NodeType('normcdfInv');",
                    "const rationalApproximation = (t) => {",
                    "    const c = [2.515517, 0.802853, 0.010328];",
                    "    const d = [1.432788, 0.189269, 0.001308];",
                    "    return t - ((c[2] * t + c[1]) * t + c[0]) / (((d[2] * t + d[1]) * t + d[0]) * t + 1.0);",
                    "};",
                    "const normcdfInv = (p) => {",
                    "    if (p < 0.5) {",
                    "        return -rationalApproximation(Math.sqrt(-2.0 * Math.log(p)));",
                    "    }",
                    "    else {",
                    "        return rationalApproximation(Math.sqrt(-2.0 * Math.log(1 - p)));",
                    "    }",
                    "};",
                    "normcdfInvNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = normcdfInv(inputs[0]);",
                    "});",
                    "NodeTypes['normcdfInv'] = normcdfInvNode;",
                    "const clampNode = new NodeType('clamp');",
                    "clampNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.max(Math.min(inputs[0], inputs[2]), inputs[1]);",
                    "});",
                    "NodeTypes['clamp'] = clampNode;",
                    "const smoothstepNode = new NodeType('smoothstep');",
                    "smoothstepNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    const x = Math.max(Math.min(inputs[0], inputs[2]), inputs[1]);",
                    "    outputs[0] = x * x * (3 - 2 * x);",
                    "});",
                    "NodeTypes['smoothstep'] = smoothstepNode;",
                    "const randomNode = new NodeType('random');",
                    "randomNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Number, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [gdjs.__particleEmmiter3DExtension.NodeValueType.Number], (context, data, inputs, outputs) => {",
                    "    outputs[0] = Math.random() * (inputs[1] - inputs[0]) + inputs[0];",
                    "});",
                    "randomNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    let random = Math.random();",
                    "    outputs[0].lerpVectors(inputs[0], inputs[1], random);",
                    "});",
                    "randomNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    let random = Math.random();",
                    "    outputs[0].lerpVectors(inputs[0], inputs[1], random);",
                    "});",
                    "randomNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    let random = Math.random();",
                    "    outputs[0].lerpVectors(inputs[0], inputs[1], random);",
                    "});",
                    "NodeTypes['random'] = randomNode;",
                    "const vrandNode = new NodeType('vrand');",
                    "vrandNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec2], (context, data, inputs, outputs) => {",
                    "    let x = normcdfInv(Math.random());",
                    "    let y = normcdfInv(Math.random());",
                    "    const mag = Math.sqrt(x * x + y * y);",
                    "    outputs[0].set(x / mag, y / mag);",
                    "});",
                    "vrandNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3], (context, data, inputs, outputs) => {",
                    "    let x = normcdfInv(Math.random());",
                    "    let y = normcdfInv(Math.random());",
                    "    let z = normcdfInv(Math.random());",
                    "    const mag = Math.sqrt(x * x + y * y + z * z);",
                    "    outputs[0].set(x / mag, y / mag, z / mag);",
                    "});",
                    "vrandNode.addSignature([], [gdjs.__particleEmmiter3DExtension.NodeValueType.Vec4], (context, data, inputs, outputs) => {",
                    "    let x = normcdfInv(Math.random());",
                    "    let y = normcdfInv(Math.random());",
                    "    let z = normcdfInv(Math.random());",
                    "    let w = normcdfInv(Math.random());",
                    "    const mag = Math.sqrt(x * x + y * y + z * z + w * w);",
                    "    outputs[0].set(x / mag, y / mag, z / mag, w / mag);",
                    "});",
                    "NodeTypes['vrand'] = vrandNode;",
                    "const bsdfNode = new NodeType('bsdf');",
                    "bsdfNode.addSignature([gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Vec3, gdjs.__particleEmmiter3DExtension.NodeValueType.Number], [], (context, data, inputs, outputs) => { });",
                    "NodeTypes['bsdf'] = bsdfNode;",
                    "const OutputNodeTypeNames = new Set(['output', 'particleProperty', 'graphProperty', 'emit']);",
                    "",
                    "class NodeGraph {",
                    "    constructor(name) {",
                    "        this.inputNodes = [];",
                    "        this.outputNodes = [];",
                    "        this.allNodes = new Map();",
                    "        this.wires = [];",
                    "        this.compiled = false;",
                    "        this.nodesInOrder = [];",
                    "        this.version = '1.0';",
                    "        this.uuid = THREE.MathUtils.generateUUID();",
                    "        this.name = name;",
                    "        this.revision = 0;",
                    "    }",
                    "    addWire(wire) {",
                    "        this.wires.push(wire);",
                    "        this.revision++;",
                    "    }",
                    "    addNode(node) {",
                    "        this.allNodes.set(node.id, node);",
                    "        if (node.type === NodeTypes['input']) {",
                    "            this.inputNodes.push(node);",
                    "        }",
                    "        else if (OutputNodeTypeNames.has(node.type.name)) {",
                    "            this.outputNodes.push(node);",
                    "        }",
                    "        this.revision++;",
                    "    }",
                    "    getNode(id) {",
                    "        return this.allNodes.get(id);",
                    "    }",
                    "    deleteNode(node) {",
                    "        this.allNodes.delete(node.id);",
                    "        this.revision++;",
                    "    }",
                    "    deleteWire(wire) {",
                    "        let index = wire.input.outputs[wire.inputIndex].indexOf(wire);",
                    "        if (index !== -1) {",
                    "            wire.input.outputs[wire.inputIndex].splice(index, 1);",
                    "        }",
                    "        wire.output.inputs[wire.outputIndex] = undefined;",
                    "        index = this.wires.indexOf(wire);",
                    "        if (index != -1) {",
                    "            this.wires[index] = this.wires[this.wires.length - 1];",
                    "            this.wires.pop();",
                    "        }",
                    "        this.revision++;",
                    "    }",
                    "    toJSON() {",
                    "        throw new Error('not implemented');",
                    "    }",
                    "    clone() {",
                    "        throw new Error('not implemented');",
                    "    }",
                    "}",
                    "",
                    "new THREE.Vector3(0, 0, 1);",
                    "const tempQ = new THREE.Quaternion();",
                    "const tempV = new THREE.Vector3();",
                    "const tempV2 = new THREE.Vector3();",
                    "const PREWARM_FPS = 60;",
                    "const DEFAULT_GEOMETRY = new THREE.PlaneGeometry(1, 1, 1, 1);",
                    "class NodeVFX {",
                    "    set time(time) {",
                    "        this.emissionState.time = time;",
                    "    }",
                    "    get time() {",
                    "        return this.emissionState.time;",
                    "    }",
                    "    get layers() {",
                    "        return this.rendererSettings.layers;",
                    "    }",
                    "    get texture() {",
                    "        return this.rendererSettings.material.map;",
                    "    }",
                    "    set texture(texture) {",
                    "        this.rendererSettings.material.map = texture;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get material() {",
                    "        return this.rendererSettings.material;",
                    "    }",
                    "    set material(material) {",
                    "        this.rendererSettings.material = material;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get instancingGeometry() {",
                    "        return this.rendererSettings.instancingGeometry;",
                    "    }",
                    "    set instancingGeometry(geometry) {",
                    "        this.restart();",
                    "        this.particles.length = 0;",
                    "        this.rendererSettings.instancingGeometry = geometry;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get renderMode() {",
                    "        return this.rendererSettings.renderMode;",
                    "    }",
                    "    set renderMode(renderMode) {",
                    "        if ((this.rendererSettings.renderMode != gdjs.__particleEmmiter3DExtension.RenderMode.Trail && renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) ||",
                    "            (this.rendererSettings.renderMode == gdjs.__particleEmmiter3DExtension.RenderMode.Trail && renderMode !== gdjs.__particleEmmiter3DExtension.RenderMode.Trail)) {",
                    "            this.restart();",
                    "            this.particles.length = 0;",
                    "        }",
                    "        if (this.rendererSettings.renderMode !== renderMode) {",
                    "            switch (renderMode) {",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.Trail:",
                    "                    this.rendererEmitterSettings = {",
                    "                        startLength: 30,",
                    "                        followLocalOrigin: false,",
                    "                    };",
                    "                    break;",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.Mesh:",
                    "                    this.rendererEmitterSettings = {",
                    "                        geometry: new THREE.PlaneGeometry(1, 1),",
                    "                    };",
                    "                    break;",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard:",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.VerticalBillBoard:",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.HorizontalBillBoard:",
                    "                case gdjs.__particleEmmiter3DExtension.RenderMode.StretchedBillBoard:",
                    "                    this.rendererEmitterSettings = {};",
                    "                    break;",
                    "            }",
                    "        }",
                    "        this.rendererSettings.renderMode = renderMode;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get renderOrder() {",
                    "        return this.rendererSettings.renderOrder;",
                    "    }",
                    "    set renderOrder(renderOrder) {",
                    "        this.rendererSettings.renderOrder = renderOrder;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    get blending() {",
                    "        return this.rendererSettings.material.blending;",
                    "    }",
                    "    set blending(blending) {",
                    "        this.rendererSettings.material.blending = blending;",
                    "        this.neededToUpdateRender = true;",
                    "    }",
                    "    constructor(parameters) {",
                    "        var _a, _b, _c, _d, _e, _f, _g;",
                    "        this.temp = new THREE.Vector3();",
                    "        this.travelDistance = 0;",
                    "        this.normalMatrix = new THREE.Matrix3();",
                    "        this.speedFactor = 0;",
                    "        this.autoDestroy = parameters.autoDestroy === undefined ? false : parameters.autoDestroy;",
                    "        this.duration = (_a = parameters.duration) !== null && _a !== void 0 ? _a : 1;",
                    "        this.looping = parameters.looping === undefined ? true : parameters.looping;",
                    "        this.prewarm = parameters.prewarm === undefined ? false : parameters.prewarm;",
                    "        this.worldSpace = (_b = parameters.worldSpace) !== null && _b !== void 0 ? _b : false;",
                    "        this.rendererEmitterSettings = (_c = parameters.rendererEmitterSettings) !== null && _c !== void 0 ? _c : {};",
                    "        this.emissionGraph = parameters.emissionGraph;",
                    "        this.updateGraph = parameters.updateGraph;",
                    "        this.interpreter = new Interpreter();",
                    "        this.rendererSettings = {",
                    "            instancingGeometry: (_d = parameters.instancingGeometry) !== null && _d !== void 0 ? _d : DEFAULT_GEOMETRY,",
                    "            renderMode: (_e = parameters.renderMode) !== null && _e !== void 0 ? _e : gdjs.__particleEmmiter3DExtension.RenderMode.BillBoard,",
                    "            renderOrder: (_f = parameters.renderOrder) !== null && _f !== void 0 ? _f : 0,",
                    "            material: parameters.material,",
                    "            layers: (_g = parameters.layers) !== null && _g !== void 0 ? _g : new THREE.Layers(),",
                    "            uTileCount: 1,",
                    "            vTileCount: 1,",
                    "        };",
                    "        this.neededToUpdateRender = true;",
                    "        this.particles = new Array();",
                    "        this.emitter = new ParticleEmitter(this);",
                    "        this.paused = false;",
                    "        this.particleNum = 0;",
                    "        this.emissionState = {",
                    "            time: 0,",
                    "        };",
                    "        this.emitEnded = false;",
                    "        this.markForDestroy = false;",
                    "        this.prewarmed = false;",
                    "    }",
                    "    pause() {",
                    "        this.paused = true;",
                    "    }",
                    "    play() {",
                    "        this.paused = false;",
                    "    }",
                    "    spawn(emissionState, matrix) {",
                    "        tempQ.setFromRotationMatrix(matrix);",
                    "        const translation = tempV;",
                    "        const quaternion = tempQ;",
                    "        const scale = tempV2;",
                    "        matrix.decompose(translation, quaternion, scale);",
                    "        this.particleNum++;",
                    "        while (this.particles.length < this.particleNum) {",
                    "            this.particles.push(new NodeParticle());",
                    "        }",
                    "        const particle = this.particles[this.particleNum - 1];",
                    "        particle.reset();",
                    "        this.interpreter.run(this.updateGraph, { particle: particle, emissionState: this.emissionState });",
                    "        if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail &&",
                    "            this.rendererEmitterSettings.followLocalOrigin) {",
                    "            const trail = particle;",
                    "            trail.localPosition = new THREE.Vector3().copy(trail.position);",
                    "        }",
                    "        if (this.worldSpace) {",
                    "            particle.position.applyMatrix4(matrix);",
                    "            particle.size *= (Math.abs(scale.x) + Math.abs(scale.y) + Math.abs(scale.z)) / 3;",
                    "            particle.velocity.multiply(scale).applyMatrix3(this.normalMatrix);",
                    "            if (particle.rotation && particle.rotation instanceof THREE.Quaternion) {",
                    "                particle.rotation.multiplyQuaternions(tempQ, particle.rotation);",
                    "            }",
                    "        }",
                    "    }",
                    "    endEmit() {",
                    "        this.emitEnded = true;",
                    "        if (this.autoDestroy) {",
                    "            this.markForDestroy = true;",
                    "        }",
                    "    }",
                    "    dispose() {",
                    "        if (this._renderer)",
                    "            this._renderer.deleteSystem(this);",
                    "        this.emitter.dispose();",
                    "        if (this.emitter.parent)",
                    "            this.emitter.parent.remove(this.emitter);",
                    "    }",
                    "    restart() {",
                    "        this.paused = false;",
                    "        this.particleNum = 0;",
                    "        this.emissionState.time = 0;",
                    "        this.emitEnded = false;",
                    "        this.markForDestroy = false;",
                    "        this.prewarmed = false;",
                    "    }",
                    "    update(delta) {",
                    "        if (this.paused)",
                    "            return;",
                    "        let currentParent = this.emitter;",
                    "        while (currentParent.parent) {",
                    "            currentParent = currentParent.parent;",
                    "        }",
                    "        if (currentParent.type !== 'Scene') {",
                    "            this.dispose();",
                    "            return;",
                    "        }",
                    "        if (this.emitEnded && this.particleNum === 0) {",
                    "            if (this.markForDestroy && this.emitter.parent)",
                    "                this.dispose();",
                    "            return;",
                    "        }",
                    "        if (this.looping && this.prewarm && !this.prewarmed) {",
                    "            this.prewarmed = true;",
                    "            for (let i = 0; i < this.duration * PREWARM_FPS; i++) {",
                    "                this.update(1.0 / PREWARM_FPS);",
                    "            }",
                    "        }",
                    "        if (delta > 0.1) {",
                    "            delta = 0.1;",
                    "        }",
                    "        if (this.neededToUpdateRender) {",
                    "            if (this._renderer)",
                    "                this._renderer.updateSystem(this);",
                    "            this.neededToUpdateRender = false;",
                    "        }",
                    "        this.emit(delta, this.emissionState, this.emitter.matrixWorld);",
                    "        const context = { particle: undefined, emissionState: this.emissionState, delta };",
                    "        for (let i = 0; i < this.particleNum; i++) {",
                    "            context.particle = this.particles[i];",
                    "            this.interpreter.run(this.updateGraph, context);",
                    "        }",
                    "        for (let i = 0; i < this.particleNum; i++) {",
                    "            if (this.rendererEmitterSettings.followLocalOrigin &&",
                    "                this.particles[i].localPosition) {",
                    "                this.particles[i].position.copy(this.particles[i].localPosition);",
                    "                if (this.particles[i].parentMatrix) {",
                    "                    this.particles[i].position.applyMatrix4(this.particles[i].parentMatrix);",
                    "                }",
                    "                else {",
                    "                    this.particles[i].position.applyMatrix4(this.emitter.matrixWorld);",
                    "                }",
                    "            }",
                    "            else {",
                    "                this.particles[i].position.addScaledVector(this.particles[i].velocity, delta);",
                    "            }",
                    "            this.particles[i].age += delta;",
                    "        }",
                    "        if (this.rendererSettings.renderMode === gdjs.__particleEmmiter3DExtension.RenderMode.Trail) {",
                    "            for (let i = 0; i < this.particleNum; i++) {",
                    "                const particle = this.particles[i];",
                    "                particle.update();",
                    "            }",
                    "        }",
                    "        for (let i = 0; i < this.particleNum; i++) {",
                    "            const particle = this.particles[i];",
                    "            if (particle.died && (!(particle instanceof TrailParticle) || particle.previous.length === 0)) {",
                    "                this.particles[i] = this.particles[this.particleNum - 1];",
                    "                this.particles[this.particleNum - 1] = particle;",
                    "                this.particleNum--;",
                    "                i--;",
                    "            }",
                    "        }",
                    "    }",
                    "    emit(delta, emissionState, emitterMatrix) {",
                    "        if (emissionState.time > this.duration) {",
                    "            if (this.looping) {",
                    "                emissionState.time -= this.duration;",
                    "            }",
                    "            else {",
                    "                if (!this.emitEnded) {",
                    "                    this.endEmit();",
                    "                }",
                    "            }",
                    "        }",
                    "        this.normalMatrix.getNormalMatrix(emitterMatrix);",
                    "        const context = {",
                    "            signal: () => {",
                    "                this.spawn(emissionState, emitterMatrix);",
                    "            },",
                    "            emissionState,",
                    "            delta,",
                    "        };",
                    "        if (!this.emitEnded) {",
                    "            this.interpreter.run(this.emissionGraph, context);",
                    "        }",
                    "        if (this.previousWorldPos === undefined)",
                    "            this.previousWorldPos = new THREE.Vector3();",
                    "        this.emitter.getWorldPosition(this.previousWorldPos);",
                    "        emissionState.time += delta;",
                    "    }",
                    "    toJSON(meta, options = {}) {",
                    "        return {};",
                    "    }",
                    "    getRendererSettings() {",
                    "        return this.rendererSettings;",
                    "    }",
                    "    clone() {",
                    "        return this;",
                    "    }",
                    "}",
                    "",
                    "gdjs.__particleEmmiter3DExtension.ApplyCollision = ApplyCollision;",
                    "gdjs.__particleEmmiter3DExtension.ApplyForce = ApplyForce;",
                    "gdjs.__particleEmmiter3DExtension.ApplySequences = ApplySequences;",
                    "gdjs.__particleEmmiter3DExtension.AxisAngleGenerator = AxisAngleGenerator;",
                    "gdjs.__particleEmmiter3DExtension.BatchedParticleRenderer = BatchedParticleRenderer;",
                    "gdjs.__particleEmmiter3DExtension.BatchedRenderer = BatchedRenderer;",
                    "gdjs.__particleEmmiter3DExtension.BehaviorFromJSON = BehaviorFromJSON;",
                    "gdjs.__particleEmmiter3DExtension.BehaviorTypes = BehaviorTypes;",
                    "gdjs.__particleEmmiter3DExtension.Bezier = Bezier;",
                    "gdjs.__particleEmmiter3DExtension.ChangeEmitDirection = ChangeEmitDirection;",
                    "gdjs.__particleEmmiter3DExtension.ColorGeneratorFromJSON = ColorGeneratorFromJSON;",
                    "gdjs.__particleEmmiter3DExtension.ColorOverLife = ColorOverLife;",
                    "gdjs.__particleEmmiter3DExtension.ColorRange = ColorRange;",
                    "gdjs.__particleEmmiter3DExtension.ConeEmitter = ConeEmitter;",
                    "gdjs.__particleEmmiter3DExtension.ConstantColor = ConstantColor;",
                    "gdjs.__particleEmmiter3DExtension.ConstantValue = ConstantValue;",
                    "gdjs.__particleEmmiter3DExtension.DonutEmitter = DonutEmitter;",
                    "gdjs.__particleEmmiter3DExtension.EmitSubParticleSystem = EmitSubParticleSystem;",
                    "gdjs.__particleEmmiter3DExtension.EmitterFromJSON = EmitterFromJSON;",
                    "gdjs.__particleEmmiter3DExtension.EmitterShapes = EmitterShapes;",
                    "gdjs.__particleEmmiter3DExtension.EulerGenerator = EulerGenerator;",
                    "gdjs.__particleEmmiter3DExtension.ForceOverLife = ForceOverLife;",
                    "gdjs.__particleEmmiter3DExtension.FrameOverLife = FrameOverLife;",
                    "gdjs.__particleEmmiter3DExtension.GeneratorFromJSON = GeneratorFromJSON;",
                    "gdjs.__particleEmmiter3DExtension.Gradient = Gradient;",
                    "gdjs.__particleEmmiter3DExtension.GraphNodeType = GraphNodeType;",
                    "gdjs.__particleEmmiter3DExtension.GravityForce = GravityForce;",
                    "gdjs.__particleEmmiter3DExtension.GridEmitter = GridEmitter;",
                    "gdjs.__particleEmmiter3DExtension.Interpreter = Interpreter;",
                    "gdjs.__particleEmmiter3DExtension.IntervalValue = IntervalValue;",
                    "gdjs.__particleEmmiter3DExtension.MeshSurfaceEmitter = MeshSurfaceEmitter;",
                    "gdjs.__particleEmmiter3DExtension.Node = Node;",
                    "gdjs.__particleEmmiter3DExtension.NodeGraph = NodeGraph;",
                    "gdjs.__particleEmmiter3DExtension.NodeType = NodeType;",
                    "gdjs.__particleEmmiter3DExtension.NodeTypes = NodeTypes;",
                    "gdjs.__particleEmmiter3DExtension.Noise = Noise;",
                    "gdjs.__particleEmmiter3DExtension.OrbitOverLife = OrbitOverLife;",
                    "gdjs.__particleEmmiter3DExtension.ParticleEmitter = ParticleEmitter;",
                    "gdjs.__particleEmmiter3DExtension.ParticleSystem = ParticleSystem;",
                    "gdjs.__particleEmmiter3DExtension.PiecewiseBezier = PiecewiseBezier;",
                    "gdjs.__particleEmmiter3DExtension.PiecewiseFunction = PiecewiseFunction;",
                    "gdjs.__particleEmmiter3DExtension.Plugins = Plugins;",
                    "gdjs.__particleEmmiter3DExtension.PointEmitter = PointEmitter;",
                    "gdjs.__particleEmmiter3DExtension.QuarksLoader = QuarksLoader;",
                    "gdjs.__particleEmmiter3DExtension.RandomColor = RandomColor;",
                    "gdjs.__particleEmmiter3DExtension.RandomColorBetweenGradient = RandomColorBetweenGradient;",
                    "gdjs.__particleEmmiter3DExtension.RandomQuatGenerator = RandomQuatGenerator;",
                    "gdjs.__particleEmmiter3DExtension.RecordState = RecordState;",
                    "gdjs.__particleEmmiter3DExtension.Rotation3DOverLife = Rotation3DOverLife;",
                    "gdjs.__particleEmmiter3DExtension.RotationGeneratorFromJSON = RotationGeneratorFromJSON;",
                    "gdjs.__particleEmmiter3DExtension.RotationOverLife = RotationOverLife;",
                    "gdjs.__particleEmmiter3DExtension.SequencerFromJSON = SequencerFromJSON;",
                    "gdjs.__particleEmmiter3DExtension.SizeOverLife = SizeOverLife;",
                    "gdjs.__particleEmmiter3DExtension.SpeedOverLife = SpeedOverLife;",
                    "gdjs.__particleEmmiter3DExtension.SphereEmitter = SphereEmitter;",
                    "gdjs.__particleEmmiter3DExtension.SpriteBatch = SpriteBatch;",
                    "gdjs.__particleEmmiter3DExtension.SpriteParticle = SpriteParticle;",
                    "gdjs.__particleEmmiter3DExtension.TextureSequencer = TextureSequencer;",
                    "gdjs.__particleEmmiter3DExtension.TrailBatch = TrailBatch;",
                    "gdjs.__particleEmmiter3DExtension.TrailParticle = TrailParticle;",
                    "gdjs.__particleEmmiter3DExtension.TurbulenceField = TurbulenceField;",
                    "gdjs.__particleEmmiter3DExtension.VFXBatch = VFXBatch;",
                    "gdjs.__particleEmmiter3DExtension.ValueGeneratorFromJSON = ValueGeneratorFromJSON;",
                    "gdjs.__particleEmmiter3DExtension.WidthOverLength = WidthOverLength;",
                    "gdjs.__particleEmmiter3DExtension.Wire = Wire;",
                    "gdjs.__particleEmmiter3DExtension.genDefaultForNodeValueType = genDefaultForNodeValueType;",
                    "gdjs.__particleEmmiter3DExtension.getPhysicsResolver = getPhysicsResolver;",
                    "gdjs.__particleEmmiter3DExtension.loadPlugin = loadPlugin;",
                    "gdjs.__particleEmmiter3DExtension.setPhysicsResolver = setPhysicsResolver;",
                    "gdjs.__particleEmmiter3DExtension.unloadPlugin = unloadPlugin;",
                    ""
                  ],
                  "parameterObjects": "",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ]
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onScenePreEvents",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "\r",
                "// See doStepPostEvents\r",
                "runtimeScene.__particleEmmiter3DExtension = runtimeScene.__particleEmmiter3DExtension || {};\r",
                "runtimeScene.__particleEmmiter3DExtension.emittersStepped = 0;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": [
        {
          "defaultName": "ParticleEmitter",
          "description": "Display a large number of particles to create visual effects.",
          "fullName": "3D particle emitter",
          "is3D": true,
          "name": "ParticleEmitter3D",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const BatchedRenderer = gdjs.__particleEmmiter3DExtension.BatchedRenderer;",
                    "const ParticleSystem = gdjs.__particleEmmiter3DExtension.ParticleSystem;",
                    "const TextureLoader = gdjs.__particleEmmiter3DExtension.TextureLoader;",
                    "const IntervalValue = gdjs.__particleEmmiter3DExtension.IntervalValue;",
                    "const ConstantValue = gdjs.__particleEmmiter3DExtension.ConstantValue;",
                    "const ConstantColor = gdjs.__particleEmmiter3DExtension.ConstantColor;",
                    "const ColorOverLife = gdjs.__particleEmmiter3DExtension.ColorOverLife;",
                    "const SizeOverLife = gdjs.__particleEmmiter3DExtension.SizeOverLife;",
                    "const ApplyForce = gdjs.__particleEmmiter3DExtension.ApplyForce;",
                    "const Gradient = gdjs.__particleEmmiter3DExtension.Gradient;",
                    "const PiecewiseBezier = gdjs.__particleEmmiter3DExtension.PiecewiseBezier;",
                    "const Bezier = gdjs.__particleEmmiter3DExtension.Bezier;",
                    "const PointEmitter = gdjs.__particleEmmiter3DExtension.PointEmitter;",
                    "const ConeEmitter = gdjs.__particleEmmiter3DExtension.ConeEmitter;",
                    "const RenderMode = gdjs.__particleEmmiter3DExtension.RenderMode;",
                    "",
                    "const { ParticleEmitterAdapter, ParticleEmitter3DRenderer } = gdjs.__particleEmmiter3DExtension;",
                    "",
                    "/** @type {gdjs.CustomRuntimeObject} */",
                    "const object = objects[0];",
                    "",
                    "// Here runtimeScene is the gdjs.CustomRuntimeObjectInstanceContainer inside the custom object.",
                    "const gameScene = object.getRuntimeScene();",
                    "",
                    "/** @type {SpriteObjectDataType} */",
                    "const particleSpriteData = object._instanceContainer._objects.get(\"Particle\");",
                    "const resourceName = particleSpriteData.animations[0].directions[0].sprites[0].image;",
                    "const texture = object",
                    "    .getInstanceContainer()",
                    "    .getGame()",
                    "    .getImageManager().getThreeTexture(resourceName);",
                    "",
                    "// Set the blending here because changes are not applied after the emitter creation.",
                    "const blendingString = object._getBlending();",
                    "const blending =",
                    "    blendingString === \"Additive\" ? THREE.AdditiveBlending :",
                    "        blendingString === \"Normal\" ? THREE.NormalBlending :",
                    "            blendingString === \"Subtractive\" ? THREE.SubtractiveBlending :",
                    "                blendingString === \"Multiply\" ? THREE.MultiplyBlending :",
                    "                    blendingString === \"None\" ? THREE.NoBlending :",
                    "                        THREE.AdditiveBlending;",
                    "",
                    "",
                    "// Build a configuration with the right kind of objects.",
                    "// These values are not important as they are overrided by the object properties values.",
                    "const muzzle = {",
                    "    duration: 10,",
                    "    looping: false,",
                    "    startLife: new IntervalValue(1, 2),",
                    "    startSpeed: new IntervalValue(100, 200),",
                    "    startSize: new IntervalValue(20, 50),",
                    "    startColor: new ConstantColor(new THREE.Vector4(1, 1, 1, 1)),",
                    "    worldSpace: true,",
                    "",
                    "    maxParticle: 5,",
                    "    emissionOverTime: new ConstantValue(50),",
                    "    emissionBursts: [{",
                    "        time: 0,",
                    "        count: new ConstantValue(1),",
                    "        cycle: 1,",
                    "        interval: 0.01,",
                    "        probability: 1,",
                    "    }],",
                    "",
                    "    shape: new PointEmitter(),",
                    "    material: new THREE.MeshBasicMaterial({",
                    "        map: texture,",
                    "        blending: blending,",
                    "        transparent: true,",
                    "        side: THREE.DoubleSide",
                    "    }),",
                    "    startTileIndex: 0,",
                    "    uTileCount: 1,",
                    "    vTileCount: 1,",
                    "    renderOrder: 2,",
                    "    renderMode: RenderMode.BillBoard",
                    "};",
                    "const particleSystem = new ParticleSystem(muzzle);",
                    "",
                    "const colorOverLife = new ColorOverLife(",
                    "    new Gradient(",
                    "        [",
                    "            [new THREE.Vector3(1, 0, 0), 0],",
                    "            [new THREE.Vector3(1, 0, 0), 1],",
                    "        ],",
                    "        [",
                    "            [1, 0],",
                    "            [1, 1],",
                    "        ]",
                    "    ));",
                    "particleSystem.addBehavior(colorOverLife);",
                    "const sizeOverLife = new SizeOverLife(new PiecewiseBezier([[new Bezier(1, 2 / 3, 1 / 3, 0), 0]]));",
                    "particleSystem.addBehavior(sizeOverLife);",
                    "const applyForce = new ApplyForce(new THREE.Vector3(0, 0, -1), new ConstantValue(0));",
                    "particleSystem.addBehavior(applyForce);",
                    "",
                    "particleSystem.emitter.name = object.getName() + object.getNameId();",
                    "",
                    "object.__particleEmitterAdapter = new ParticleEmitterAdapter(particleSystem, colorOverLife, sizeOverLife, applyForce);",
                    "object.__particleSystem = particleSystem;",
                    "",
                    "// This is a hack that may break in future releases.",
                    "// Replace the group that would hold children objects by the emmiter.",
                    "const layer = gameScene.getLayer(object.getLayer());",
                    "const group = object.getRenderer()._threeGroup;",
                    "layer.getRenderer().remove3DRendererObject(group);",
                    "particleSystem.emitter.position.copy(group.position);",
                    "particleSystem.emitter.rotation.order = 'ZYX';",
                    "particleSystem.emitter.rotation.copy(group.rotation);",
                    "",
                    "const particleEmitter3DRenderer = new ParticleEmitter3DRenderer(object, object._instanceContainer, object.getInstanceContainer());",
                    "object._renderer = particleEmitter3DRenderer;",
                    "particleEmitter3DRenderer._threeGroup = particleSystem.emitter;",
                    "layer.getRenderer().add3DRendererObject(particleSystem.emitter);",
                    "",
                    "particleSystem.emitter.updateMatrixWorld(true);",
                    "",
                    "",
                    "// See doStepPostEvents",
                    "gameScene.__particleEmmiter3DExtension = gameScene.__particleEmmiter3DExtension || {};",
                    "gameScene.__particleEmmiter3DExtension.emittersCount = gameScene.__particleEmmiter3DExtension.emittersCount || 0;",
                    "gameScene.__particleEmmiter3DExtension.emittersCount++;",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::UpdateFromProperties"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetRotationCenter"
                      },
                      "parameters": [
                        "Object",
                        "0",
                        "0",
                        "0"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onDestroy",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */",
                    "const object = objects[0];",
                    "// Here runtimeScene is the gdjs.CustomRuntimeObjectInstanceContainer inside the custom object.",
                    "const gameScene = object.getRuntimeScene();",
                    "",
                    "object.__particleSystem.dispose();",
                    "",
                    "// See doStepPostEvents",
                    "gameScene.__particleEmmiter3DExtension.emittersCount--;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onHotReloading",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::UpdateFromProperties"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Update from properties.",
              "fullName": "Update from properties",
              "functionType": "Action",
              "name": "UpdateFromProperties",
              "private": true,
              "sentence": "Update from properties of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetZ"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.Z()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetRotationX"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.PropertyRotationX()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetRotationY"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.PropertyRotationY()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetStartColor"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.StartColor()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetEndColor"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.EndColor()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetStartOpacity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.StartOpacity()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetEndOpacity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.EndOpacity()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetFlow"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.Flow()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetStartSizeMin"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.StartSizeMin()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetStartSizeMax"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.StartSizeMax()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetEndScale"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.EndScale()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetStartSpeedMin"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.StartSpeedMin()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetStartSpeedMax"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.StartSpeedMax()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetLifespanMin"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.LifespanMin()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetLifespanMax"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.LifespanMax()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetDuration"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.Duration()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetSpayConeAngle"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.SpayConeAngle()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetGravity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.Gravity()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetGravityTop"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "Object.GravityTop()",
                        ""
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "inverted": true,
                            "value": "ParticleEmitter3D::ParticleEmitter3D::PropertyAreParticlesRelative"
                          },
                          "parameters": [
                            "Object"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ParticleEmitter3D::ParticleEmitter3D::SetAreParticlesRelative"
                          },
                          "parameters": [
                            "Object",
                            "no",
                            ""
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ParticleEmitter3D::ParticleEmitter3D::PropertyAreParticlesRelative"
                          },
                          "parameters": [
                            "Object"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ParticleEmitter3D::ParticleEmitter3D::SetAreParticlesRelative"
                          },
                          "parameters": [
                            "Object",
                            "yes",
                            ""
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "TODO: Blending can't be changed."
                    },
                    {
                      "disabled": true,
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "ParticleEmitter3D::ParticleEmitter3D::SetBlending"
                          },
                          "parameters": [
                            "Object",
                            "=",
                            "Object.Blending()",
                            ""
                          ]
                        }
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::HasEnded"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::Delete"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "ParticleEmitter3D::ParticleEmitter3D::HasEnded"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::RegisterInLayer"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "/** @type {gdjs.CustomRuntimeObject3D} */",
                        "const object = objects[0];",
                        "// Here runtimeScene is the gdjs.CustomRuntimeObjectInstanceContainer inside the custom object.",
                        "const gameScene = object.getRuntimeScene();",
                        "",
                        "// Update batch system after having moved every emitter.",
                        "// See onScenePreEvents",
                        "gameScene.__particleEmmiter3DExtension.emittersStepped++;",
                        "if (gameScene.__particleEmmiter3DExtension.emittersStepped === gameScene.__particleEmmiter3DExtension.emittersCount) {",
                        "    gameScene.__particleEmmiter3DExtension.layerNames = gameScene.__particleEmmiter3DExtension.layerNames || [];",
                        "    const layerNames = gameScene.__particleEmmiter3DExtension.layerNames;",
                        "    gameScene.getAllLayerNames(layerNames);",
                        "    for (const layerName of layerNames) {",
                        "        const layer = gameScene.getLayer(layerName);",
                        "        if (layer.__particleEmmiter3DExtension) {",
                        "            layer.__particleEmmiter3DExtension.batchSystem.update(object.getElapsedTime() / 1000);",
                        "        }",
                        "    }",
                        "}"
                      ],
                      "parameterObjects": "Object",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Register in layer",
              "functionType": "Action",
              "name": "RegisterInLayer",
              "private": true,
              "sentence": "Register _PARAM0_ in layer",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */",
                    "const object = objects[0];",
                    "",
                    "// TODO Handle layer changes?",
                    "if (object.__emitterLayerName === undefined) {",
                    "    // Here runtimeScene is the gdjs.CustomRuntimeObjectInstanceContainer inside the custom object.",
                    "    const gameScene = object.getRuntimeScene();",
                    "",
                    "    const layer = gameScene.getLayer(object.getLayer());",
                    "    layer.__particleEmmiter3DExtension = layer.__particleEmmiter3DExtension || {};",
                    "    if (!layer.__particleEmmiter3DExtension.batchSystem) {",
                    "        const batchSystem = new gdjs.__particleEmmiter3DExtension.BatchedRenderer();",
                    "        const threeScene = layer.getRenderer().getThreeScene();",
                    "        if (threeScene) {",
                    "            threeScene.add(batchSystem);",
                    "        }",
                    "        layer.__particleEmmiter3DExtension.batchSystem = batchSystem;",
                    "    }",
                    "    layer.__particleEmmiter3DExtension.batchSystem.addSystem(object.__particleSystem);",
                    "    object.__emitterLayerName = layer.getName();",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Delete itself",
              "fullName": "Delete itself",
              "functionType": "Action",
              "name": "Delete",
              "private": true,
              "sentence": "Delete _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "",
                    "object.deleteFromScene(object.getParent());",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check that emission has ended and no particle is alive anymore.",
              "fullName": "Emission has ended",
              "functionType": "Condition",
              "name": "HasEnded",
              "sentence": "Emission from _PARAM0_ has ended",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "\r",
                    "eventsFunctionContext.returnValue =\r",
                    "       object._getShouldAutodestruct()\r",
                    "    && object.__particleSystem.emitEnded\r",
                    "    && object.__particleSystem.particleNum === 0;\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Restart particule emission from the beginning.",
              "fullName": "Restart",
              "functionType": "Action",
              "name": "Restart",
              "sentence": "Restart particule emission from _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */\r",
                    "const object = objects[0];\r",
                    "\r",
                    "object.__particleSystem.restart();\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the Z position of the emitter.",
              "fullName": "Z elevaltion (deprecated)",
              "functionType": "ExpressionAndCondition",
              "group": "Position",
              "name": "Z",
              "private": true,
              "sentence": "the Z position",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyZ()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Z",
              "name": "SetZ",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyZ"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the rotation on X axis of the emitter.",
              "fullName": "Rotation on X axis (deprecated)",
              "functionType": "ExpressionAndCondition",
              "group": "Angle",
              "name": "RotationX",
              "private": true,
              "sentence": "the rotation on X axis",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyRotationX()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "RotationX",
              "name": "SetRotationX",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyRotationX"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "\r",
                    "object.__particleSystem.emitter.rotation.x = eventsFunctionContext.getArgument(\"Value\") * Math.PI / 180;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the rotation on Y axis of the emitter.",
              "fullName": "Rotation on Y axis (deprecated)",
              "functionType": "ExpressionAndCondition",
              "group": "Angle",
              "name": "RotationY",
              "private": true,
              "sentence": "the rotation on Y axis",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyRotationY()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "RotationY",
              "name": "SetRotationY",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyRotationY"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "\r",
                    "object.__particleSystem.emitter.rotation.y = (90 + eventsFunctionContext.getArgument(\"Value\")) * Math.PI / 180;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the start color of the object.",
              "fullName": "Start color",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter color configuration",
              "name": "StartColor",
              "sentence": "the start color",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Object.PropertyStartColor()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "color"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "StartColor",
              "name": "SetStartColor",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyStartColor"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsString(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const startColor = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setStartColor(startColor);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the end color of the object.",
              "fullName": "End color",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter color configuration",
              "name": "EndColor",
              "sentence": "the end color",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Object.PropertyEndColor()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "color"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "EndColor",
              "name": "SetEndColor",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyEndColor"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsString(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const endColor = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setEndColor(endColor);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the start opacity of the object.",
              "fullName": "Start opacity",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter color configuration",
              "name": "StartOpacity",
              "sentence": "the start opacity",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyStartOpacity()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "StartOpacity",
              "name": "SetStartOpacity",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyStartOpacity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const startOpacity = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setStartOpacity(startOpacity);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the end opacity of the object.",
              "fullName": "End opacity",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter color configuration",
              "name": "EndOpacity",
              "sentence": "the end opacity",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyEndOpacity()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "EndOpacity",
              "name": "SetEndOpacity",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyEndOpacity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const endOpacity = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setEndOpacity(endOpacity);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the flow of particles of the object  (particles per second).",
              "fullName": "Flow of particles",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "Flow",
              "sentence": "the flow of particles",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyFlow()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Flow",
              "name": "SetFlow",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyFlow"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const flow = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setFlow(flow);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the start min size of the object.",
              "fullName": "Start min size",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "StartSizeMin",
              "sentence": "the start min size",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyStartSizeMin()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "StartSizeMin",
              "name": "SetStartSizeMin",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyStartSizeMin"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const startMinSize = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setStartMinSize(startMinSize);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the start max size of the object.",
              "fullName": "Start max size",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "StartSizeMax",
              "sentence": "the start max size",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyStartSizeMax()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "StartSizeMax",
              "name": "SetStartSizeMax",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyStartSizeMax"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const startMaxSize = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setStartMaxSize(startMaxSize);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the end scale of the object.",
              "fullName": "End scale",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "EndScale",
              "sentence": "the end scale",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyEndScale()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "EndScale",
              "name": "SetEndScale",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyEndScale"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const endScale = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setEndScale(endScale);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the min start speed of the object.",
              "fullName": "Min start speed",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter speed configuration",
              "name": "StartSpeedMin",
              "sentence": "the min start speed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyStartSpeedMin()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "StartSpeedMin",
              "name": "SetStartSpeedMin",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyStartSpeedMin"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const startSpeedMin = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setStartSpeedMin(startSpeedMin);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the max start speed of the object.",
              "fullName": "Max start speed",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter speed configuration",
              "name": "StartSpeedMax",
              "sentence": "the max start speed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyStartSpeedMax()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "StartSpeedMax",
              "name": "SetStartSpeedMax",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyStartSpeedMax"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const startSpeedMax = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setStartSpeedMax(startSpeedMax);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the min lifespan of the object.",
              "fullName": "Min lifespan",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "LifespanMin",
              "sentence": "the min lifespan",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyLifespanMin()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "LifespanMin",
              "name": "SetLifespanMin",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyLifespanMin"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const lifespanMin = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setLifespanMin(lifespanMin);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the max lifespan of the object.",
              "fullName": "Max lifespan",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "LifespanMax",
              "sentence": "the max lifespan",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyLifespanMax()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "LifespanMax",
              "name": "SetLifespanMax",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyLifespanMax"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const lifespanMax = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setLifespanMax(lifespanMax);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the emission duration of the object.",
              "fullName": "Emission duration",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "Duration",
              "sentence": "the emission duration",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyDuration()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Duration",
              "name": "SetDuration",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyDuration"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const duration = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setDuration(duration);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if particles move with the emitter.",
              "fullName": "Particles move with the emitter",
              "functionType": "Condition",
              "group": "3D particle emitter speed configuration",
              "name": "AreParticlesRelative",
              "sentence": "_PARAM0_ particles move with the emitter",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::PropertyAreParticlesRelative"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change if particles move with the emitter.",
              "fullName": "Particles move with the emitter",
              "functionType": "Action",
              "group": "3D particle emitter speed configuration",
              "name": "SetAreParticlesRelative",
              "sentence": "_PARAM0_ particles move with the emitter: _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyAreParticlesRelative"
                      },
                      "parameters": [
                        "Object",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyAreParticlesRelative"
                      },
                      "parameters": [
                        "Object",
                        "yes"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const areParticlesRelative = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setParticlesRelative(areParticlesRelative);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                },
                {
                  "defaultValue": "yes",
                  "description": "AreParticlesRelative",
                  "name": "Value",
                  "optional": true,
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the spay cone angle of the object.",
              "fullName": "Spay cone angle",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter configuration",
              "name": "SpayConeAngle",
              "sentence": "the spay cone angle",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertySpayConeAngle()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "SpayConeAngle",
              "name": "SetSpayConeAngle",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertySpayConeAngle"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const sprayConeAngle = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setSprayConeAngle(sprayConeAngle);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the blending of the object.",
              "fullName": "Blending",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter color configuration",
              "name": "Blending",
              "sentence": "the blending",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Object.PropertyBlending()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "supplementaryInformation": "[\"Normal\",\"Additive\",\"Substractive\",\"Multiply\",\"None\"]",
                "type": "stringWithSelector"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Blending",
              "name": "SetBlending",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyBlending"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsString(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const blending = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setBlending(blending);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the gravity top of the object.",
              "fullName": "Gravity top",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter speed configuration",
              "name": "GravityTop",
              "sentence": "the gravity top",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Object.PropertyGravityTop()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "supplementaryInformation": "[\"Y-\",\"Z+\"]",
                "type": "stringWithSelector"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "GravityTop",
              "name": "SetGravityTop",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyGravityTop"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsString(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const gravityTop = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setGravityTop(gravityTop);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the gravity of the object.",
              "fullName": "Gravity",
              "functionType": "ExpressionAndCondition",
              "group": "3D particle emitter speed configuration",
              "name": "Gravity",
              "sentence": "the gravity",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.PropertyGravity()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "Gravity",
              "name": "SetGravity",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyGravity"
                      },
                      "parameters": [
                        "Object",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];\r",
                    "const gravity = eventsFunctionContext.getArgument(\"Value\");\r",
                    "\r",
                    "object.__particleEmitterAdapter.setGravity(gravity);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if delete when emission ends.",
              "fullName": "Delete when emission ends",
              "functionType": "Condition",
              "group": "3D particle emitter configuration",
              "name": "ShouldAutodestruct",
              "sentence": "_PARAM0_ delete when emission ends",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::PropertyShouldAutodestruct"
                      },
                      "parameters": [
                        "Object"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change if delete when emission ends.",
              "fullName": "Delete when emission ends",
              "functionType": "Action",
              "group": "3D particle emitter configuration",
              "name": "SetShouldAutodestruct",
              "sentence": "_PARAM0_ delete when emission ends: _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyShouldAutodestruct"
                      },
                      "parameters": [
                        "Object",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"Value\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ParticleEmitter3D::ParticleEmitter3D::SetPropertyShouldAutodestruct"
                      },
                      "parameters": [
                        "Object",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "ParticleEmitter3D::ParticleEmitter3D",
                  "type": "object"
                },
                {
                  "defaultValue": "yes",
                  "description": "ShouldAutodestruct",
                  "name": "Value",
                  "optional": true,
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "255;0;0",
              "type": "Color",
              "label": "Start color",
              "description": "",
              "group": "Color",
              "extraInformation": [],
              "name": "StartColor"
            },
            {
              "value": "255;255;0",
              "type": "Color",
              "label": "End color",
              "description": "",
              "group": "Color",
              "extraInformation": [],
              "name": "EndColor"
            },
            {
              "value": "255",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "Start opacity",
              "description": "",
              "group": "Color",
              "extraInformation": [],
              "name": "StartOpacity"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "End opacity",
              "description": "",
              "group": "Color",
              "extraInformation": [],
              "name": "EndOpacity"
            },
            {
              "value": "50",
              "type": "Number",
              "label": "Flow of particles (particles per second)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Flow"
            },
            {
              "value": "10",
              "type": "Number",
              "unit": "Pixel",
              "label": "Start min size",
              "description": "",
              "group": "Size",
              "extraInformation": [],
              "name": "StartSizeMin"
            },
            {
              "value": "20",
              "type": "Number",
              "unit": "Pixel",
              "label": "Start max size",
              "description": "",
              "group": "Size",
              "extraInformation": [],
              "name": "StartSizeMax"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "End scale",
              "description": "",
              "group": "Size",
              "extraInformation": [],
              "name": "EndScale"
            },
            {
              "value": "100",
              "type": "Number",
              "unit": "PixelSpeed",
              "label": "Start min speed",
              "description": "",
              "group": "Speed",
              "extraInformation": [],
              "name": "StartSpeedMin"
            },
            {
              "value": "100",
              "type": "Number",
              "unit": "PixelSpeed",
              "label": "Start max speed",
              "description": "",
              "group": "Speed",
              "extraInformation": [],
              "name": "StartSpeedMax"
            },
            {
              "value": "1",
              "type": "Number",
              "unit": "Second",
              "label": "Min lifespan",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "LifespanMin"
            },
            {
              "value": "2",
              "type": "Number",
              "unit": "Second",
              "label": "Max lifespan",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "LifespanMax"
            },
            {
              "value": "5",
              "type": "Number",
              "unit": "Second",
              "label": "Emission duration",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Duration"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Particles move with the emitter",
              "description": "",
              "group": "Speed",
              "extraInformation": [],
              "name": "AreParticlesRelative"
            },
            {
              "value": "30",
              "type": "Number",
              "unit": "DegreeAngle",
              "label": "Spay cone angle",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "name": "SpayConeAngle"
            },
            {
              "value": "Additive",
              "type": "Choice",
              "label": "Blending",
              "description": "",
              "group": "Color",
              "extraInformation": [
                "Normal",
                "Additive",
                "Subtractive",
                "Multiply",
                "None"
              ],
              "name": "Blending"
            },
            {
              "value": "Y-",
              "type": "Choice",
              "label": "Gravity top",
              "description": "",
              "group": "Speed",
              "extraInformation": [
                "Y-",
                "Z+"
              ],
              "name": "GravityTop"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "PixelAcceleration",
              "label": "Gravity",
              "description": "",
              "group": "Speed",
              "extraInformation": [],
              "name": "Gravity"
            },
            {
              "value": "true",
              "type": "Boolean",
              "label": "Delete when emission ends",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "ShouldAutodestruct"
            },
            {
              "value": "Center-center",
              "type": "String",
              "label": "",
              "description": "Only used by the scene editor.",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "ParentOrigin"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Z (elevation)",
              "description": "Deprecated",
              "group": "Position",
              "extraInformation": [],
              "hidden": true,
              "name": "Z"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "DegreeAngle",
              "label": "Rotation on X axis",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "hidden": true,
              "name": "RotationX"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "DegreeAngle",
              "label": "Rotation on Y axis",
              "description": "",
              "group": "Position",
              "extraInformation": [],
              "hidden": true,
              "name": "RotationY"
            }
          ],
          "objects": [
            {
              "adaptCollisionMaskAutomatically": true,
              "assetStoreId": "",
              "name": "Particle",
              "type": "Sprite",
              "updateIfNotVisible": false,
              "variables": [],
              "effects": [],
              "behaviors": [],
              "animations": [
                {
                  "name": "Image",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": []
                    }
                  ]
                }
              ]
            }
          ],
          "objectsFolderStructure": {
            "folderName": "__ROOT",
            "children": [
              {
                "objectName": "Particle"
              }
            ]
          }
        }
      ]
    },
    {
      "author": "@Bouh",
      "category": "User interface",
      "extensionNamespace": "",
      "fullName": "Time formatting",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWNsb2NrLWRpZ2l0YWwiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMiw2QTIsMiAwIDAsMCAwLDhWMTZBMiwyIDAgMCwwIDIsMThIMjJBMiwyIDAgMCwwIDI0LDE2VjhBMiwyIDAgMCwwIDIyLDZNMiw4SDIyVjE2SDJNMyw5VjEwLjVINi4yNUwzLDE1SDQuNzVMOCwxMC41VjlNOS4yNSw5VjEwLjVIMTAuNzVWOU0xMiw5VjEwLjVIMTMuNVYxNUgxNVY5TTE3LDlBMSwxIDAgMCwwIDE2LDEwVjE0QTEsMSAwIDAsMCAxNywxNUgyMEExLDEgMCAwLDAgMjEsMTRWMTBBMSwxIDAgMCwwIDIwLDlNMTcuNSwxMC41SDE5LjVWMTMuNUgxNy41TTkuMjUsMTMuNVYxNUgxMC43NVYxMy41IiAvPjwvc3ZnPg==",
      "name": "TimeFormatter",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/clock-digital.svg",
      "shortDescription": "Converts seconds into standard time formats, such as HH:MM:SS. ",
      "version": "0.0.2",
      "description": [
        "Ideal for displaying timers on screen.",
        "",
        "Formats included:",
        "* HH:MM:SS",
        "* HH:MM:SS.000 (displays milliseconds)"
      ],
      "origin": {
        "identifier": "TimeFormatter",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "time",
        "timer",
        "format",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      ],
      "authorIds": [
        "2OwwM8ToR9dx9RJ2sAKTcrLmCB92"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Format time in seconds to HH:MM:SS.",
          "fullName": "Format time in seconds to HH:MM:SS",
          "functionType": "StringExpression",
          "name": "SecondsToHHMMSS",
          "sentence": "Format time _PARAM1_ to HH:MM:SS in _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "var format_time = function (time_second) {\r",
                "    date = new Date(null);\r",
                "    date.setSeconds(time_second);\r",
                "    if (time_second >= 3600) {\r",
                "        return date.toISOString().substr(11, 8); // MM:SS\r",
                "    } else {\r",
                "        return date.toISOString().substr(14, 5); // HH:MM:SS\r",
                "    }\r",
                "}\r",
                "\r",
                "eventsFunctionContext.returnValue = format_time(eventsFunctionContext.getArgument(\"TimeInSeconds\"));"
              ],
              "parameterObjects": "",
              "useStrict": false,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Time, in seconds",
              "name": "TimeInSeconds",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Format time in seconds to HH:MM:SS.000, including milliseconds.",
          "fullName": "Format time in seconds to HH:MM:SS.000",
          "functionType": "StringExpression",
          "name": "SecondsToHHMMSS000",
          "sentence": "Format time _PARAM1_ to HH:MM:SS in _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "var format_time = function (time_second) {\r",
                "    date = new Date(null);\r",
                "    date.setMilliseconds(1000*time_second);\r",
                "    if (time_second >= 3600) {\r",
                "        return date.toISOString().substr(11, 12); // MM:SS.000\r",
                "    } else {\r",
                "        return date.toISOString().substr(14, 9); // HH:MM:SS.000\r",
                "    }\r",
                "}\r",
                "\r",
                "eventsFunctionContext.returnValue = format_time(eventsFunctionContext.getArgument(\"TimeInSeconds\"));"
              ],
              "parameterObjects": "",
              "useStrict": false,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Time, in seconds",
              "name": "TimeInSeconds",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "User interface",
      "extensionNamespace": "",
      "fullName": "Panel sprite button",
      "helpPath": "/objects/button",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI5LDIzSDNjLTEuMSwwLTItMC45LTItMlYxMWMwLTEuMSwwLjktMiwyLTJoMjZjMS4xLDAsMiwwLjksMiwydjEwQzMxLDIyLjEsMzAuMSwyMywyOSwyM3oiLz4NCjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMywxOUwxMywxOWMtMS4xLDAtMi0wLjktMi0ydi0yYzAtMS4xLDAuOS0yLDItMmgwYzEuMSwwLDIsMC45LDIsMnYyQzE1LDE4LjEsMTQuMSwxOSwxMywxOXoiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIxOCIgeTE9IjEzIiB4Mj0iMTgiIHkyPSIxOSIvPg0KPGxpbmUgY2xhc3M9InN0MCIgeDE9IjIxIiB5MT0iMTMiIHgyPSIxOCIgeTI9IjE3Ii8+DQo8bGluZSBjbGFzcz0ic3QwIiB4MT0iMjEiIHkxPSIxOSIgeDI9IjE5IiB5Mj0iMTYiLz4NCjwvc3ZnPg0K",
      "name": "PanelSpriteButton",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Interface Elements/Interface Elements_interface_ui_button_ok_cta_clock_tap.svg",
      "shortDescription": "A button that can be customized.",
      "version": "1.4.4",
      "description": [
        "The button can be customized with a background for each state and a label. It handles user interactions and a simple condition can be used to check if it is clicked.",
        "",
        "There are ready-to-use buttons in the asset-store [menu buttons pack](https://editor.gdevelop.io/?initial-dialog=asset-store&asset-pack=menu-buttons-menu-buttons)."
      ],
      "origin": {
        "identifier": "PanelSpriteButton",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "button",
        "ui"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [],
      "eventsBasedBehaviors": [
        {
          "description": "The finite state machine used internally by the button object.",
          "fullName": "Button finite state machine",
          "name": "ButtonFSM",
          "objectType": "",
          "private": true,
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Finite state machine",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "The \"Validated\" state only last one frame."
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "\"Validated\""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "\"Idle\""
                          ]
                        }
                      ]
                    },
                    {
                      "colorB": 228,
                      "colorG": 176,
                      "colorR": 74,
                      "creationTime": 0,
                      "name": "Check position",
                      "source": "",
                      "type": "BuiltinCommonInstructions::Group",
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Comment",
                          "color": {
                            "b": 109,
                            "g": 230,
                            "r": 255,
                            "textB": 0,
                            "textG": 0,
                            "textR": 0
                          },
                          "comment": "Make sure the cursor position is only checked once per frame."
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyMouseIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "no"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyShouldCheckHovering"
                              },
                              "parameters": [
                                "Object",
                                "Behavior"
                              ]
                            },
                            {
                              "type": {
                                "value": "CollisionPoint"
                              },
                              "parameters": [
                                "Object",
                                "MouseOnlyCursorX(Object.Layer(), 0)",
                                "MouseOnlyCursorY(Object.Layer(), 0)"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyMouseIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "yes"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Comment",
                          "color": {
                            "b": 109,
                            "g": 230,
                            "r": 255,
                            "textB": 0,
                            "textG": 0,
                            "textR": 0
                          },
                          "comment": "Touches are always pressed, so ShouldCheckHovering doesn't matter."
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyTouchIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "no"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyTouchId"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "!=",
                                "0"
                              ]
                            },
                            {
                              "type": {
                                "value": "CollisionPoint"
                              },
                              "parameters": [
                                "Object",
                                "TouchX(Object.Behavior::PropertyTouchId(), Object.Layer(), 0)",
                                "TouchY(Object.Behavior::PropertyTouchId(), Object.Layer(), 0)"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyTouchIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "yes"
                              ]
                            }
                          ]
                        }
                      ],
                      "parameters": []
                    },
                    {
                      "colorB": 228,
                      "colorG": 176,
                      "colorR": 74,
                      "creationTime": 0,
                      "name": "Handle touch start",
                      "source": "",
                      "type": "BuiltinCommonInstructions::Group",
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "HasAnyTouchOrMouseStarted"
                              },
                              "parameters": [
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyIndex"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "0"
                              ]
                            }
                          ],
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::Repeat",
                              "repeatExpression": "StartedTouchOrMouseCount()",
                              "conditions": [],
                              "actions": [],
                              "events": [
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [
                                    {
                                      "type": {
                                        "value": "CollisionPoint"
                                      },
                                      "parameters": [
                                        "Object",
                                        "TouchX(StartedTouchOrMouseId(Object.Behavior::PropertyIndex()), Object.Layer(), 0)",
                                        "TouchY(StartedTouchOrMouseId(Object.Behavior::PropertyIndex()), Object.Layer(), 0)"
                                      ]
                                    }
                                  ],
                                  "actions": [
                                    {
                                      "type": {
                                        "value": "PanelSpriteButton::ButtonFSM::SetPropertyTouchId"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "=",
                                        "StartedTouchOrMouseId(Object.Behavior::PropertyIndex())"
                                      ]
                                    },
                                    {
                                      "type": {
                                        "value": "PanelSpriteButton::ButtonFSM::SetPropertyTouchIsInside"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "yes"
                                      ]
                                    }
                                  ],
                                  "events": [
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "BuiltinCommonInstructions::Or"
                                          },
                                          "parameters": [],
                                          "subInstructions": [
                                            {
                                              "type": {
                                                "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                                              },
                                              "parameters": [
                                                "Object",
                                                "Behavior",
                                                "=",
                                                "\"Hovered\""
                                              ]
                                            },
                                            {
                                              "type": {
                                                "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                                              },
                                              "parameters": [
                                                "Object",
                                                "Behavior",
                                                "=",
                                                "\"Idle\""
                                              ]
                                            }
                                          ]
                                        }
                                      ],
                                      "actions": [
                                        {
                                          "type": {
                                            "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                                          },
                                          "parameters": [
                                            "Object",
                                            "Behavior",
                                            "=",
                                            "\"PressedInside\""
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [],
                                  "actions": [
                                    {
                                      "type": {
                                        "value": "PanelSpriteButton::ButtonFSM::SetPropertyIndex"
                                      },
                                      "parameters": [
                                        "Object",
                                        "Behavior",
                                        "+",
                                        "1"
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ],
                      "parameters": []
                    },
                    {
                      "colorB": 228,
                      "colorG": 176,
                      "colorR": 74,
                      "creationTime": 0,
                      "name": "Apply position changes",
                      "source": "",
                      "type": "BuiltinCommonInstructions::Group",
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "inverted": true,
                                "value": "PanelSpriteButton::ButtonFSM::PropertyMouseIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior"
                              ]
                            },
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"Hovered\""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"Idle\""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyMouseIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior"
                              ]
                            },
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"Idle\""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"Hovered\""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "inverted": true,
                                "value": "PanelSpriteButton::ButtonFSM::PropertyTouchIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior"
                              ]
                            },
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"PressedInside\""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"PressedOutside\""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyTouchIsInside"
                              },
                              "parameters": [
                                "Object",
                                "Behavior"
                              ]
                            },
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"PressedOutside\""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "\"PressedInside\""
                              ]
                            }
                          ]
                        }
                      ],
                      "parameters": []
                    },
                    {
                      "colorB": 228,
                      "colorG": 176,
                      "colorR": 74,
                      "creationTime": 0,
                      "name": "Handle touch end",
                      "source": "",
                      "type": "BuiltinCommonInstructions::Group",
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "HasTouchEnded"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyTouchId()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::ButtonFSM::SetPropertyTouchId"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "0"
                              ]
                            }
                          ],
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "\"PressedInside\""
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "\"Validated\""
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "inverted": true,
                                    "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "\"PressedInside\""
                                  ]
                                },
                                {
                                  "type": {
                                    "inverted": true,
                                    "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "\"Validated\""
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "\"Idle\""
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ],
                      "parameters": []
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onDeActivate",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::ResetState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Reset the state of the button.",
              "fullName": "Reset state",
              "functionType": "Action",
              "name": "ResetState",
              "private": true,
              "sentence": "Reset the button state of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::SetPropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Idle\""
                      ]
                    },
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::SetPropertyTouchId"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button is not used.",
              "fullName": "Is idle",
              "functionType": "Condition",
              "name": "IsIdle",
              "sentence": "_PARAM0_ is idle",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Idle\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button was just clicked.",
              "fullName": "Is clicked",
              "functionType": "Condition",
              "name": "IsClicked",
              "sentence": "_PARAM0_ is clicked",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Validated\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the cursor is hovered over the button.",
              "fullName": "Is hovered",
              "functionType": "Condition",
              "name": "IsHovered",
              "sentence": "_PARAM0_ is hovered",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Hovered\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button is either hovered or pressed but not hovered.",
              "fullName": "Is focused",
              "functionType": "Condition",
              "name": "IsFocused",
              "sentence": "_PARAM0_ is focused",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Hovered\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"PressedOutside\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button is currently being pressed with mouse or touch.",
              "fullName": "Is pressed",
              "functionType": "Condition",
              "name": "IsPressed",
              "sentence": "_PARAM0_ is pressed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"PressedInside\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button is currently being pressed outside with mouse or touch.",
              "fullName": "Is held outside",
              "functionType": "Condition",
              "name": "IsPressedOutside",
              "sentence": "_PARAM0_ is held outside",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::PropertyState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"PressedOutside\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the touch id that is using the button or 0 if none.",
              "fullName": "Touch id",
              "functionType": "ExpressionAndCondition",
              "name": "TouchId",
              "sentence": "the touch id",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyTouchId()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "PanelSpriteButton::ButtonFSM",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "true",
              "type": "Boolean",
              "label": "",
              "description": "Should check hovering",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "ShouldCheckHovering"
            },
            {
              "value": "Idle",
              "type": "Choice",
              "label": "State",
              "description": "",
              "group": "",
              "extraInformation": [
                "Idle",
                "Hovered",
                "PressedInside",
                "PressedOutside",
                "Validated"
              ],
              "hidden": true,
              "name": "State"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Touch id",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TouchId"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Touch is inside",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TouchIsInside"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Mouse is inside",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "MouseIsInside"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Index"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": [
        {
          "defaultName": "Button",
          "description": "A button that can be customized.",
          "fullName": "Button (panel sprite)",
          "name": "PanelSpriteButton",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Create one background instance for of each state.\nOnly the instance for the current state is shown."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Idle",
                        "0",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Hovered",
                        "0",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Pressed",
                        "0",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Hovered"
                      ]
                    },
                    {
                      "type": {
                        "value": "Cache"
                      },
                      "parameters": [
                        "Pressed"
                      ]
                    },
                    {
                      "type": {
                        "value": "ChangePlan"
                      },
                      "parameters": [
                        "Hovered",
                        "=",
                        "1"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Place the label over the backgrounds."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Label",
                        "0",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ChangePlan"
                      },
                      "parameters": [
                        "Label",
                        "=",
                        "2"
                      ]
                    },
                    {
                      "type": {
                        "value": "TextObject::SetWrapping"
                      },
                      "parameters": [
                        "Label",
                        "yes"
                      ]
                    },
                    {
                      "type": {
                        "value": "PanelSpriteButton::PanelSpriteButton::CenterLabel"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": [
                {
                  "name": "Background",
                  "objects": [
                    {
                      "name": "Idle"
                    },
                    {
                      "name": "Hovered"
                    },
                    {
                      "name": "Pressed"
                    }
                  ]
                }
              ]
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onHotReloading",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::PanelSpriteButton::CenterLabel"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Apply states",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "Show the right background accordingly to the new state."
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "PanelSpriteButton::PanelSpriteButton::IsIdle"
                          },
                          "parameters": [
                            "Object",
                            "ButtonFSM"
                          ]
                        },
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::Once"
                          },
                          "parameters": []
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetCenterY"
                          },
                          "parameters": [
                            "Label",
                            "=",
                            "Object.CenterWithPaddingY()"
                          ]
                        },
                        {
                          "type": {
                            "value": "Montre"
                          },
                          "parameters": [
                            "Idle",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Pressed"
                          ]
                        }
                      ],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "Visible"
                              },
                              "parameters": [
                                "Hovered"
                              ]
                            },
                            {
                              "type": {
                                "value": "PanelSpriteButton::PanelSpriteButton::PropertyHoveredFadeOutDuration"
                              },
                              "parameters": [
                                "Object",
                                ">",
                                "0"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "Tween::AddObjectOpacityTween"
                              },
                              "parameters": [
                                "Hovered",
                                "Tween",
                                "\"Fadeout\"",
                                "0",
                                "\"linear\"",
                                "Object.PropertyHoveredFadeOutDuration() * 1000",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PanelSpriteButton::PanelSpriteButton::PropertyHoveredFadeOutDuration"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "0"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "Cache"
                              },
                              "parameters": [
                                "Hovered"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "PanelSpriteObject::Opacity"
                          },
                          "parameters": [
                            "Hovered",
                            "=",
                            "0"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Hovered"
                          ]
                        },
                        {
                          "type": {
                            "value": "PanelSpriteObject::SetOpacity"
                          },
                          "parameters": [
                            "Hovered",
                            "=",
                            "255"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "PanelSpriteButton::PanelSpriteButton::IsHovered"
                          },
                          "parameters": [
                            "Object",
                            "ButtonFSM"
                          ]
                        },
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::Once"
                          },
                          "parameters": []
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetCenterY"
                          },
                          "parameters": [
                            "Label",
                            "=",
                            "Object.CenterWithPaddingY()"
                          ]
                        },
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Idle"
                          ]
                        },
                        {
                          "type": {
                            "value": "Montre"
                          },
                          "parameters": [
                            "Hovered",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Pressed"
                          ]
                        },
                        {
                          "type": {
                            "value": "Tween::RemoveTween"
                          },
                          "parameters": [
                            "Hovered",
                            "Tween",
                            "\"Fadeout\""
                          ]
                        },
                        {
                          "type": {
                            "value": "PanelSpriteObject::SetOpacity"
                          },
                          "parameters": [
                            "Hovered",
                            "=",
                            "255"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "PanelSpriteButton::PanelSpriteButton::IsPressed"
                          },
                          "parameters": [
                            "Object",
                            "ButtonFSM"
                          ]
                        },
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::Once"
                          },
                          "parameters": []
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetCenterY"
                          },
                          "parameters": [
                            "Label",
                            "=",
                            "Object.CenterWithPaddingY() + Object.PropertyPressedLabelOffsetY()"
                          ]
                        },
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Idle"
                          ]
                        },
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Hovered"
                          ]
                        },
                        {
                          "type": {
                            "value": "Montre"
                          },
                          "parameters": [
                            "Pressed",
                            ""
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "PanelSpriteButton::PanelSpriteButton::IsFocused"
                          },
                          "parameters": [
                            "Object",
                            "ButtonFSM"
                          ]
                        },
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::Once"
                          },
                          "parameters": []
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetCenterY"
                          },
                          "parameters": [
                            "Label",
                            "=",
                            "Object.CenterWithPaddingY()"
                          ]
                        },
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Idle"
                          ]
                        },
                        {
                          "type": {
                            "value": "Montre"
                          },
                          "parameters": [
                            "Hovered",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "Cache"
                          },
                          "parameters": [
                            "Pressed"
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Resize",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "Children instances must be resized when the button size change:\n- backgrounds for each state are resized to take the full dimensions of the button\n- the label is put back at the center of the button\n\nThe scale is set back to 1 because it means that the parent instance has the same dimensions as the union of its children instances."
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "BuiltinCommonInstructions::Or"
                          },
                          "parameters": [],
                          "subInstructions": [
                            {
                              "type": {
                                "value": "BuiltinCommonInstructions::CompareNumbers"
                              },
                              "parameters": [
                                "Object.Width()",
                                "!=",
                                "max(Idle.BoundingBoxRight(), Label.BoundingBoxRight()) - min(Idle.BoundingBoxLeft(), Label.BoundingBoxLeft())"
                              ]
                            },
                            {
                              "type": {
                                "value": "BuiltinCommonInstructions::CompareNumbers"
                              },
                              "parameters": [
                                "Object.Height()",
                                "!=",
                                "max(Idle.BoundingBoxBottom(), Label.BoundingBoxBottom()) - min(Idle.BoundingBoxTop(), Label.BoundingBoxTop())"
                              ]
                            }
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ModVarObjet"
                          },
                          "parameters": [
                            "Idle",
                            "Width",
                            "=",
                            "Object.Width()"
                          ]
                        },
                        {
                          "type": {
                            "value": "ModVarObjet"
                          },
                          "parameters": [
                            "Idle",
                            "Height",
                            "=",
                            "Object.Height()"
                          ]
                        },
                        {
                          "type": {
                            "value": "PanelSpriteButton::Scale"
                          },
                          "parameters": [
                            "Object",
                            "=",
                            "1"
                          ]
                        },
                        {
                          "type": {
                            "value": "PanelSpriteObject::Width"
                          },
                          "parameters": [
                            "Background",
                            "=",
                            "Idle.Variable(Width)"
                          ]
                        },
                        {
                          "type": {
                            "value": "PanelSpriteObject::Height"
                          },
                          "parameters": [
                            "Background",
                            "=",
                            "Idle.Variable(Height)"
                          ]
                        },
                        {
                          "type": {
                            "value": "PanelSpriteButton::PanelSpriteButton::CenterLabel"
                          },
                          "parameters": [
                            "Object",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": [
                {
                  "name": "Background",
                  "objects": [
                    {
                      "name": "Idle"
                    },
                    {
                      "name": "Hovered"
                    },
                    {
                      "name": "Pressed"
                    }
                  ]
                }
              ]
            },
            {
              "description": "Check if the button is not used.",
              "fullName": "Is idle",
              "functionType": "Condition",
              "name": "IsIdle",
              "sentence": "_PARAM0_ is idle",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::IsIdle"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button was just clicked.",
              "fullName": "Is clicked",
              "functionType": "Condition",
              "name": "IsClicked",
              "sentence": "_PARAM0_ is clicked",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::IsClicked"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the cursor is hovered over the button.",
              "fullName": "Is hovered",
              "functionType": "Condition",
              "name": "IsHovered",
              "sentence": "_PARAM0_ is hovered",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::IsHovered"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button is either hovered or pressed but not hovered.",
              "fullName": "Is focused",
              "functionType": "Condition",
              "name": "IsFocused",
              "sentence": "_PARAM0_ is focused",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::IsFocused"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the button is currently being pressed with mouse or touch.",
              "fullName": "Is pressed",
              "functionType": "Condition",
              "name": "IsPressed",
              "sentence": "_PARAM0_ is pressed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::ButtonFSM::IsPressed"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the text of the button label.",
              "fullName": "Label text",
              "functionType": "Action",
              "name": "SetLabelText",
              "sentence": "Change the text of _PARAM0_ to _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TextObject::String"
                      },
                      "parameters": [
                        "Label",
                        "=",
                        "GetArgumentAsString(\"LabelText\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "PanelSpriteButton::PanelSpriteButton::CenterLabel"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                },
                {
                  "description": "Text",
                  "name": "LabelText",
                  "type": "string"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the label text.",
              "fullName": "Label text",
              "functionType": "StringExpression",
              "name": "LabelText",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Label.String()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the label center Y according to the button configuration. This expression is used in doStepPostEvents when the button is pressed or released.",
              "fullName": "",
              "functionType": "Expression",
              "name": "CenterWithPaddingY",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Idle.CenterY() + (Object.PropertyTopPadding() - Object.PropertyBottomPadding()) / 2"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Center the label according to the button configuration. This is used in doStepPostEvents when the button is resized.",
              "fullName": "",
              "functionType": "Action",
              "name": "CenterLabel",
              "private": true,
              "sentence": "Center the label of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MettreXY"
                      },
                      "parameters": [
                        "Label",
                        "=",
                        "Object.PropertyLeftPadding()",
                        "=",
                        "Object.PropertyTopPadding()"
                      ]
                    },
                    {
                      "type": {
                        "value": "TextObject::WrappingWidth"
                      },
                      "parameters": [
                        "Label",
                        "=",
                        "Idle.Width() - Object.PropertyLeftPadding() - Object.PropertyRightPadding()"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetCenterY"
                      },
                      "parameters": [
                        "Label",
                        "=",
                        "Object.CenterWithPaddingY()"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "SetCenterX"
                          },
                          "parameters": [
                            "Label",
                            "=",
                            "Background.CenterX() +  (Object.PropertyLeftPadding() - Object.PropertyRightPadding()) / 2"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "PanelSpriteButton::PanelSpriteButton::IsPressed"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "MettreY"
                      },
                      "parameters": [
                        "Label",
                        "+",
                        "Object.PropertyPressedLabelOffsetY()"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": [
                {
                  "name": "Background",
                  "objects": [
                    {
                      "name": "Idle"
                    },
                    {
                      "name": "Hovered"
                    },
                    {
                      "name": "Pressed"
                    }
                  ]
                }
              ]
            },
            {
              "description": "De/activate interactions with the button.",
              "fullName": "De/activate interactions",
              "functionType": "Action",
              "name": "Activate",
              "sentence": "Activate interactions with _PARAM0_: _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldActivate\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ActivateBehavior"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM",
                        "yes"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldActivate\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ActivateBehavior"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM",
                        "no"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                },
                {
                  "description": "Activate",
                  "name": "ShouldActivate",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if interactions are activated on the button.",
              "fullName": "Interactions activated",
              "functionType": "Condition",
              "name": "IsActivated",
              "sentence": "Interactions on _PARAM0_ are activated",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BehaviorActivated"
                      },
                      "parameters": [
                        "Idle",
                        "ButtonFSM"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PanelSpriteButton::PanelSpriteButton",
                  "type": "object"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "0",
              "type": "Number",
              "label": "Label offset on Y axis when pressed",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "PressedLabelOffsetY"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Left padding",
              "description": "",
              "group": "Padding",
              "extraInformation": [
                "Label"
              ],
              "name": "LeftPadding"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Right padding",
              "description": "",
              "group": "Padding",
              "extraInformation": [
                "Label"
              ],
              "name": "RightPadding"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Top padding",
              "description": "",
              "group": "Padding",
              "extraInformation": [
                "Label"
              ],
              "name": "TopPadding"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Bottom padding",
              "description": "",
              "group": "Padding",
              "extraInformation": [
                "Label"
              ],
              "name": "BottomPadding"
            },
            {
              "value": "0.25",
              "type": "Number",
              "label": "Hovered fade out duration (in seconds)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "HoveredFadeOutDuration"
            }
          ],
          "objects": [
            {
              "assetStoreId": "",
              "bold": false,
              "italic": false,
              "name": "Label",
              "smoothed": true,
              "type": "TextObject::Text",
              "underlined": false,
              "variables": [],
              "effects": [],
              "behaviors": [],
              "string": "Text",
              "font": "",
              "textAlignment": "",
              "characterSize": 20,
              "color": {
                "b": 0,
                "g": 0,
                "r": 0
              },
              "content": {
                "bold": false,
                "isOutlineEnabled": false,
                "isShadowEnabled": false,
                "italic": false,
                "outlineColor": "255;255;255",
                "outlineThickness": 2,
                "shadowAngle": 90,
                "shadowBlurRadius": 2,
                "shadowColor": "0;0;0",
                "shadowDistance": 4,
                "shadowOpacity": 127,
                "smoothed": true,
                "underlined": false,
                "text": "Text",
                "font": "",
                "textAlignment": "",
                "characterSize": 20,
                "color": "0;0;0"
              }
            },
            {
              "assetStoreId": "",
              "bottomMargin": 0,
              "height": 32,
              "leftMargin": 0,
              "name": "Idle",
              "rightMargin": 0,
              "texture": "",
              "tiled": false,
              "topMargin": 0,
              "type": "PanelSpriteObject::PanelSprite",
              "width": 32,
              "variables": [
                {
                  "folded": true,
                  "name": "State",
                  "type": "string",
                  "value": "Idle"
                }
              ],
              "effects": [],
              "behaviors": [
                {
                  "name": "ButtonFSM",
                  "type": "PanelSpriteButton::ButtonFSM",
                  "ShouldCheckHovering": true
                }
              ]
            },
            {
              "assetStoreId": "",
              "bottomMargin": 0,
              "height": 32,
              "leftMargin": 0,
              "name": "Hovered",
              "rightMargin": 0,
              "texture": "",
              "tiled": false,
              "topMargin": 0,
              "type": "PanelSpriteObject::PanelSprite",
              "width": 32,
              "variables": [],
              "effects": [],
              "behaviors": [
                {
                  "name": "Tween",
                  "type": "Tween::TweenBehavior"
                }
              ]
            },
            {
              "assetStoreId": "",
              "bottomMargin": 0,
              "height": 32,
              "leftMargin": 0,
              "name": "Pressed",
              "rightMargin": 0,
              "texture": "",
              "tiled": false,
              "topMargin": 0,
              "type": "PanelSpriteObject::PanelSprite",
              "width": 32,
              "variables": [],
              "effects": [],
              "behaviors": []
            }
          ],
          "objectsFolderStructure": {
            "folderName": "__ROOT",
            "children": [
              {
                "objectName": "Label"
              },
              {
                "objectName": "Idle"
              },
              {
                "objectName": "Hovered"
              },
              {
                "objectName": "Pressed"
              }
            ]
          }
        }
      ]
    },
    {
      "author": "Tristan Rhodes (tristan@victrisgames.com), Entropy",
      "category": "Movement",
      "extensionNamespace": "",
      "fullName": "Screen wrap",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLW1vbml0b3Itc2NyZWVuc2hvdCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik05LDZINVYxMEg3VjhIOU0xOSwxMEgxN1YxMkgxNVYxNEgxOU0yMSwxNkgzVjRIMjFNMjEsMkgzQzEuODksMiAxLDIuODkgMSw0VjE2QTIsMiAwIDAsMCAzLDE4SDEwVjIwSDhWMjJIMTZWMjBIMTRWMThIMjFBMiwyIDAgMCwwIDIzLDE2VjRDMjMsMi44OSAyMi4xLDIgMjEsMiIgLz48L3N2Zz4=",
      "name": "ScreenWrap",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/monitor-screenshot.svg",
      "shortDescription": "Teleport object when it moves off the screen and immediately appear on the opposite side while maintaining speed and trajectory.",
      "version": "0.2.4",
      "description": [
        "The teleport happens when the center point of the object crosses a border (this can be adjusted with an offset).",
        "By default, the borders of the wrapping area match the screen size, but they can alo be changed.",
        "",
        "The Asteroid-like example uses this extension ([open the project online](https://editor.gdevelop.io/?project=example://space-asteroid))."
      ],
      "origin": {
        "identifier": "ScreenWrap",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "screen",
        "wrap",
        "teleport",
        "asteroids"
      ],
      "authorIds": [
        "q8ubdigLvIRXLxsJDDTaokO41mc2",
        "gqDaZjCfevOOxBYkK6zlhtZnXCg1",
        "1OgYzWp5UeVPbiWGJwI6vqfgZLC3"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [],
      "eventsBasedBehaviors": [
        {
          "description": "Teleport the object when leaving one side of the screen so that it immediately reappears on the opposite side, maintaining speed and trajectory.",
          "fullName": "Screen Wrap",
          "name": "ScreenWrap",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Initialize variables (if needed)",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrap::PropertyBorderBottom"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "0"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrap::SetBottomBorder"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "SceneWindowHeight()",
                            ""
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrap::PropertyBorderRight"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "0"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrap::SetRightBorder"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "SceneWindowWidth()",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "colorB": 5,
                  "colorG": 117,
                  "colorR": 65,
                  "creationTime": 0,
                  "name": "ScreenWrap",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "colorB": 228,
                      "colorG": 176,
                      "colorR": 74,
                      "creationTime": 0,
                      "name": "Move object to opposite side (if needed)",
                      "source": "",
                      "type": "BuiltinCommonInstructions::Group",
                      "events": [],
                      "parameters": []
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrap::PropertyHorizontalWrapping"
                          },
                          "parameters": [
                            "Object",
                            "Behavior"
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosX"
                              },
                              "parameters": [
                                "Object",
                                "<",
                                "Object.Behavior::PropertyBorderLeft() - (Object.Width()/2) - Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "MettreX"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderRight() - (Object.Width()/2) +  Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosX"
                              },
                              "parameters": [
                                "Object",
                                ">",
                                "Object.Behavior::PropertyBorderRight() - (Object.Width()/2) + Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "MettreX"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderLeft() - (Object.Width()/2) -  Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrap::PropertyVerticalWrapping"
                          },
                          "parameters": [
                            "Object",
                            "Behavior"
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosY"
                              },
                              "parameters": [
                                "Object",
                                "<",
                                "Object.Behavior::PropertyBorderTop() - (Object.Height()/2) - Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "MettreY"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderBottom() - (Object.Height()/2) + Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosY"
                              },
                              "parameters": [
                                "Object",
                                ">",
                                "Object.Behavior::PropertyBorderBottom() - (Object.Height()/2) + Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "MettreY"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderTop() - (Object.Height()/2) -  Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object is wrapping on the left and right borders.",
              "fullName": "Is horizontal wrapping",
              "functionType": "Condition",
              "name": "IsHorizontalWrapping",
              "sentence": "_PARAM0_ is horizontal wrapping",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "ScreenWrap::ScreenWrap::PropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::PropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object is wrapping on the top and bottom borders.",
              "fullName": "Is vertical wrapping",
              "functionType": "Condition",
              "name": "IsVerticalWrapping",
              "sentence": "_PARAM0_ is vertical wrapping",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "ScreenWrap::ScreenWrap::PropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::PropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Enable wrapping on the left and right borders.",
              "fullName": "Enable horizontal wrapping",
              "functionType": "Action",
              "name": "EnableHorizontalWrapping",
              "sentence": "Enable _PARAM0_ horizontal wrapping: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableHorizontalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableHorizontalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "EnableHorizontalWrapping",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Enable wrapping on the top and bottom borders.",
              "fullName": "Enable vertical wrapping",
              "functionType": "Action",
              "name": "EnableVerticalWrapping",
              "sentence": "Enable _PARAM0_ vertical wrapping: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableVerticalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableVerticalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "EnableVerticalWrapping",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Top border (Y position).",
              "fullName": "Top border",
              "functionType": "Expression",
              "name": "BorderTop",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderTop()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Left border (X position).",
              "fullName": "Left border",
              "functionType": "Expression",
              "name": "BorderLeft",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderLeft()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Right border (X position).",
              "fullName": "Right border",
              "functionType": "Expression",
              "name": "BorderRight",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderRight()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Bottom border (Y position).",
              "fullName": "Bottom border",
              "functionType": "Expression",
              "name": "BorderBottom",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderBottom()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Number of pixels past the center where the object teleports and appears.",
              "fullName": "Trigger offset",
              "functionType": "Expression",
              "name": "TriggerOffset",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyTriggerOffset()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set top border (Y position).",
              "fullName": "Set top border",
              "functionType": "Action",
              "name": "SetTopBorder",
              "sentence": "Set _PARAM0_ top border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyBorderTop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                },
                {
                  "description": "Top border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set left border (X position).",
              "fullName": "Set left border",
              "functionType": "Action",
              "name": "SetLeftBorder",
              "sentence": "Set _PARAM0_ left border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyBorderLeft"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                },
                {
                  "description": "Left border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set bottom border (Y position).",
              "fullName": "Set bottom border",
              "functionType": "Action",
              "name": "SetBottomBorder",
              "sentence": "Set _PARAM0_ bottom border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyBorderBottom"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                },
                {
                  "description": "Bottom border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set right border (X position).",
              "fullName": "Set right border",
              "functionType": "Action",
              "name": "SetRightBorder",
              "sentence": "Set _PARAM0_ right border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyBorderRight"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                },
                {
                  "description": "Right border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set trigger offset (pixels).",
              "fullName": "Set trigger offset",
              "functionType": "Action",
              "name": "SetTriggerOffset",
              "sentence": "Set _PARAM0_ trigger offset to _PARAM2_ pixels",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrap::SetPropertyTriggerOffset"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrap",
                  "type": "behavior"
                },
                {
                  "description": "SetScreen Offset Leaving Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "true",
              "type": "Boolean",
              "label": "Horizontal wrapping",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "HorizontalWrapping"
            },
            {
              "value": "true",
              "type": "Boolean",
              "label": "Vertical wrapping",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "VerticalWrapping"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Top border of wrapped area (Y)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "BorderTop"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Left border of wrapped area (X)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "BorderLeft"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Right border of wrapped area (X)",
              "description": "If blank, the value will be the scene width.",
              "group": "",
              "extraInformation": [],
              "name": "BorderRight"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Bottom border of wrapped area (Y)",
              "description": "If blank, the value will be scene height.",
              "group": "",
              "extraInformation": [],
              "name": "BorderBottom"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Number of pixels past the center where the object teleports and appears",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "TriggerOffset"
            }
          ],
          "sharedPropertyDescriptors": []
        },
        {
          "description": "Teleport the object when leaving one side of the screen so that it immediately reappears on the opposite side, maintaining speed and trajectory.",
          "fullName": "Screen Wrap (physics objects)",
          "name": "ScreenWrapPhysics",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Initialize variables (if needed)",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrapPhysics::PropertyBorderBottom"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "0"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrapPhysics::SetBottomBorder"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "SceneWindowHeight()",
                            ""
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrapPhysics::PropertyBorderRight"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "0"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrapPhysics::SetRightBorder"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "SceneWindowWidth()",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "colorB": 5,
                  "colorG": 117,
                  "colorR": 65,
                  "creationTime": 0,
                  "name": "ScreenWrap",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "colorB": 228,
                      "colorG": 176,
                      "colorR": 74,
                      "creationTime": 0,
                      "name": "Move object to opposite side (if needed)",
                      "source": "",
                      "type": "BuiltinCommonInstructions::Group",
                      "events": [],
                      "parameters": []
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrapPhysics::IsHorizontalWrapping"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Comment",
                          "color": {
                            "b": 109,
                            "g": 230,
                            "r": 255,
                            "textB": 0,
                            "textG": 0,
                            "textR": 0
                          },
                          "comment": "Velocity is saved because Physics2 resets objects velocities when they are moved from the outside of the extension."
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosX"
                              },
                              "parameters": [
                                "Object",
                                "<",
                                "Object.Behavior::PropertyBorderLeft() - (Object.Width()/2) - Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::SaveCurrentVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "MettreX"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderRight() - (Object.Width()/2) +  Object.Behavior::PropertyTriggerOffset()"
                              ]
                            },
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::ApplySavedVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosX"
                              },
                              "parameters": [
                                "Object",
                                ">",
                                "Object.Behavior::PropertyBorderRight() - (Object.Width()/2) + Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::SaveCurrentVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "MettreX"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderLeft() - (Object.Width()/2) -  Object.Behavior::PropertyTriggerOffset()"
                              ]
                            },
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::ApplySavedVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ScreenWrap::ScreenWrapPhysics::IsVerticalWrapping"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosY"
                              },
                              "parameters": [
                                "Object",
                                "<",
                                "Object.Behavior::PropertyBorderTop() - (Object.Height()/2) - Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::SaveCurrentVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "MettreY"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderBottom() - (Object.Height()/2) + Object.Behavior::PropertyTriggerOffset()"
                              ]
                            },
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::ApplySavedVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "PosY"
                              },
                              "parameters": [
                                "Object",
                                ">",
                                "Object.Behavior::PropertyBorderBottom() - (Object.Height()/2) + Object.Behavior::PropertyTriggerOffset()"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::SaveCurrentVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "MettreY"
                              },
                              "parameters": [
                                "Object",
                                "=",
                                "Object.Behavior::PropertyBorderTop() - (Object.Height()/2) -  Object.Behavior::PropertyTriggerOffset()"
                              ]
                            },
                            {
                              "type": {
                                "value": "ScreenWrap::ScreenWrapPhysics::ApplySavedVelocities"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                ""
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object is wrapping on the left and right borders.",
              "fullName": "Is horizontal wrapping",
              "functionType": "Condition",
              "name": "IsHorizontalWrapping",
              "sentence": "_PARAM0_ is horizontal wrapping",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "ScreenWrap::ScreenWrapPhysics::PropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::PropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the object is wrapping on the top and bottom borders.",
              "fullName": "Is vertical wrapping",
              "functionType": "Condition",
              "name": "IsVerticalWrapping",
              "sentence": "_PARAM0_ is vertical wrapping",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "ScreenWrap::ScreenWrapPhysics::PropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::PropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Enable wrapping on the left and right borders.",
              "fullName": "Enable horizontal wrapping",
              "functionType": "Action",
              "name": "EnableHorizontalWrapping",
              "sentence": "Enable _PARAM0_ horizontal wrapping: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableHorizontalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableHorizontalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyHorizontalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "EnableHorizontalWrapping",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Enable wrapping on the top and bottom borders.",
              "fullName": "Enable vertical wrapping",
              "functionType": "Action",
              "name": "EnableVerticalWrapping",
              "sentence": "Enable _PARAM0_ vertical wrapping: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableVerticalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"EnableVerticalWrapping\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyVerticalWrapping"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "EnableVerticalWrapping",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Top border (Y position).",
              "fullName": "Top border",
              "functionType": "Expression",
              "name": "BorderTop",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderTop()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Left border (X position).",
              "fullName": "Left border",
              "functionType": "Expression",
              "name": "BorderLeft",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderLeft()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Right border (X position).",
              "fullName": "Right border",
              "functionType": "Expression",
              "name": "BorderRight",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderRight()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Bottom border (Y position).",
              "fullName": "Bottom border",
              "functionType": "Expression",
              "name": "BorderBottom",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyBorderBottom()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Number of pixels past the center where the object teleports and appears.",
              "fullName": "Trigger offset",
              "functionType": "Expression",
              "name": "TriggerOffset",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyTriggerOffset()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set top border (Y position).",
              "fullName": "Set top border",
              "functionType": "Action",
              "name": "SetTopBorder",
              "sentence": "Set _PARAM0_ top border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyBorderTop"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                },
                {
                  "description": "Top border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set left border (X position).",
              "fullName": "Set left border",
              "functionType": "Action",
              "name": "SetLeftBorder",
              "sentence": "Set _PARAM0_ left border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyBorderLeft"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                },
                {
                  "description": "Left border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set bottom border (Y position).",
              "fullName": "Set bottom border",
              "functionType": "Action",
              "name": "SetBottomBorder",
              "sentence": "Set _PARAM0_ bottom border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyBorderBottom"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                },
                {
                  "description": "Bottom border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set right border (X position).",
              "fullName": "Set right border",
              "functionType": "Action",
              "name": "SetRightBorder",
              "sentence": "Set _PARAM0_ right border to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyBorderRight"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                },
                {
                  "description": "Right border value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Set trigger offset (pixels).",
              "fullName": "Set trigger offset",
              "functionType": "Action",
              "name": "SetTriggerOffset",
              "sentence": "Set _PARAM0_ trigger offset to _PARAM2_ pixels",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyTriggerOffset"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                },
                {
                  "description": "SetScreen Offset Leaving Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Save current velocity values.",
              "fullName": "Save current velocity values",
              "functionType": "Action",
              "name": "SaveCurrentVelocities",
              "sentence": "Save current velocity values of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyAngularVelocity"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.RequiredPhysicsBehavior::AngularVelocity()"
                      ]
                    },
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyLinearVelocityX"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.RequiredPhysicsBehavior::LinearVelocityX()"
                      ]
                    },
                    {
                      "type": {
                        "value": "ScreenWrap::ScreenWrapPhysics::SetPropertyLinearVelocityY"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.RequiredPhysicsBehavior::LinearVelocityY()"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Apply saved velocity values.",
              "fullName": "Apply saved velocity values",
              "functionType": "Action",
              "name": "ApplySavedVelocities",
              "sentence": "Apply saved velocity values of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Physics2::AngularVelocity"
                      },
                      "parameters": [
                        "Object",
                        "RequiredPhysicsBehavior",
                        "=",
                        "Object.Behavior::PropertyAngularVelocity()"
                      ]
                    },
                    {
                      "type": {
                        "value": "Physics2::LinearVelocityX"
                      },
                      "parameters": [
                        "Object",
                        "RequiredPhysicsBehavior",
                        "=",
                        "Object.Behavior::PropertyLinearVelocityX()"
                      ]
                    },
                    {
                      "type": {
                        "value": "Physics2::LinearVelocityY"
                      },
                      "parameters": [
                        "Object",
                        "RequiredPhysicsBehavior",
                        "=",
                        "Object.Behavior::PropertyLinearVelocityY()"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ScreenWrap::ScreenWrapPhysics",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "",
              "type": "Behavior",
              "label": "Physics Behavior",
              "description": "",
              "group": "",
              "extraInformation": [
                "Physics2::Physics2Behavior"
              ],
              "name": "RequiredPhysicsBehavior"
            },
            {
              "value": "true",
              "type": "Boolean",
              "label": "Horizontal wrapping",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "HorizontalWrapping"
            },
            {
              "value": "true",
              "type": "Boolean",
              "label": "Vertical wrapping",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "VerticalWrapping"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Top border of wrapped area (Y)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "BorderTop"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Left border of wrapped area (X)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "BorderLeft"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Right border of wrapped area (X)",
              "description": "If blank, the value will be the scene width.",
              "group": "",
              "extraInformation": [],
              "name": "BorderRight"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Bottom border of wrapped area (Y)",
              "description": "If blank, the value will be scene height.",
              "group": "",
              "extraInformation": [],
              "name": "BorderBottom"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Number of pixels past the center where the object teleports and appears",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "TriggerOffset"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Angular Velocity",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "AngularVelocity"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Linear Velocity X",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "LinearVelocityX"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Linear Velocity Y",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "LinearVelocityY"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "D8H",
      "category": "Movement",
      "extensionNamespace": "",
      "fullName": "Stick objects to others",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXN0aWNrZXItb3V0bGluZSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik01LjUgMkMzLjYgMiAyIDMuNiAyIDUuNVYxOC41QzIgMjAuNCAzLjYgMjIgNS41IDIySDE2TDIyIDE2VjUuNUMyMiAzLjYgMjAuNCAyIDE4LjUgMkg1LjVNNS44IDRIMTguM0MxOS4zIDQgMjAuMSA0LjggMjAuMSA1LjhWMTVIMTguNkMxNi43IDE1IDE1LjEgMTYuNiAxNS4xIDE4LjVWMjBINS44QzQuOCAyMCA0IDE5LjIgNCAxOC4yVjUuOEM0IDQuOCA0LjggNCA1LjggNCIgLz48L3N2Zz4=",
      "name": "Sticker",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/sticker-outline.svg",
      "shortDescription": "Make objects follow the position and rotation of the object they are stuck to.",
      "version": "0.5.1",
      "description": [
        "This extension can be useful to:",
        "* Stick accessories to moving objects",
        "* Animate a skeleton",
        "* Delete an object with another one",
        "",
        "An example allows to check it out ([open the project online](https://editor.gdevelop.io/?project=example://stick-objects))."
      ],
      "origin": {
        "identifier": "Sticker",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "sticker",
        "stick",
        "follow",
        "skeleton",
        "joint",
        "pin",
        "bind",
        "glue",
        "tie",
        "attach",
        "hold",
        "paste",
        "wear"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs._stickerExtension) {",
                "    return;",
                "}",
                "",
                "// Unstick from deleted objects.",
                "gdjs.registerObjectDeletedFromSceneCallback(function (runtimeScene, deletedObject) {",
                "    const extension = runtimeScene._stickerExtension;",
                "    if (!extension) {",
                "        return;",
                "    }",
                "    const allStickers = runtimeScene._stickerExtension.allStickers;",
                "    for (const behavior of allStickers) {",
                "        const sticker = behavior._sticker;",
                "        if (sticker.isStuckTo(deletedObject)) {",
                "            if (behavior._getIsDestroyedWithParent()) {",
                "                behavior.owner.deleteFromScene(runtimeScene);",
                "            }",
                "            sticker.unstick();",
                "        }",
                "    }",
                "});",
                "",
                "class Sticker {",
                "    /** @type {gdjs.RuntimeBehavior} */",
                "    behavior;",
                "    /** @type {gdjs.RuntimeObject | null} */",
                "    basisObject;",
                "    followingDoneThisFrame = false;",
                "    relativeX = 0;",
                "    relativeY = 0;",
                "    relativeAngle = 0;",
                "    relativeRotatedX = 0;",
                "    relativeRotatedY = 0;",
                "    basisOldX = 0;",
                "    basisOldY = 0;",
                "    basisOldAngle = 0;",
                "    basisOldWidth = 0;",
                "    basisOldHeight = 0;",
                "    basisOldCenterXInScene = 0;",
                "    basisOldCenterYInScene = 0;",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeBehavior} behavior",
                "     */",
                "    constructor(behavior) {",
                "        this.behavior = behavior;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} basisObject",
                "     */",
                "    isStuckTo(basisObject) {",
                "        return this.basisObject === basisObject;",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} basisObject",
                "     */",
                "    stickTo(basisObject) {",
                "        this.basisObject = basisObject;",
                "        this.updateOldCoordinates();",
                "        this.updateRelativeCoordinates();",
                "    }",
                "",
                "    unstick() {",
                "        this.basisObject = null;",
                "    }",
                "",
                "    onStepPreEvents() {",
                "        this.followingDoneThisFrame = false;",
                "    }",
                "",
                "    /**",
                "     * Update the coordinates in the basisObject basis.",
                "     * ",
                "     * It uses the basisObject coordinates from the previous frame.",
                "     * This way, the sticker can move relatively to it and still",
                "     * follow basisObject.",
                "     * ",
                "     * @param {gdjs.RuntimeObject} basisObject",
                "     */",
                "    updateRelativeCoordinates() {",
                "        const object = this.behavior.owner;",
                "",
                "        // Update relative coordinates",
                "        this.relativeX = object.getX() - this.basisOldX;",
                "        this.relativeY = object.getY() - this.basisOldY;",
                "        if (!this.behavior._getOnlyFollowPosition()) {",
                "            this.relativeAngle = object.getAngle() - this.basisOldAngle;",
                "            this.relativeWidth = object.getWidth() / this.basisOldWidth;",
                "            this.relativeHeight = object.getHeight() / this.basisOldHeight;",
                "            const deltaX = object.getCenterXInScene() - this.basisOldCenterXInScene;",
                "            const deltaY = object.getCenterYInScene() - this.basisOldCenterYInScene;",
                "            const angle = this.basisOldAngle * Math.PI / 180;",
                "            this.relativeRotatedX = (deltaX * Math.cos(angle) + deltaY * Math.sin(angle)) / this.basisOldWidth;",
                "            this.relativeRotatedY = (-deltaX * Math.sin(angle) + deltaY * Math.cos(angle)) / this.basisOldHeight;",
                "",
                "            // Save initial values to avoid calculus and rounding errors",
                "            this.basisOriginalWidth = this.basisObject.getWidth();",
                "            this.basisOriginalHeight = this.basisObject.getHeight();",
                "            this.basisOriginalAngle = this.basisObject.getAngle();",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Copy the coordinates to use it the next frame.",
                "     */",
                "    updateOldCoordinates() {",
                "        const object = this.behavior.owner;",
                "",
                "        this.ownerOldX = object.getX();",
                "        this.ownerOldY = object.getY();",
                "",
                "        this.basisOldX = this.basisObject.getX();",
                "        this.basisOldY = this.basisObject.getY();",
                "",
                "        if (!this.behavior._getOnlyFollowPosition()) {",
                "            this.ownerOldAngle = object.getAngle();",
                "            this.ownerOldWidth = object.getWidth();",
                "            this.ownerOldHeight = object.getHeight();",
                "",
                "            this.basisOldAngle = this.basisObject.getAngle();",
                "            this.basisOldWidth = this.basisObject.getWidth();",
                "            this.basisOldHeight = this.basisObject.getHeight();",
                "            this.basisOldCenterXInScene = this.basisObject.getCenterXInScene();",
                "            this.basisOldCenterYInScene = this.basisObject.getCenterYInScene();",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Follow the basisObject (called in doStepPostEvents).",
                "     * ",
                "     * This method is also called by children to ensure",
                "     * parents are updated first.",
                "     */",
                "    followBasisObject() {",
                "        if (this.followingDoneThisFrame) {",
                "            return;",
                "        }",
                "        this.followingDoneThisFrame = true;",
                "        const basisObject = this.basisObject;",
                "        if (basisObject) {",
                "            // If the behavior on the basis object has a different name,",
                "            // the objects will still follow their basis objects",
                "            // but frame delays could happen.",
                "            const behaviorName = this.behavior.getName();",
                "            if (basisObject.hasBehavior(behaviorName)) {",
                "                const basisBehavior = basisObject.getBehavior(behaviorName);",
                "                if (basisBehavior.type === this.behavior.type) {",
                "                    // Follow parents 1st to avoid frame delays",
                "                    basisBehavior._sticker.followBasisObject();",
                "                }",
                "            }",
                "",
                "            const object = this.behavior.owner;",
                "",
                "            if (this.behavior._getOnlyFollowPosition()) {",
                "                if (object.getX() !== this.ownerOldX",
                "                    || object.getY() !== this.ownerOldY) {",
                "                    this.updateRelativeCoordinates();",
                "                }",
                "",
                "                if (this.basisOldX !== basisObject.getX() ||",
                "                    this.basisOldY !== basisObject.getY()) {",
                "                    object.setPosition(",
                "                        basisObject.getX() + this.relativeX,",
                "                        basisObject.getY() + this.relativeY);",
                "                }",
                "            } else {",
                "                if (object.getX() !== this.ownerOldX",
                "                    || object.getY() !== this.ownerOldY",
                "                    || object.getAngle() !== this.ownerOldAngle",
                "                    || object.getWidth() !== this.ownerOldWidth",
                "                    || object.getHeight() !== this.ownerOldHeight) {",
                "                    this.updateRelativeCoordinates();",
                "                }",
                "",
                "                // Follow basisObject",
                "                if (basisObject.getAngle() === this.basisOriginalAngle && this.basisOriginalAngle === 0) {",
                "                    if (basisObject.getWidth() === this.basisOriginalWidth ||",
                "                        basisObject.getHeight() === this.basisOriginalHeight) {",
                "                        if (this.basisOldX !== basisObject.getX() ||",
                "                            this.basisOldY !== basisObject.getY()) {",
                "                            object.setPosition(",
                "                                basisObject.getX() + this.relativeX,",
                "                                basisObject.getY() + this.relativeY);",
                "                        }",
                "                    } else {",
                "                        object.setCenterPositionInScene(",
                "                            basisObject.getCenterXInScene() + this.relativeRotatedX * basisObject.getWidth(),",
                "                            basisObject.getCenterYInScene() + this.relativeRotatedY * basisObject.getHeight());",
                "                    }",
                "                } else {",
                "                    object.setAngle(basisObject.getAngle() + this.relativeAngle);",
                "",
                "                    const deltaX = this.relativeRotatedX * basisObject.getWidth();",
                "                    const deltaY = this.relativeRotatedY * basisObject.getHeight();",
                "                    const angle = -basisObject.getAngle() * Math.PI / 180;",
                "                    object.setX(basisObject.getCenterXInScene() + object.getX() - object.getCenterXInScene() + deltaX * Math.cos(angle) + deltaY * Math.sin(angle));",
                "                    object.setY(basisObject.getCenterYInScene() + object.getY() - object.getCenterYInScene() - deltaX * Math.sin(angle) + deltaY * Math.cos(angle));",
                "                }",
                "                // Unproportional dimensions changes won't work as expected",
                "                // if the object angle is not null but nothing more can be done",
                "                // because there is no full affine transformation on objects.",
                "                if (basisObject.getWidth() !== this.basisOriginalWidth) {",
                "                    object.setWidth(this.relativeWidth * basisObject.getWidth());",
                "                }",
                "                if (basisObject.getHeight() !== this.basisOriginalHeight) {",
                "                    object.setHeight(this.relativeHeight * basisObject.getHeight());",
                "                }",
                "            }",
                "",
                "            this.updateOldCoordinates();",
                "        }",
                "    }",
                "}",
                "",
                "gdjs._stickerExtension = {",
                "    Sticker",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Check if the object is stuck to another object.",
          "fullName": "Is stuck to another object",
          "functionType": "Condition",
          "name": "IsStuck",
          "sentence": "_PARAM1_ is stuck to _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const stickerBehaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const stickerObjectsLists = eventsFunctionContext.getObjectsLists(\"Object\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const basisObjectsLists = eventsFunctionContext.getObjectsLists(\"BasisObject\");",
                "",
                "eventsFunctionContext.returnValue = gdjs.evtTools.object.twoListsTest(",
                "  (stickerObject, basisObject) => {",
                "    const sticker = stickerObject.getBehavior(stickerBehaviorName)._sticker;",
                "    return sticker.isStuckTo(basisObject);",
                "  },",
                "  stickerObjectsLists,",
                "  basisObjectsLists,",
                "  false",
                ");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Sticker",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Sticker behavior",
              "name": "Behavior",
              "supplementaryInformation": "Sticker::Sticker",
              "type": "behavior"
            },
            {
              "description": "Basis",
              "name": "BasisObject",
              "type": "objectList"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "Stick the object to another. Use the action to stick the object, or unstick it later.",
          "fullName": "Sticker",
          "name": "Sticker",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Sticker::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const Sticker = gdjs._stickerExtension.Sticker;",
                    "",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const object = objects[0];",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "behavior._sticker = new Sticker(behavior);",
                    "",
                    "// Set up the scene sticker objects list - if not done already.",
                    "runtimeScene._stickerExtension = runtimeScene._stickerExtension || {",
                    "    allStickers: new Set(),",
                    "};",
                    "// Register this object as a sticker.",
                    "runtimeScene._stickerExtension.allStickers.add(behavior);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "Sticker::Sticker",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const object = objects[0];",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "behavior._sticker.onStepPreEvents();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "Sticker::Sticker",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const object = objects[0];",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "behavior._sticker.followBasisObject();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "Sticker::Sticker",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Stick on another object.",
              "fullName": "Stick",
              "functionType": "Action",
              "name": "Stick",
              "sentence": "Stick _PARAM0_ to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const basisObjects = eventsFunctionContext.getObjects(\"BasisObject\");",
                    "",
                    "if (basisObjects.length === 0) return;",
                    "// An object can stick to only one object.",
                    "const basisObject = basisObjects[0];",
                    "object.getBehavior(behaviorName)._sticker.stickTo(basisObject);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "Sticker::Sticker",
                  "type": "behavior"
                },
                {
                  "description": "Object to stick to",
                  "name": "BasisObject",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Unstick from the object it was stuck to.",
              "fullName": "Unstick",
              "functionType": "Action",
              "name": "Unstick",
              "sentence": "Unstick _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "object.getBehavior(behaviorName)._sticker.unstick();",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "Sticker::Sticker",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onDestroy",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const object = objects[0];",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "runtimeScene._stickerExtension.allStickers.delete(behavior._sticker);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "Sticker::Sticker",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "",
              "type": "Boolean",
              "label": "Only follow the position",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "OnlyFollowPosition"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Destroy when the object it's stuck on is destroyed",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "IsDestroyedWithParent"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "Silver-Streak, @Bouh, Tristan Rhodes",
      "category": "Game mechanic",
      "extensionNamespace": "",
      "fullName": "Object \"Is On Screen\" Detection",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLW1vbml0b3Itc2NyZWVuc2hvdCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik05LDZINVYxMEg3VjhIOU0xOSwxMEgxN1YxMkgxNVYxNEgxOU0yMSwxNkgzVjRIMjFNMjEsMkgzQzEuODksMiAxLDIuODkgMSw0VjE2QTIsMiAwIDAsMCAzLDE4SDEwVjIwSDhWMjJIMTZWMjBIMTRWMThIMjFBMiwyIDAgMCwwIDIzLDE2VjRDMjMsMi44OSAyMi4xLDIgMjEsMiIgLz48L3N2Zz4=",
      "name": "IsOnScreen",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/monitor-screenshot.svg",
      "shortDescription": "This adds a condition to detect if an object is on screen based off its current layer.",
      "version": "1.2.1",
      "description": [
        "This extension adds conditions to check if an object is located within the visible portion of its layer's camera. The condition also allows for specifying padding to the virtual screen border.",
        "",
        "Note that this does not take into account any object visibility, such as being hidden or 0 opacity, but can be combined with those existing conditions."
      ],
      "origin": {
        "identifier": "IsOnScreen",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "is on screen",
        "condition",
        "visible",
        "hide",
        "screen"
      ],
      "authorIds": [
        "2OwwM8ToR9dx9RJ2sAKTcrLmCB92",
        "8Ih1aa8f5gWUp4UB2BdhQ2iXWxJ3",
        "gqDaZjCfevOOxBYkK6zlhtZnXCg1"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [],
      "eventsBasedBehaviors": [
        {
          "description": "This behavior provides a condition to check if the object is located within the visible portion of its layer's camera. The condition also allows for specifying padding to the virtual screen border.\nNote that object visibility, such as being hidden or 0 opacity, is not considered (but you can use those existing conditions in addition to this behavior).",
          "fullName": "Is on screen",
          "name": "InOnScreen",
          "objectType": "",
          "eventsFunctions": [
            {
              "description": "Checks if an object position is within the viewport of its layer.",
              "fullName": "Is on screen",
              "functionType": "Condition",
              "name": "IsOnScreen",
              "sentence": "_PARAM0_ is on screen (padded by _PARAM2_ pixels)",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/*",
                    "Get the object layer, convert the position from this layer to the screen coordinates.",
                    "Get the point on each side on the object on screen, and compare with the screen area.",
                    "",
                    "This way even if the camera has a rotation or custom scale the object is always compared to the screen area.",
                    "*/",
                    "",
                    "",
                    "// Get the layer of the object.",
                    "const object = objects[0];",
                    "const layer = runtimeScene.getLayer(object.getLayer());",
                    "",
                    "// Get the aabb of the object on his layer.",
                    "const aabb = object.getVisibilityAABB();",
                    "",
                    "// Get the layer to convert the coordinates of the AABB to the screen coordinates",
                    "const topLeft = layer.convertInverseCoords(aabb.min[0], aabb.min[1]);",
                    "const topRight = layer.convertInverseCoords(aabb.max[0], aabb.min[1]);",
                    "const bottomRight = layer.convertInverseCoords(aabb.max[0], aabb.max[1]);",
                    "const bottomLeft = layer.convertInverseCoords(aabb.min[0], aabb.max[1]);",
                    "",
                    "// Get the points on each side of the object on screen.",
                    "const posLeftObjectOnScreen = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);",
                    "const posRightObjectOnScreen = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);",
                    "const posUpObjectOnScreen = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);",
                    "const posDownObjectOnScreen = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);",
                    "",
                    "const padding = eventsFunctionContext.getArgument(\"Padding\");",
                    "",
                    "if (",
                    "    !(posLeftObjectOnScreen - padding > runtimeScene.getGame().getGameResolutionWidth() ||",
                    "        posUpObjectOnScreen - padding > runtimeScene.getGame().getGameResolutionHeight() ||",
                    "        posRightObjectOnScreen + padding < 0 ||",
                    "        posDownObjectOnScreen + padding < 0",
                    "        )",
                    ") {",
                    "    eventsFunctionContext.returnValue = true;",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "IsOnScreen::InOnScreen",
                  "type": "behavior"
                },
                {
                  "description": "Padding (in pixels)",
                  "longDescription": "Number of pixels to pad the screen border. Zero by default. A negative value goes inside the screen, a positive value go outside.",
                  "name": "Padding",
                  "type": "expression"
                }
              ],
              "objectGroups": [
                {
                  "name": "Group",
                  "objects": []
                }
              ]
            }
          ],
          "propertyDescriptors": [],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "Input",
      "extensionNamespace": "",
      "fullName": "Multitouch joystick and buttons (sprite)",
      "helpPath": "/objects/multitouch-joystick",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPGNpcmNsZSBjbGFzcz0ic3QwIiBjeD0iMTYiIGN5PSIxNiIgcj0iMTMiLz4NCjxwb2x5bGluZSBjbGFzcz0ic3QwIiBwb2ludHM9IjI4LjQsMTIgMjAsMTIgMjAsMy42ICIvPg0KPHBvbHlsaW5lIGNsYXNzPSJzdDAiIHBvaW50cz0iMjAsMjguNCAyMCwyMCAyOC40LDIwICIvPg0KPHBvbHlsaW5lIGNsYXNzPSJzdDAiIHBvaW50cz0iMy42LDIwIDEyLDIwIDEyLDI4LjQgIi8+DQo8cG9seWxpbmUgY2xhc3M9InN0MCIgcG9pbnRzPSIxMiwzLjYgMTIsMTIgMy42LDEyICIvPg0KPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNiw2IDE2LjcsNyAxNS4zLDcgIi8+DQo8cG9seWdvbiBjbGFzcz0ic3QwIiBwb2ludHM9IjE2LDI2IDE1LjMsMjUgMTYuNywyNSAiLz4NCjxwb2x5Z29uIGNsYXNzPSJzdDAiIHBvaW50cz0iNiwxNiA3LDE1LjMgNywxNi43ICIvPg0KPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIyNiwxNiAyNSwxNi43IDI1LDE1LjMgIi8+DQo8L3N2Zz4NCg==",
      "name": "SpriteMultitouchJoystick",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Videogames/Videogames_controller_joystick_arrows_direction.svg",
      "shortDescription": "Joysticks or buttons for touchscreens.",
      "version": "1.2.2",
      "description": [
        "Multitouch joysticks can be used the same way as physical gamepads:",
        "- 4 or 8 directions",
        "- Analogus pads",
        "- Player selection",
        "- Controls mapping for top-down movement and platformer characters",
        "",
        "There are ready-to-use joysticks in the asset-store [multitouch joysticks pack](https://editor.gdevelop.io/?initial-dialog=asset-store&asset-pack=multitouch-joysticks-multitouch-joysticks)."
      ],
      "origin": {
        "identifier": "SpriteMultitouchJoystick",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "multitouch",
        "joystick",
        "thumbstick",
        "controller",
        "touchscreen",
        "twin stick",
        "shooter",
        "virtual",
        "platformer",
        "platform",
        "top-down"
      ],
      "authorIds": [
        "gqDaZjCfevOOxBYkK6zlhtZnXCg1",
        "1OgYzWp5UeVPbiWGJwI6vqfgZLC3",
        "v0YRpdAnIucZFgiRCCecqVnGKno2",
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Check if a button is pressed on a gamepad.",
          "fullName": "Multitouch controller button pressed",
          "functionType": "Condition",
          "name": "IsButtonPressed",
          "sentence": "Button _PARAM2_ of multitouch controller _PARAM1_ is pressed",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "VarSceneTxt"
                  },
                  "parameters": [
                    "__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Buttons[GetArgumentAsString(\"Button\")].State",
                    "=",
                    "\"Pressed\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Button name",
              "name": "Button",
              "supplementaryInformation": "[\"A\",\"CROSS\",\"B\",\"CIRCLE\",\"X\",\"SQUARE\",\"Y\",\"TRIANGLE\",\"LB\",\"L1\",\"RB\",\"R1\",\"LT\",\"L2\",\"RT\",\"R2\",\"UP\",\"DOWN\",\"LEFT\",\"RIGHT\",\"BACK\",\"SHARE\",\"START\",\"OPTIONS\",\"CLICK_STICK_LEFT\",\"CLICK_STICK_RIGHT\",\"PS_BUTTON\",\"CLICK_TOUCHPAD\"]",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if a button is released on a gamepad.",
          "fullName": "Multitouch controller button released",
          "functionType": "Condition",
          "name": "IsButtonReleased",
          "sentence": "Button _PARAM2_ of multitouch controller _PARAM1_ is released",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "VarSceneTxt"
                  },
                  "parameters": [
                    "__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Buttons[GetArgumentAsString(\"Button\")].State",
                    "=",
                    "\"Released\""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Button name",
              "name": "Button",
              "supplementaryInformation": "[\"A\",\"CROSS\",\"B\",\"CIRCLE\",\"X\",\"SQUARE\",\"Y\",\"TRIANGLE\",\"LB\",\"L1\",\"RB\",\"R1\",\"LT\",\"L2\",\"RT\",\"R2\",\"UP\",\"DOWN\",\"LEFT\",\"RIGHT\",\"BACK\",\"SHARE\",\"START\",\"OPTIONS\",\"CLICK_STICK_LEFT\",\"CLICK_STICK_RIGHT\",\"PS_BUTTON\",\"CLICK_TOUCHPAD\"]",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change a button state for a multitouch controller.",
          "fullName": "Button state",
          "functionType": "Action",
          "name": "SetButtonState",
          "private": true,
          "sentence": "Mark _PARAM2_ button as _PARAM3_ for multitouch controller _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarSceneTxt"
                  },
                  "parameters": [
                    "__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Buttons[GetArgumentAsString(\"Button\")].State",
                    "=",
                    "GetArgumentAsString(\"ButtonState\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Button name",
              "name": "Button",
              "type": "string"
            },
            {
              "description": "Button state",
              "name": "ButtonState",
              "supplementaryInformation": "[\"Idle\",\"Pressed\",\"Released\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the dead zone radius of a joystick. The deadzone is an area for which movement on sticks won't be taken into account (instead, the stick will be considered as not moved).",
          "fullName": "Dead zone radius",
          "functionType": "Action",
          "name": "SetDeadZone",
          "private": true,
          "sentence": "Change the dead zone of multitouch joystick _PARAM2_ of multitouch controller _PARAM1_ to _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Joystick[GetArgumentAsString(\"JoystickIdentifier\")].DeadZone",
                    "=",
                    "GetArgumentAsNumber(\"DeadZoneRadius\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "type": "string"
            },
            {
              "description": "Dead zone radius",
              "name": "DeadZoneRadius",
              "supplementaryInformation": "[]",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the dead zone radius of a joystick. The deadzone is an area for which movement on sticks won't be taken into account (instead, the stick will be considered as not moved).",
          "fullName": "Dead zone radius",
          "functionType": "Expression",
          "name": "DeadZone",
          "private": true,
          "sentence": "Change multitouch joystick _PARAM2_ of multitouch controller _PARAM1_ dead zone to _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Variable(__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Joystick[GetArgumentAsString(\"JoystickIdentifier\")].DeadZone)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the direction index (left = 1, bottom = 1, right = 2, top = 3) for an angle (in degrees).",
          "fullName": "Angle to 4-way index",
          "functionType": "ExpressionAndCondition",
          "name": "AngleTo4Way",
          "private": true,
          "sentence": "The angle _PARAM1_ 4-way index",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "mod(round(GetArgumentAsNumber(\"Angle\") * 4 / 360), 4)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Angle",
              "name": "Angle",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the direction index (left = 1, bottom-left = 1... top-left = 7) for an angle (in degrees).",
          "fullName": "Angle to 8-way index",
          "functionType": "ExpressionAndCondition",
          "name": "AngleTo8Way",
          "private": true,
          "sentence": "The angle _PARAM1_ 8-way index",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "mod(round(GetArgumentAsNumber(\"Angle\") * 8 / 360), 8)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Angle",
              "name": "Angle",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if angle is in a given direction.",
          "fullName": "Angle 4-way direction",
          "functionType": "Condition",
          "name": "IsAngleIn4WayDirection",
          "private": true,
          "sentence": "The angle _PARAM1_ is the 4-way direction _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Right\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo4Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "0",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Down\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo4Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "1",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Left\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo4Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "2",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Up\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo4Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "3",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Angle",
              "name": "Angle",
              "type": "expression"
            },
            {
              "description": "Direction",
              "name": "Direction",
              "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if angle is in a given direction.",
          "fullName": "Angle 8-way direction",
          "functionType": "Condition",
          "name": "IsAngleIn8WayDirection",
          "private": true,
          "sentence": "The angle _PARAM1_ is the 8-way direction _PARAM2_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Right\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "0",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"DownRight\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "1",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Down\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "2",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"DownLeft\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "3",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Left\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "4",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"UpLeft\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "5",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"Up\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "6",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::CompareStrings"
                  },
                  "parameters": [
                    "GetArgumentAsString(\"Direction\")",
                    "=",
                    "\"UpRight\""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::AngleTo8Way"
                  },
                  "parameters": [
                    "",
                    "=",
                    "7",
                    "GetArgumentAsNumber(\"Angle\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Angle",
              "name": "Angle",
              "type": "expression"
            },
            {
              "description": "Direction",
              "name": "Direction",
              "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\",\"UpLeft\",\"UpRight\",\"DownLeft\",\"DownRight\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if joystick is pushed in a given direction.",
          "fullName": "Joystick pushed in a direction (4-way)",
          "functionType": "Condition",
          "name": "IsDirectionPushed4Way",
          "sentence": "Joystick _PARAM2_ of multitouch controller _PARAM1_ is pushed in direction _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Make sure the joystick has moved from center"
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::JoystickForce"
                  },
                  "parameters": [
                    "",
                    ">",
                    "SpriteMultitouchJoystick::DeadZone(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))",
                    "GetArgumentAsNumber(\"ControllerIdentifier\")",
                    "GetArgumentAsString(\"JoystickIdentifier\")",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::IsAngleIn4WayDirection"
                  },
                  "parameters": [
                    "",
                    "SpriteMultitouchJoystick::JoystickAngle(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))",
                    "GetArgumentAsString(\"Direction\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            },
            {
              "description": "Direction",
              "name": "Direction",
              "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if joystick is pushed in a given direction.",
          "fullName": "Joystick pushed in a direction (8-way)",
          "functionType": "Condition",
          "name": "IsDirectionPushed8Way",
          "sentence": "Joystick _PARAM2_ of multitouch controller _PARAM1_ is pushed in direction _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Make sure the joystick has moved from center"
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::JoystickForce"
                  },
                  "parameters": [
                    "",
                    ">",
                    "SpriteMultitouchJoystick::DeadZone(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))",
                    "GetArgumentAsNumber(\"ControllerIdentifier\")",
                    "GetArgumentAsString(\"JoystickIdentifier\")",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "SpriteMultitouchJoystick::IsAngleIn8WayDirection"
                  },
                  "parameters": [
                    "",
                    "SpriteMultitouchJoystick::JoystickAngle(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))",
                    "GetArgumentAsString(\"Direction\")",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            },
            {
              "description": "Direction",
              "name": "Direction",
              "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\",\"UpLeft\",\"UpRight\",\"DownLeft\",\"DownRight\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the percentage the thumb has been pulled away from the joystick center (Range: 0 to 1).",
          "fullName": "Joystick force (deprecated)",
          "functionType": "ExpressionAndCondition",
          "name": "JoystickForce",
          "private": true,
          "sentence": "Joystick _PARAM2_ of multitouch controller _PARAM1_ force",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "SpriteMultitouchJoystick::StickForce(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "the force of multitouch contoller stick (from 0 to 1).",
          "fullName": "Stick force",
          "functionType": "ExpressionAndCondition",
          "name": "StickForce",
          "sentence": "multitouch controller _PARAM1_ _PARAM2_ stick force",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Variable(__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Joystick[GetArgumentAsString(\"JoystickIdentifier\")].Force)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Stick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the percentage the thumb has been pulled away from the joystick center (Range: 0 to 1).",
          "fullName": "Joystick force",
          "functionType": "Action",
          "name": "SetJoystickForce",
          "private": true,
          "sentence": "Change the force of the joystick _PARAM2_ of multitouch controller _PARAM1_ to _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Joystick[GetArgumentAsString(\"JoystickIdentifier\")].Force",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "type": "string"
            },
            {
              "description": "Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the angle the joystick is pointing towards (Range: -180 to 180).",
          "fullName": "Joystick angle (deprecated)",
          "functionType": "Expression",
          "name": "JoystickAngle",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "SpriteMultitouchJoystick::StickAngle(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the angle the multitouch controller stick is pointing towards (Range: -180 to 180).",
          "fullName": "Stick angle",
          "functionType": "Expression",
          "name": "StickAngle",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Variable(__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Joystick[GetArgumentAsString(\"JoystickIdentifier\")].Angle)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the angle the joystick is pointing towards (Range: -180 to 180).",
          "fullName": "Joystick angle",
          "functionType": "Action",
          "name": "SetJoystickAngle",
          "private": true,
          "sentence": "Change the angle of the joystick _PARAM2_ of multitouch controller _PARAM1_ to _PARAM3_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "__MultitouchJoystick.Controllers[GetArgumentAsNumber(\"ControllerIdentifier\")].Joystick[GetArgumentAsString(\"JoystickIdentifier\")].Angle",
                    "=",
                    "GetArgumentAsNumber(\"Value\")"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "type": "string"
            },
            {
              "description": "Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the multitouch contoller stick force on X axis (from -1 at the left to 1 at the right).",
          "fullName": "Stick X force",
          "functionType": "Expression",
          "name": "StickForceX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "SpriteMultitouchJoystick::JoystickForce(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\")) * cos(ToRad(SpriteMultitouchJoystick::JoystickAngle(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Return the multitouch contoller stick force on Y axis (from -1 at the top to 1 at the bottom).",
          "fullName": "Stick Y force",
          "functionType": "Expression",
          "name": "StickForceY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "SpriteMultitouchJoystick::JoystickForce(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\")) * sin(ToRad(SpriteMultitouchJoystick::JoystickAngle(GetArgumentAsNumber(\"ControllerIdentifier\"), GetArgumentAsString(\"JoystickIdentifier\"))))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Multitouch controller identifier (1, 2, 3, 4...)",
              "name": "ControllerIdentifier",
              "type": "expression"
            },
            {
              "description": "Joystick name",
              "name": "JoystickIdentifier",
              "supplementaryInformation": "[\"Primary\",\"Secondary\"]",
              "type": "stringWithSelector"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "Joystick that can be controlled by interacting with a touchscreen.",
          "fullName": "Multitouch Joystick",
          "name": "MultitouchJoystick",
          "objectType": "",
          "private": true,
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::SetDeadZone"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJoystickIdentifier()",
                        "Object.Behavior::PropertyDeadZoneRadius()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::Reset"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onDeActivate",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::Reset"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "HasGameJustResumed"
                      },
                      "parameters": [
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::Reset"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Manage touches",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "HasAnyTouchOrMouseStarted"
                          },
                          "parameters": [
                            ""
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyTouchIndex"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "0"
                          ]
                        }
                      ],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Repeat",
                          "repeatExpression": "StartedTouchOrMouseCount()",
                          "conditions": [],
                          "actions": [],
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "value": "SpriteMultitouchJoystick::MultitouchJoystick::PropertyTouchId"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "0"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "CollisionPoint"
                                  },
                                  "parameters": [
                                    "Object",
                                    "TouchX(StartedTouchOrMouseId(Object.Behavior::PropertyTouchIndex()), Object.Layer(), 0)",
                                    "TouchY(StartedTouchOrMouseId(Object.Behavior::PropertyTouchIndex()), Object.Layer(), 0)"
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyTouchId"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "StartedTouchOrMouseId(Object.Behavior::PropertyTouchIndex())"
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyTouchIndex"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "+",
                                    "1"
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "Move thumb back to center when not being pressed (acts like a spring on a real controller)"
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "HasTouchEnded"
                          },
                          "parameters": [
                            "",
                            "Object.Behavior::PropertyTouchId()"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::MultitouchJoystick::Reset"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Update joystick position",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::MultitouchJoystick::PropertyTouchId"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "!=",
                            "0"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetJoystickAngle"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "AngleBetweenPositions(Object.CenterX(), Object.CenterY(), TouchX(Object.Behavior::PropertyTouchId(), Object.Layer(), 0), TouchY(Object.Behavior::PropertyTouchId(), Object.Layer(), 0))",
                            "AngleBetweenPositions(Object.CenterX(), Object.CenterY(), TouchX(Object.Behavior::PropertyTouchId(), Object.Layer(), 0), TouchY(Object.Behavior::PropertyTouchId(), Object.Layer(), 0))"
                          ]
                        },
                        {
                          "type": {
                            "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetJoystickForce"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "clamp(2 * DistanceBetweenPositions(Object.CenterX(), Object.CenterY(), TouchX(Object.Behavior::PropertyTouchId(), Object.Layer(), 0), TouchY(Object.Behavior::PropertyTouchId(), Object.Layer(), 0)) / Object.Width(), 0, 1)",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the joystick force (from 0 to 1).",
              "fullName": "Joystick force",
              "functionType": "ExpressionAndCondition",
              "name": "JoystickForce",
              "sentence": "the joystick force",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyJoystickForce()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "JoystickForce",
              "name": "SetJoystickForce",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyJoystickForce"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::SetJoystickForce"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJoystickIdentifier()",
                        "Object.Behavior::PropertyJoystickForce()",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the angle the joystick is pointing towards (Range: -180 to 180).",
              "fullName": "Joystick angle",
              "functionType": "Expression",
              "name": "JoystickAngle",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyJoystickAngle()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the angle the joystick is pointing towards (Range: -180 to 180).",
              "fullName": "Joystick angle",
              "functionType": "Action",
              "name": "SetJoystickAngle",
              "private": true,
              "sentence": "Change the joystick angle of _PARAM0_ to _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyJoystickAngle"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::SetJoystickAngle"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJoystickIdentifier()",
                        "Object.Behavior::PropertyJoystickAngle()",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                },
                {
                  "description": "Angle",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the stick force on X axis (from -1 at the left to 1 at the right).",
              "fullName": "Stick X force",
              "functionType": "Expression",
              "name": "StickForceX",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::JoystickForce() * cos(ToRad(Object.Behavior::JoystickAngle()))"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the stick force on Y axis (from -1 at the top to 1 at the bottom).",
              "fullName": "Stick Y force",
              "functionType": "Expression",
              "name": "StickForceY",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::JoystickForce() * sin(ToRad(Object.Behavior::JoystickAngle()))"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if joystick is pushed in a given direction.",
              "fullName": "Joystick pushed in a direction (4-way movement)",
              "functionType": "Condition",
              "name": "IsDirectionPushed4Way",
              "sentence": "_PARAM0_ is pushed in direction _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::PropertyJoystickForce"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ">",
                        "Object.Behavior::PropertyDeadZoneRadius()"
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::IsAngleIn4WayDirection"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::JoystickAngle()",
                        "GetArgumentAsString(\"Direction\")",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                },
                {
                  "description": "Direction",
                  "name": "Direction",
                  "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if joystick is pushed in a given direction.",
              "fullName": "Joystick pushed in a direction (8-way movement)",
              "functionType": "Condition",
              "name": "IsDirectionPushed8Way",
              "sentence": "_PARAM0_ is pushed in direction _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::PropertyJoystickForce"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ">",
                        "Object.Behavior::PropertyDeadZoneRadius()"
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::IsAngleIn8WayDirection"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::JoystickAngle()",
                        "GetArgumentAsString(\"Direction\")",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                },
                {
                  "description": "Direction",
                  "name": "Direction",
                  "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\",\"UpLeft\",\"UpRight\",\"DownLeft\",\"DownRight\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if a joystick is pressed.",
              "fullName": "Joystick pressed",
              "functionType": "Condition",
              "name": "IsPressed",
              "sentence": "Joystick _PARAM0_ is pressed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::PropertyTouchId"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "!=",
                        "0"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Reset the joystick values (except for angle, which stays the same)",
              "fullName": "Reset",
              "functionType": "Action",
              "name": "Reset",
              "private": true,
              "sentence": "Reset the joystick of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetJoystickForce"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyTouchId"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the multitouch controller identifier.",
              "fullName": "Multitouch controller identifier",
              "functionType": "ExpressionAndCondition",
              "group": "Multitouch Joystick configuration",
              "name": "ControllerIdentifier",
              "sentence": "the multitouch controller identifier",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyControllerIdentifier()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ControllerIdentifier",
              "name": "SetControllerIdentifier",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyControllerIdentifier"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the joystick name.",
              "fullName": "Joystick name",
              "functionType": "ExpressionAndCondition",
              "group": "Multitouch Joystick configuration",
              "name": "JoystickIdentifier",
              "sentence": "the joystick name",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyJoystickIdentifier()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "JoystickIdentifier",
              "name": "SetJoystickIdentifier",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyJoystickIdentifier"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsString(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the dead zone radius (range: 0 to 1) of the joystick. The deadzone is an area for which movement on sticks won't be taken into account (instead, the stick will be considered as not moved).",
              "fullName": "Dead zone radius",
              "functionType": "ExpressionAndCondition",
              "group": "Multitouch Joystick configuration",
              "name": "DeadZoneRadius",
              "sentence": "the dead zone radius",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyDeadZoneRadius()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "DeadZoneRadius",
              "name": "SetDeadZoneRadius",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetPropertyDeadZoneRadius"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Value\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "1",
              "type": "Number",
              "label": "Multitouch controller identifier (1, 2, 3, 4...)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "ControllerIdentifier"
            },
            {
              "value": "Primary",
              "type": "String",
              "label": "Joystick name",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "JoystickIdentifier"
            },
            {
              "value": "0.4",
              "type": "Number",
              "label": "Dead zone radius (range: 0 to 1)",
              "description": "The deadzone is an area for which movement on sticks won't be taken into account (instead, the stick will be considered as not moved)",
              "group": "",
              "extraInformation": [],
              "name": "DeadZoneRadius"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Joystick angle (range: -180 to 180)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "JoystickAngle"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Joystick force (range: 0 to 1)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "JoystickForce"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TouchId"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TouchIndex"
            }
          ],
          "sharedPropertyDescriptors": []
        },
        {
          "description": "Detect button presses made on a touchscreen.",
          "fullName": "Multitouch button",
          "name": "MultitouchButton",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::IsReleased"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::SetPropertyIsReleased"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "no"
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::SetButtonState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "\"Idle\"",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "SpriteMultitouchJoystick::MultitouchButton::IsPressed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "HasAnyTouchOrMouseStarted"
                      },
                      "parameters": [
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::SetPropertyTouchIndex"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Repeat",
                      "repeatExpression": "StartedTouchOrMouseCount()",
                      "conditions": [],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "CollisionPoint"
                              },
                              "parameters": [
                                "Object",
                                "TouchX(StartedTouchOrMouseId(Object.Behavior::PropertyTouchIndex()), Object.Layer(), 0)",
                                "TouchY(StartedTouchOrMouseId(Object.Behavior::PropertyTouchIndex()), Object.Layer(), 0)"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::MultitouchButton::SetPropertyTouchId"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "StartedTouchOrMouseId(Object.Behavior::PropertyTouchIndex())"
                              ]
                            },
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::MultitouchButton::SetButtonState"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "\"Pressed\"",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::MultitouchButton::SetPropertyTouchIndex"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "+",
                                "1"
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::IsPressed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "HasTouchEnded"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyTouchId()"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::SetButtonState"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "\"Released\"",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::SetPropertyIsReleased"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::SetPropertyTouchId"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchButton",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if button is released.",
              "fullName": "Button released",
              "functionType": "Condition",
              "name": "IsReleased",
              "sentence": "Button _PARAM0_ is released",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::PropertyIsReleased"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchButton",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if button is pressed.",
              "fullName": "Button pressed",
              "functionType": "Condition",
              "name": "IsPressed",
              "sentence": "Button _PARAM0_ is pressed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchButton::PropertyTouchId"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "!=",
                        "0"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchButton",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Button state",
              "functionType": "Action",
              "name": "SetButtonState",
              "private": true,
              "sentence": "Mark the button _PARAM0_ as _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::SetButtonState"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyButtonIdentifier()",
                        "GetArgumentAsString(\"ButtonState\")",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::MultitouchButton",
                  "type": "behavior"
                },
                {
                  "description": "Button state",
                  "name": "ButtonState",
                  "supplementaryInformation": "[\"Idle\",\"Pressed\",\"Released\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "1",
              "type": "Number",
              "label": "Multitouch controller identifier (1, 2, 3, 4...)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "ControllerIdentifier"
            },
            {
              "value": "A",
              "type": "String",
              "label": "Button identifier",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "ButtonIdentifier"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "TouchID",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TouchId"
            },
            {
              "value": "",
              "type": "Number",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "TouchIndex"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Button released",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "IsReleased"
            }
          ],
          "sharedPropertyDescriptors": []
        },
        {
          "description": "Control a platformer character with a multitouch controller.",
          "fullName": "Platformer multitouch controller mapper",
          "name": "PlatformerMultitouchMapper",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJoystickIdentifier()",
                        "\"Left\"",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "PlatformBehavior::SimulateLeftKey"
                      },
                      "parameters": [
                        "Object",
                        "Property"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJoystickIdentifier()",
                        "\"Right\"",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "PlatformBehavior::SimulateRightKey"
                      },
                      "parameters": [
                        "Object",
                        "Property"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJoystickIdentifier()",
                        "\"Up\"",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "PlatformBehavior::SimulateUpKey"
                      },
                      "parameters": [
                        "Object",
                        "Property"
                      ]
                    },
                    {
                      "type": {
                        "value": "PlatformBehavior::SimulateLadderKey"
                      },
                      "parameters": [
                        "Object",
                        "Property"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJoystickIdentifier()",
                        "\"Down\"",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "PlatformBehavior::SimulateDownKey"
                      },
                      "parameters": [
                        "Object",
                        "Property"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::IsButtonPressed"
                      },
                      "parameters": [
                        "",
                        "Object.Behavior::PropertyControllerIdentifier()",
                        "Object.Behavior::PropertyJumpButton()",
                        "\"Down\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "PlatformBehavior::SimulateJumpKey"
                      },
                      "parameters": [
                        "Object",
                        "Property"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::PlatformerMultitouchMapper",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "",
              "type": "Behavior",
              "label": "Platform character behavior",
              "description": "",
              "group": "",
              "extraInformation": [
                "PlatformBehavior::PlatformerObjectBehavior"
              ],
              "name": "Property"
            },
            {
              "value": "1",
              "type": "Number",
              "label": "Controller identifier (1, 2, 3, 4...)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "ControllerIdentifier"
            },
            {
              "value": "Primary",
              "type": "Choice",
              "label": "Joystick name",
              "description": "",
              "group": "Controls",
              "extraInformation": [
                "Primary",
                "Secondary"
              ],
              "name": "JoystickIdentifier"
            },
            {
              "value": "A",
              "type": "String",
              "label": "Jump button name",
              "description": "",
              "group": "Controls",
              "extraInformation": [],
              "name": "JumpButton"
            }
          ],
          "sharedPropertyDescriptors": []
        },
        {
          "description": "Control a top-down character with a multitouch controller.",
          "fullName": "Top-down multitouch controller mapper",
          "name": "TopDownMultitouchMapper",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::TopDownMultitouchMapper::PropertyStickMode"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Analog\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TopDownMovementBehavior::SimulateStick"
                      },
                      "parameters": [
                        "Object",
                        "TopDownMovement",
                        "SpriteMultitouchJoystick::StickAngle(Object.Behavior::PropertyControllerIdentifier(), Object.Behavior::PropertyJoystickIdentifier())",
                        "SpriteMultitouchJoystick::StickForce(Object.Behavior::PropertyControllerIdentifier(), Object.Behavior::PropertyJoystickIdentifier())"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::TopDownMultitouchMapper::PropertyStickMode"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"360Â°\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TopDownMovementBehavior::SimulateStick"
                      },
                      "parameters": [
                        "Object",
                        "TopDownMovement",
                        "SpriteMultitouchJoystick::StickAngle(Object.Behavior::PropertyControllerIdentifier(), Object.Behavior::PropertyJoystickIdentifier())",
                        "sign(SpriteMultitouchJoystick::StickForce(Object.Behavior::PropertyControllerIdentifier(), Object.Behavior::PropertyJoystickIdentifier()))"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::TopDownMultitouchMapper::PropertyStickMode"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"8 Directions\""
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "inverted": true,
                            "value": "TopDownMovementBehavior::DiagonalsAllowed"
                          },
                          "parameters": [
                            "Object",
                            "TopDownMovement"
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Left\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateLeftKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Right\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateRightKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Up\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateUpKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed4Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Down\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateDownKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "TopDownMovementBehavior::DiagonalsAllowed"
                          },
                          "parameters": [
                            "Object",
                            "TopDownMovement"
                          ]
                        }
                      ],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Left\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateLeftKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Right\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateRightKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Up\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateUpKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"Down\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateDownKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"UpLeft\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateUpKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            },
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateLeftKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"UpRight\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateUpKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            },
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateRightKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"DownLeft\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateDownKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            },
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateLeftKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "SpriteMultitouchJoystick::IsDirectionPushed8Way"
                              },
                              "parameters": [
                                "",
                                "Object.Behavior::PropertyControllerIdentifier()",
                                "Object.Behavior::PropertyJoystickIdentifier()",
                                "\"DownRight\"",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateDownKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            },
                            {
                              "type": {
                                "value": "TopDownMovementBehavior::SimulateRightKey"
                              },
                              "parameters": [
                                "Object",
                                "TopDownMovement"
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "SpriteMultitouchJoystick::TopDownMultitouchMapper",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "",
              "type": "Behavior",
              "label": "Top-down movement behavior",
              "description": "",
              "group": "",
              "extraInformation": [
                "TopDownMovementBehavior::TopDownMovementBehavior"
              ],
              "name": "TopDownMovement"
            },
            {
              "value": "1",
              "type": "Number",
              "label": "Controller identifier (1, 2, 3, 4...)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "ControllerIdentifier"
            },
            {
              "value": "Primary",
              "type": "Choice",
              "label": "Joystick name",
              "description": "",
              "group": "",
              "extraInformation": [
                "Primary",
                "Secondary"
              ],
              "name": "JoystickIdentifier"
            },
            {
              "value": "Analog",
              "type": "Choice",
              "label": "Stick mode",
              "description": "",
              "group": "Controls",
              "extraInformation": [
                "Analog",
                "360Â°",
                "8 Directions"
              ],
              "name": "StickMode"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": [
        {
          "defaultName": "Joystick",
          "description": "Joystick for touchscreens.",
          "fullName": "Multitouch Joystick",
          "name": "SpriteMultitouchJoystick",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Border",
                        "0",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "Thumb",
                        "0",
                        "0",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "ChangePlan"
                      },
                      "parameters": [
                        "Border",
                        "=",
                        "1"
                      ]
                    },
                    {
                      "type": {
                        "value": "ChangePlan"
                      },
                      "parameters": [
                        "Thumb",
                        "=",
                        "2"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetCenter"
                      },
                      "parameters": [
                        "Border",
                        "=",
                        "0",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetCenter"
                      },
                      "parameters": [
                        "Thumb",
                        "=",
                        "0",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::SpriteMultitouchJoystick::UpdateConfiguration"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "SetIncludedInParentCollisionMask"
                      },
                      "parameters": [
                        "Thumb",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MettreAutour"
                      },
                      "parameters": [
                        "Thumb",
                        "Border",
                        "Border.MultitouchJoystick::JoystickForce() * Border.Width() / 2",
                        "Border.MultitouchJoystick::JoystickAngle()"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onHotReloading",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::SpriteMultitouchJoystick::UpdateConfiguration"
                      },
                      "parameters": [
                        "Object",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Pass the object property values to the behavior.",
              "fullName": "Update configuration",
              "functionType": "Action",
              "name": "UpdateConfiguration",
              "private": true,
              "sentence": "Update the configuration of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetControllerIdentifier"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "=",
                        "Object.PropertyControllerIdentifier()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetJoystickIdentifier"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "=",
                        "Object.PropertyJoystickIdentifier()",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetDeadZoneRadius"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "=",
                        "Object.PropertyDeadZoneRadius()",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "De/activate control of the joystick.",
              "fullName": "De/activate control",
              "functionType": "Action",
              "name": "ActivateControl",
              "sentence": "Activate control of _PARAM0_: _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldActivate\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ActivateBehavior"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "no"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"ShouldActivate\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "ActivateBehavior"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                },
                {
                  "description": "Activate",
                  "name": "ShouldActivate",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if a stick is pressed.",
              "fullName": "Stick pressed",
              "functionType": "Condition",
              "name": "IsPressed",
              "sentence": "Stick _PARAM0_ is pressed",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::IsPressed"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "!="
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the joystick force (from 0 to 1).",
              "fullName": "Joystick force (deprecated)",
              "functionType": "ExpressionAndCondition",
              "name": "JoystickForce",
              "private": true,
              "sentence": "the joystick force",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::JoystickForce()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the strick force (from 0 to 1).",
              "fullName": "Stick force",
              "functionType": "ExpressionAndCondition",
              "name": "StickForce",
              "sentence": "the stick force",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::JoystickForce()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the stick force on X axis (from -1 at the left to 1 at the right).",
              "fullName": "Stick X force",
              "functionType": "ExpressionAndCondition",
              "name": "StickForceX",
              "sentence": "the stick X force",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::StickForceX()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the stick force on Y axis (from -1 at the top to 1 at the bottom).",
              "fullName": "Stick Y force",
              "functionType": "ExpressionAndCondition",
              "name": "StickForceY",
              "sentence": "the stick Y force",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::StickForceY()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the angle the joystick is pointing towards (from -180 to 180).",
              "fullName": "Joystick angle (deprecated)",
              "functionType": "Expression",
              "name": "JoystickAngle",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::JoystickAngle()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Return the angle the stick is pointing towards (from -180 to 180).",
              "fullName": "Stick angle",
              "functionType": "Expression",
              "name": "StickAngle",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::JoystickAngle()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if joystick is pushed in a given direction.",
              "fullName": "Joystick pushed in a direction (4-way movement)",
              "functionType": "Condition",
              "name": "IsDirectionPushed4Way",
              "sentence": "_PARAM0_ is pushed in direction _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::IsDirectionPushed4Way"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "GetArgumentAsString(\"Direction\")",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                },
                {
                  "description": "Direction",
                  "name": "Direction",
                  "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if joystick is pushed in a given direction.",
              "fullName": "Joystick pushed in a direction (8-way movement)",
              "functionType": "Condition",
              "name": "IsDirectionPushed8Way",
              "sentence": "_PARAM0_ is pushed in direction _PARAM1_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::IsDirectionPushed8Way"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "GetArgumentAsString(\"Direction\")",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                },
                {
                  "description": "Direction",
                  "name": "Direction",
                  "supplementaryInformation": "[\"Up\",\"Down\",\"Left\",\"Right\",\"UpLeft\",\"UpRight\",\"DownLeft\",\"DownRight\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the multitouch controller identifier (1, 2, 3, 4...).",
              "fullName": "Multitouch controller identifier",
              "functionType": "ExpressionAndCondition",
              "group": "Multitouch Joystick configuration",
              "name": "ControllerIdentifier",
              "sentence": "the multitouch controller identifier",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::PropertyControllerIdentifier()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "ControllerIdentifier",
              "name": "SetControllerIdentifier",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetControllerIdentifier"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "=",
                        "GetArgumentAsNumber(\"Value\")",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the joystick name of the object.",
              "fullName": "Joystick name",
              "functionType": "ExpressionAndCondition",
              "group": "Multitouch Joystick configuration",
              "name": "JoystickIdentifier",
              "sentence": "the joystick name",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::PropertyJoystickIdentifier()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "JoystickIdentifier",
              "name": "SetJoystickIdentifier",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetJoystickIdentifier"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "=",
                        "GetArgumentAsString(\"Value\")",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "the dead zone radius of the joystick (range: 0 to 1). The deadzone is an area for which movement on sticks won't be taken into account (instead, the stick will be considered as not moved).",
              "fullName": "Dead zone radius",
              "functionType": "ExpressionAndCondition",
              "group": "Multitouch Joystick configuration",
              "name": "DeadZoneRadius",
              "sentence": "the dead zone radius",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Border.MultitouchJoystick::PropertyDeadZoneRadius()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "DeadZoneRadius",
              "name": "SetDeadZoneRadius",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SpriteMultitouchJoystick::MultitouchJoystick::SetDeadZoneRadius"
                      },
                      "parameters": [
                        "Border",
                        "MultitouchJoystick",
                        "=",
                        "GetArgumentAsNumber(\"Value\")",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "SpriteMultitouchJoystick::SpriteMultitouchJoystick",
                  "type": "object"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "1",
              "type": "Number",
              "label": "Multitouch controller identifier (1, 2, 3, 4...)",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "ControllerIdentifier"
            },
            {
              "value": "Primary",
              "type": "Choice",
              "label": "Joystick name",
              "description": "",
              "group": "",
              "extraInformation": [
                "Primary",
                "Secondary"
              ],
              "name": "JoystickIdentifier"
            },
            {
              "value": "0.4",
              "type": "Number",
              "label": "Dead zone radius (range: 0 to 1)",
              "description": "The deadzone is an area for which movement on sticks won't be taken into account (instead, the stick will be considered as not moved)",
              "group": "",
              "extraInformation": [],
              "name": "DeadZoneRadius"
            },
            {
              "value": "Center-center",
              "type": "String",
              "label": "",
              "description": "Only used by the scene editor.",
              "group": "",
              "extraInformation": [
                "Thumb"
              ],
              "hidden": true,
              "name": "ThumbAnchorOrigin"
            },
            {
              "value": "Center-center",
              "type": "Number",
              "label": "",
              "description": "Only used by the scene editor.",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "ThumbAnchorTarget"
            },
            {
              "value": "true",
              "type": "Boolean",
              "label": "",
              "description": "Only used by the scene editor.",
              "group": "",
              "extraInformation": [
                "Thumb"
              ],
              "hidden": true,
              "name": "ThumbIsScaledProportionally"
            },
            {
              "value": "Center-center",
              "type": "String",
              "label": "",
              "description": "Only used by the scene editor.",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "ParentOrigin"
            }
          ],
          "objects": [
            {
              "adaptCollisionMaskAutomatically": false,
              "assetStoreId": "",
              "name": "Thumb",
              "type": "Sprite",
              "updateIfNotVisible": false,
              "variables": [],
              "effects": [],
              "behaviors": [],
              "animations": [
                {
                  "name": "Idle",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": []
                    }
                  ]
                }
              ]
            },
            {
              "adaptCollisionMaskAutomatically": false,
              "assetStoreId": "",
              "name": "Border",
              "type": "Sprite",
              "updateIfNotVisible": false,
              "variables": [],
              "effects": [],
              "behaviors": [
                {
                  "name": "MultitouchJoystick",
                  "type": "SpriteMultitouchJoystick::MultitouchJoystick",
                  "ControllerIdentifier": 1,
                  "JoystickIdentifier": "Primary",
                  "FloatingEnabled": false,
                  "DeadZoneRadius": 0.4,
                  "JoystickAngle": 0,
                  "JoystickForce": 0,
                  "TouchId": 0,
                  "TouchIndex": 0
                }
              ],
              "animations": [
                {
                  "name": "Idle",
                  "useMultipleDirections": false,
                  "directions": [
                    {
                      "looping": false,
                      "timeBetweenFrames": 0.08,
                      "sprites": []
                    }
                  ]
                }
              ]
            }
          ],
          "objectsFolderStructure": {
            "folderName": "__ROOT",
            "children": [
              {
                "objectName": "Thumb"
              },
              {
                "objectName": "Border"
              }
            ]
          }
        }
      ]
    },
    {
      "author": "",
      "category": "",
      "extensionNamespace": "",
      "fullName": "",
      "helpPath": "",
      "iconUrl": "",
      "name": "TiledRoad",
      "previewIconUrl": "",
      "shortDescription": "",
      "version": "",
      "description": "",
      "tags": [],
      "authorIds": [],
      "dependencies": [],
      "globalVariables": [
        {
          "name": "Roads",
          "type": "array",
          "children": [
            {
              "type": "array",
              "children": [
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 2
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 6
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        }
                      ]
                    }
                  ]
                },
                {
                  "folded": true,
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": []
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": []
                    }
                  ]
                },
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 0
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        }
                      ]
                    }
                  ]
                },
                {
                  "folded": true,
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": []
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": []
                    }
                  ]
                }
              ]
            },
            {
              "type": "array",
              "children": [
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 3
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 11
                        }
                      ]
                    }
                  ]
                },
                {
                  "folded": true,
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": []
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": []
                    }
                  ]
                },
                {
                  "folded": true,
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": []
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": []
                    }
                  ]
                },
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 0
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": 1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "array",
              "children": [
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 2
                        },
                        {
                          "type": "number",
                          "value": 1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 3
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 4
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 6
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 11
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 3
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 0
                        },
                        {
                          "type": "number",
                          "value": 2
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": 2
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 7
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 9
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 0
                        },
                        {
                          "type": "number",
                          "value": 1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 3
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 5
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 10
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 2
                        },
                        {
                          "type": "number",
                          "value": 0
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": 1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 3
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 8
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "array",
              "children": [
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 2
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 1
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 4
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 6
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 0
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 2
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": 2
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 7
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": [
                        {
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 1
                        }
                      ]
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": [
                        {
                          "folded": true,
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": 5
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        },
                        {
                          "folded": true,
                          "type": "number",
                          "value": -1
                        }
                      ]
                    }
                  ]
                },
                {
                  "folded": true,
                  "type": "structure",
                  "children": [
                    {
                      "name": "PathTargets",
                      "type": "array",
                      "children": []
                    },
                    {
                      "name": "PathsByEdge",
                      "type": "array",
                      "children": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "Paths",
          "type": "structure",
          "children": [
            {
              "name": "0",
              "type": "structure",
              "children": [
                {
                  "folded": true,
                  "name": "OriginX",
                  "type": "number",
                  "value": 0
                },
                {
                  "folded": true,
                  "name": "OriginY",
                  "type": "number",
                  "value": 0.75
                },
                {
                  "name": "PathName",
                  "type": "string",
                  "value": "RoadStraight"
                }
              ]
            },
            {
              "name": "1",
              "type": "structure",
              "children": [
                {
                  "folded": true,
                  "name": "OriginX",
                  "type": "number",
                  "value": 0.25
                },
                {
                  "folded": true,
                  "name": "OriginY",
                  "type": "number",
                  "value": 0
                },
                {
                  "name": "PathName",
                  "type": "string",
                  "value": "RoadBigBend"
                }
              ]
            },
            {
              "name": "2",
              "type": "structure",
              "children": [
                {
                  "folded": true,
                  "name": "OriginX",
                  "type": "number",
                  "value": 0.75
                },
                {
                  "folded": true,
                  "name": "OriginY",
                  "type": "number",
                  "value": 1
                },
                {
                  "name": "PathName",
                  "type": "string",
                  "value": "RoadSmallBend"
                }
              ]
            }
          ]
        },
        {
          "name": "RoadOrigins",
          "type": "array",
          "children": [
            {
              "type": "array",
              "children": [
                {
                  "type": "number",
                  "value": 0
                },
                {
                  "type": "number",
                  "value": 2
                }
              ]
            },
            {
              "type": "array",
              "children": [
                {
                  "type": "number",
                  "value": 0
                },
                {
                  "type": "number",
                  "value": 3
                }
              ]
            },
            {
              "type": "array",
              "children": [
                {
                  "type": "number",
                  "value": 0
                },
                {
                  "type": "number",
                  "value": 1
                },
                {
                  "type": "number",
                  "value": 2
                },
                {
                  "type": "number",
                  "value": 3
                }
              ]
            },
            {
              "type": "array",
              "children": [
                {
                  "type": "number",
                  "value": 0
                },
                {
                  "folded": true,
                  "type": "number",
                  "value": 1
                },
                {
                  "type": "number",
                  "value": 2
                }
              ]
            }
          ]
        }
      ],
      "sceneVariables": [
        {
          "name": "IsPathesBuilt",
          "type": "boolean",
          "value": false
        }
      ],
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onFirstSceneLoaded",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Rotate pathes for every tile direction."
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Repeat",
                  "repeatExpression": "3",
                  "conditions": [],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Repeat",
                          "repeatExpression": "3",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "Paths[3 * DirectionDelta + Index].OriginX",
                                "=",
                                "TiledRoad::RotatedX(Paths[Index].OriginX, Paths[Index].OriginY, DirectionDelta)"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "Paths[3 * DirectionDelta + Index].OriginY",
                                "=",
                                "TiledRoad::RotatedY(Paths[Index].OriginX, Paths[Index].OriginY, DirectionDelta)"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetStringVariable"
                              },
                              "parameters": [
                                "Paths[3 * DirectionDelta + Index].PathName",
                                "=",
                                "Paths[Index].PathName + DirectionDelta"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "Index",
                                "+",
                                "1"
                              ]
                            }
                          ]
                        }
                      ],
                      "variables": [
                        {
                          "folded": true,
                          "name": "Index",
                          "type": "number",
                          "value": 0
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "DirectionDelta",
                            "+",
                            "1"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ],
              "variables": [
                {
                  "folded": true,
                  "name": "DirectionDelta",
                  "type": "number",
                  "value": 1
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Suffix pathes names for direction 0.\n"
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Repeat",
                  "repeatExpression": "3",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetStringVariable"
                      },
                      "parameters": [
                        "Paths[Index].PathName",
                        "+",
                        "\"0\""
                      ]
                    },
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "Index",
                        "+",
                        "1"
                      ]
                    }
                  ]
                }
              ],
              "variables": [
                {
                  "folded": true,
                  "name": "Index",
                  "type": "number",
                  "value": 0
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "DebuggerTools::ConsoleLog"
                  },
                  "parameters": [
                    "ToJSON(Roads)",
                    "\"info\"",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "DebuggerTools::ConsoleLog"
                  },
                  "parameters": [
                    "ToJSON(Paths)",
                    "\"info\"",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "fullName": "Rotated X",
          "functionType": "Expression",
          "name": "RotatedX",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "0"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "PositionX"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "1"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "1 - PositionY"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "2"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "1 - PositionX"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "3"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "PositionY"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Position X",
              "name": "PositionX",
              "type": "expression"
            },
            {
              "description": "Position Y",
              "name": "PositionY",
              "type": "expression"
            },
            {
              "description": "Direction delta",
              "name": "DirectionDelta",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Rotated Y",
          "functionType": "Expression",
          "name": "RotatedY",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "0"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "PositionY"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "1"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "PositionX"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "2"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "1 - PositionY"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"DirectionDelta\"",
                    "=",
                    "3"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "1 - PositionX"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Position X",
              "name": "PositionX",
              "type": "expression"
            },
            {
              "description": "Position Y",
              "name": "PositionY",
              "type": "expression"
            },
            {
              "description": "Direction delta",
              "name": "DirectionDelta",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Opposite edge",
          "functionType": "Expression",
          "name": "OppositeEdge",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "mod(Value + 2, 4)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Edge",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Edge delta X",
          "functionType": "Expression",
          "name": "EdgeDeltaX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"Edge\"",
                    "=",
                    "0"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "1"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"Edge\"",
                    "=",
                    "2"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "-1"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Edge",
              "name": "Edge",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "fullName": "Edge delta X",
          "functionType": "Expression",
          "name": "EdgeDeltaY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"Edge\"",
                    "=",
                    "1"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "1"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "CompareArgumentAsNumber"
                  },
                  "parameters": [
                    "\"Edge\"",
                    "=",
                    "3"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "-1"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Edge",
              "name": "Edge",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "",
          "fullName": "Road tile",
          "name": "RoadTile",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TiledRoad::RoadTile::SetPropertyShape"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Behavior::ShapeIndex()"
                      ]
                    },
                    {
                      "type": {
                        "value": "TiledRoad::RoadTile::BuildRoadPaths"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Shape index",
              "functionType": "Expression",
              "name": "ShapeIndex",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TiledRoad::RoadTile::PropertyShapeName"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"L-Shaped bend\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "1"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TiledRoad::RoadTile::PropertyShapeName"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"Crossroads\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "2"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TiledRoad::RoadTile::PropertyShapeName"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "\"T-Shaped crossroads\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "3"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Follow a road path",
              "functionType": "Action",
              "name": "SetRoadPath",
              "sentence": "_PARAM4_ follow the path of _PARAM0_ from edge _PARAM2_ to edge _PARAM3_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "PathIndex",
                        "=",
                        "Object.Behavior::PathIndex(OriginEdge, TargetEdge)"
                      ]
                    },
                    {
                      "type": {
                        "value": "MettreXY"
                      },
                      "parameters": [
                        "MovingObject",
                        "=",
                        "Object.X() + Object.Behavior::RatioToPixel(Paths[PathIndex].OriginX)",
                        "=",
                        "Object.Y() + Object.Behavior::RatioToPixel(Paths[PathIndex].OriginY)"
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetPath"
                      },
                      "parameters": [
                        "MovingObject",
                        "SpeedPathMovement",
                        "Paths[PathIndex].PathName",
                        "1",
                        "",
                        ""
                      ]
                    }
                  ],
                  "events": [
                    {
                      "disabled": true,
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "DebuggerTools::ConsoleLog"
                          },
                          "parameters": [
                            "\"Shape: \" + Shape",
                            "\"info\"",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "DebuggerTools::ConsoleLog"
                          },
                          "parameters": [
                            "\"OriginEdge: \" + ToString(Object.Behavior::UnrotatedEdge(OriginEdge))",
                            "\"info\"",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "DebuggerTools::ConsoleLog"
                          },
                          "parameters": [
                            "\"TargetEdge: \" + ToString(Object.Behavior::UnrotatedEdge(TargetEdge))",
                            "\"info\"",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "DebuggerTools::ConsoleLog"
                          },
                          "parameters": [
                            "\"OriginX: \" + Paths[PathIndex].OriginX",
                            "\"info\"",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "DebuggerTools::ConsoleLog"
                          },
                          "parameters": [
                            "\"OriginY: \" + Paths[PathIndex].OriginY",
                            "\"info\"",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "DebuggerTools::ConsoleLog"
                          },
                          "parameters": [
                            "\"PathIndex: \" + PathIndex",
                            "\"info\"",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "DebuggerTools::ConsoleLog"
                          },
                          "parameters": [
                            "\"PathName: \" + Paths[PathIndex].PathName",
                            "\"info\"",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "variables": [
                    {
                      "folded": true,
                      "name": "PathIndex",
                      "type": "number",
                      "value": 0
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Origin edge",
                  "name": "OriginEdge",
                  "type": "expression"
                },
                {
                  "description": "Target edge",
                  "name": "TargetEdge",
                  "type": "expression"
                },
                {
                  "description": "Moving object",
                  "name": "MovingObject",
                  "type": "objectList"
                },
                {
                  "description": "Movement on a curve (speed-based)",
                  "name": "SpeedPathMovement",
                  "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Path name",
              "functionType": "StringExpression",
              "name": "PathName",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnString"
                      },
                      "parameters": [
                        "Paths[Object.Behavior::PathIndex(OriginEdge, TargetEdge)].PathName"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "string"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Origin edge",
                  "name": "OriginEdge",
                  "type": "expression"
                },
                {
                  "description": "Target edge",
                  "name": "TargetEdge",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Path index",
              "functionType": "Expression",
              "name": "PathIndex",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "mod(Roads[Shape][Object.Behavior::UnrotatedEdge(OriginEdge)].PathsByEdge[Object.Behavior::UnrotatedEdge(TargetEdge)] + 3 * Object.Behavior::DirectionDelta(), 12)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Origin edge",
                  "name": "OriginEdge",
                  "type": "expression"
                },
                {
                  "description": "Target edge",
                  "name": "TargetEdge",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Random target edge",
              "functionType": "Expression",
              "name": "RandomTargetEdgeFrom",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "UnrotatedOriginEdge",
                        "=",
                        "Object.Behavior::UnrotatedEdge(OriginEdge)"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::RotatedEdge(Roads[Shape][UnrotatedOriginEdge].PathTargets[Random(VariableChildCount(Roads[Shape][UnrotatedOriginEdge].PathTargets) - 1)])"
                      ]
                    }
                  ],
                  "variables": [
                    {
                      "folded": true,
                      "name": "UnrotatedOriginEdge",
                      "type": "number",
                      "value": 0
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Origin edge",
                  "name": "OriginEdge",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Random origin edge",
              "functionType": "Expression",
              "name": "RandomOriginEdge",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::RotatedEdge(RoadOrigins[Shape][Random(VariableChildCount(RoadOrigins[Shape]) - 1)])"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Build road paths",
              "functionType": "Action",
              "name": "BuildRoadPaths",
              "private": true,
              "sentence": "Build road paths",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BooleanVariable"
                      },
                      "parameters": [
                        "IsPathesBuilt",
                        "=",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetBooleanVariable"
                      },
                      "parameters": [
                        "IsPathesBuilt",
                        "True",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "CurvedMovement::AddLine"
                      },
                      "parameters": [
                        "",
                        "\"RoadStraight0\"",
                        "TileSize",
                        "0",
                        "",
                        ""
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "Radius",
                            "=",
                            "Object.Behavior::RatioToPixel(0.75)"
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::AddCubicCurve"
                          },
                          "parameters": [
                            "",
                            "\"RoadBigBend0\"",
                            "0",
                            "0.552 * Radius",
                            "0.552 * Radius",
                            "Radius",
                            "Radius",
                            "Radius",
                            "",
                            ""
                          ]
                        }
                      ],
                      "variables": [
                        {
                          "folded": true,
                          "name": "Radius",
                          "type": "number",
                          "value": 0
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "Radius",
                            "=",
                            "Object.Behavior::RatioToPixel(0.25)"
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::AddCubicCurve"
                          },
                          "parameters": [
                            "",
                            "\"RoadSmallBend0\"",
                            "0",
                            "-0.552 * Radius",
                            "0.552 * Radius",
                            "-Radius",
                            "Radius",
                            "-Radius",
                            "",
                            ""
                          ]
                        }
                      ],
                      "variables": [
                        {
                          "folded": true,
                          "name": "Radius",
                          "type": "number",
                          "value": 0
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Repeat",
                          "repeatExpression": "3",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "CurvedMovement::DuplicatedPath"
                              },
                              "parameters": [
                                "",
                                "\"RoadStraight\" + Direction",
                                "\"RoadStraight0\"",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "CurvedMovement::RotatePath"
                              },
                              "parameters": [
                                "",
                                "\"RoadStraight\" + Direction",
                                "Direction * 90",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "CurvedMovement::DuplicatedPath"
                              },
                              "parameters": [
                                "",
                                "\"RoadBigBend\" + Direction",
                                "\"RoadBigBend0\"",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "CurvedMovement::RotatePath"
                              },
                              "parameters": [
                                "",
                                "\"RoadBigBend\" + Direction",
                                "Direction * 90",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "CurvedMovement::DuplicatedPath"
                              },
                              "parameters": [
                                "",
                                "\"RoadSmallBend\" + Direction",
                                "\"RoadSmallBend0\"",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "CurvedMovement::RotatePath"
                              },
                              "parameters": [
                                "",
                                "\"RoadSmallBend\" + Direction",
                                "Direction * 90",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "Direction",
                                "+",
                                "1"
                              ]
                            }
                          ]
                        }
                      ],
                      "variables": [
                        {
                          "folded": true,
                          "name": "Direction",
                          "type": "number",
                          "value": 1
                        }
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Ratio to pixel",
              "functionType": "Expression",
              "name": "RatioToPixel",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CompareArgumentAsNumber"
                      },
                      "parameters": [
                        "\"Value\"",
                        ">",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "CompareArgumentAsNumber"
                      },
                      "parameters": [
                        "\"Value\"",
                        "<",
                        "1"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Margin + (TileSize - 2 * Margin) * Value"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Margins don't apply on road ends."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CompareArgumentAsNumber"
                      },
                      "parameters": [
                        "\"Value\"",
                        "=",
                        "0"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "0"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CompareArgumentAsNumber"
                      },
                      "parameters": [
                        "\"Value\"",
                        "=",
                        "1"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "TileSize"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Direction delta",
              "functionType": "Expression",
              "name": "DirectionDelta",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "round((Object.Angle() + RotationOffset) / 90)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Rotated edge",
              "functionType": "Expression",
              "name": "RotatedEdge",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "mod(Value + Object.Behavior::DirectionDelta(), 4)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Rotated edge",
              "functionType": "Expression",
              "name": "UnrotatedEdge",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "mod(Value - Object.Behavior::DirectionDelta(), 4)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Rotated path index",
              "functionType": "Expression",
              "name": "RotatedPathIndex",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "mod(Value + 3 * Object.Behavior::DirectionDelta(), 12)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Is crossroad",
              "functionType": "Condition",
              "name": "IsCrossroad",
              "sentence": "_PARAM0_ is a crossroad",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "value": "TiledRoad::RoadTile::PropertyShapeName"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "\"Crossroads\""
                          ]
                        },
                        {
                          "type": {
                            "value": "TiledRoad::RoadTile::PropertyShapeName"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "\"T-Shaped crossroads\""
                          ]
                        }
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "Line",
              "type": "Choice",
              "label": "Shape",
              "description": "",
              "group": "",
              "extraInformation": [
                "Line",
                "L-Shaped bend",
                "Crossroads",
                "T-Shaped crossroads"
              ],
              "name": "ShapeName"
            },
            {
              "value": "0",
              "type": "Number",
              "label": "Rotation offset",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "RotationOffset"
            },
            {
              "value": "",
              "type": "Number",
              "label": "Shape index",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Shape"
            }
          ],
          "sharedPropertyDescriptors": [
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Margin",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Margin"
            },
            {
              "value": "64",
              "type": "Number",
              "unit": "Pixel",
              "label": "Tile size",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "TileSize"
            }
          ]
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "",
      "extensionNamespace": "",
      "fullName": "",
      "helpPath": "",
      "iconUrl": "",
      "name": "ObjectRectangularGrid",
      "previewIconUrl": "",
      "shortDescription": "",
      "version": "",
      "description": "",
      "tags": [],
      "authorIds": [],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Check if a cell of the grid contains the object.",
          "fullName": "Contain at",
          "functionType": "Condition",
          "group": "Object Stack",
          "name": "ContainsAt",
          "sentence": "_PARAM3_ is into the grid of _PARAM1_ at _PARAM4_ ; _PARAM5_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const stackBehaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const gridObjectsLists = eventsFunctionContext.getObjectsLists(\"Object\");",
                "/** @type {Hashtable<gdjs.RuntimeObject[]>} */",
                "const elementObjectsLists = eventsFunctionContext.getObjectsLists(\"Element\");",
                "",
                "const cellX = eventsFunctionContext.getArgument(\"CellX\");",
                "const cellY = eventsFunctionContext.getArgument(\"CellY\");",
                "",
                "// This code is duplicated from ContainsBetween because the picking wouldn't pass from one function to the other.",
                "eventsFunctionContext.returnValue = gdjs.evtTools.object.twoListsTest(",
                "  (gridObject, element) => {",
                "    const behavior = gridObject.getBehavior(stackBehaviorName);",
                "    return behavior.objectRectangularGrid.getAt(cellX, cellY) === element;",
                "  },",
                "  gridObjectsLists,",
                "  elementObjectsLists,",
                "  false",
                ");",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Grid",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Grid behavior",
              "name": "Behavior",
              "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
              "type": "behavior"
            },
            {
              "description": "Element",
              "name": "Element",
              "type": "objectList"
            },
            {
              "description": "Cell X",
              "name": "CellX",
              "type": "expression"
            },
            {
              "description": "CellY",
              "name": "CellY",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs._objectRectangularGridExtension) {",
                "    return;",
                "}",
                "",
                "// Remove from deleted objects from stacks.",
                "gdjs.registerObjectDeletedFromSceneCallback(function (runtimeScene, obj) {",
                "    const extension = runtimeScene._objectRectangularGridExtension;",
                "    if (!extension) {",
                "        return;",
                "    }",
                "    if (extension.allUsedObjects.has(obj)) {",
                "        extension.allUsedObjects.delete(obj);",
                "        for (const objectGrid of extension.allObjectGrids) {",
                "            objectGrid.remove(obj);",
                "        }",
                "    }",
                "});",
                "",
                "class ObjectGrid {",
                "    /**",
                "     * @type {Array<Array<gdjs.RuntimeObject>>}",
                "     */",
                "    grid = [];",
                "    /**",
                "     * @type {Map<number, {x: number, y: number}>}",
                "     */",
                "    cellsByObjectId = new Map();",
                "",
                "    constructor() {",
                "    }",
                "",
                "    /**",
                "     * @param {number} cellX",
                "     * @param {number} cellY",
                "     * @param {gdjs.RuntimeObject} object",
                "     */",
                "    setAt(cellX, cellY, object) {",
                "        const oldObject = this.getAt(cellX, cellY);",
                "        if (oldObject) {",
                "            this.cellsByObjectId.delete(oldObject.getUniqueId());",
                "        }",
                "        this.cellsByObjectId.set(object.getUniqueId(), {x: cellX, y: cellY});",
                "",
                "        let row = this.grid[cellY];",
                "        if (!row) {",
                "            row = [];",
                "            this.grid[cellY] = row;",
                "        }",
                "        row[cellX] = object;",
                "    }",
                "",
                "    /**",
                "     * @param {number} cellX",
                "     * @param {number} cellY",
                "     * @return {gdjs.RuntimeObject}",
                "     */",
                "    getAt(cellX, cellY) {",
                "        const row = this.grid[cellY];",
                "        return row && row[cellX];",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject}",
                "     * @return {{x: number, y: number}}",
                "     */",
                "    getCell(object) {",
                "        return this.cellsByObjectId.get(object.getUniqueId());",
                "    }",
                "",
                "    /**",
                "     * @param {gdjs.RuntimeObject} object",
                "     */",
                "    remove(object) {",
                "        const cell = this.cellsByObjectId.get(object.getUniqueId());",
                "        if (cell) {",
                "            this.grid[cell.y][cell.x] = null;",
                "            this.cellsByObjectId.delete(object.getUniqueId());",
                "        }",
                "    }",
                "",
                "    clear() {",
                "        this.grid.length = 0;",
                "        this.cellsByObjectId.clear();",
                "    }",
                "}",
                "",
                "gdjs._objectRectangularGridExtension = {",
                "    ObjectGrid",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "",
          "fullName": "",
          "name": "ObjectRectangularGrid",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ObjectRectangularGrid::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const ObjectGrid = gdjs._objectRectangularGridExtension.ObjectGrid;",
                    "",
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "behavior.objectRectangularGrid = new ObjectGrid();",
                    "",
                    "if (!runtimeScene._objectRectangularGridExtension) {",
                    "  runtimeScene._objectRectangularGridExtension = {",
                    "    allObjectGrids: new Set(),",
                    "    // Its only use is to have a O(1) check for",
                    "    // deleted objects that have never been in a stack.",
                    "    allUsedObjects: new Set()",
                    "  };",
                    "}",
                    "runtimeScene._objectRectangularGridExtension.allObjectGrids.add(behavior.objectRectangularGrid);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onDestroy",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "runtimeScene._objectRectangularGridExtension.allObjectGrids.delete(behavior);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Add to grid (from position)",
              "functionType": "Action",
              "name": "AddFromPosition",
              "sentence": "Add _PARAM2_ into the grid of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::ForEach",
                  "object": "Element",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ObjectRectangularGrid::ObjectRectangularGrid::AddAt"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "Element",
                        "Object.Behavior::SnapX(Element.X())",
                        "Object.Behavior::SnapX(Element.Y())",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Element",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Add to grid (from cell indexes)",
              "functionType": "Action",
              "name": "AddAt",
              "sentence": "Add _PARAM2_ into the cell _PARAM3_ ; _PARAM4_ of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = object.getBehavior(behaviorName);",
                    "const elements = eventsFunctionContext.getObjects(\"Element\");",
                    "const cellX = eventsFunctionContext.getArgument(\"CellX\");",
                    "const cellY = eventsFunctionContext.getArgument(\"CellY\");",
                    "",
                    "const grid = behavior.objectRectangularGrid;",
                    "",
                    "for (const element of elements) {",
                    "  grid.setAt(cellX, cellY, element);",
                    "  runtimeScene._objectRectangularGridExtension.allUsedObjects.add(element);",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Element",
                  "type": "objectList"
                },
                {
                  "description": "Cell X",
                  "name": "CellX",
                  "type": "expression"
                },
                {
                  "description": "Cell Y",
                  "name": "CellY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Cell X",
              "functionType": "Expression",
              "name": "CellX",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "const elements = eventsFunctionContext.getObjects(\"Element\");",
                    "",
                    "eventsFunctionContext.returnValue = behavior.objectRectangularGrid.getCell(elements[0]).x;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Element",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Cell Y",
              "functionType": "Expression",
              "name": "CellY",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "const elements = eventsFunctionContext.getObjects(\"Element\");",
                    "",
                    "eventsFunctionContext.returnValue = behavior.objectRectangularGrid.getCell(elements[0]).y;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
                  "type": "behavior"
                },
                {
                  "description": "Object",
                  "name": "Element",
                  "type": "objectList"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Snap X",
              "functionType": "Expression",
              "name": "SnapX",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "floor((PositionX - OffsetX) / CellWidth)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
                  "type": "behavior"
                },
                {
                  "description": "Position X",
                  "name": "PositionX",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Snap Y",
              "functionType": "Expression",
              "name": "SnapY",
              "private": true,
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "floor((PositionY - OffsetY) / CellHeight)"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
                  "type": "behavior"
                },
                {
                  "description": "Position Y",
                  "name": "PositionY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "64",
              "type": "Number",
              "unit": "Pixel",
              "label": "Cell width",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "CellWidth"
            },
            {
              "value": "64",
              "type": "Number",
              "unit": "Pixel",
              "label": "Cell height",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "CellHeight"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Offset X",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "OffsetX"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Offset Y",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "OffsetY"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "",
      "extensionNamespace": "",
      "fullName": "",
      "helpPath": "",
      "iconUrl": "",
      "name": "TrafficCar",
      "previewIconUrl": "",
      "shortDescription": "",
      "version": "",
      "description": "",
      "tags": [],
      "authorIds": [],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "fullName": "Move on road",
          "functionType": "Action",
          "name": "Move",
          "sentence": "Move _PARAM1_ on _PARAM6_ from _PARAM4_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::ForEach",
              "object": "Object",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "TrafficCar::TrafficCar::SwitchOfRoad"
                  },
                  "parameters": [
                    "Object",
                    "Behavior",
                    "RoadGrid",
                    "ObjectRectangularGrid",
                    "Road",
                    "RoadTile",
                    "ObjectStack",
                    ""
                  ]
                }
              ],
              "events": [
                {
                  "disabled": true,
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::SetPropertyNextCarDistance"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "0"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::PropertyNextCarDistance"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "<",
                        "100"
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "ObjectStack::Contains"
                          },
                          "parameters": [
                            "",
                            "Road",
                            "ObjectStack",
                            "Object",
                            "0"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "CellX",
                            "=",
                            "RoadGrid.ObjectRectangularGrid::CellX(Road)"
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "CellY",
                            "=",
                            "RoadGrid.ObjectRectangularGrid::CellY(Road)"
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "TargetEdge",
                            "=",
                            "Object.Behavior::PropertyRoadTargetEdge()"
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "OriginEdge",
                            "=",
                            "Object.Behavior::PropertyRoadOriginEdge()"
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "PositionOnPath",
                            "=",
                            "Object.SpeedPathMovement::PositionOnPath()"
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "PathLength",
                            "=",
                            "Object.SpeedPathMovement::PathLength()"
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "PositionMin",
                            "=",
                            "123456890"
                          ]
                        }
                      ],
                      "events": [
                        {
                          "disabled": true,
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "DebuggerTools::ConsoleLog"
                              },
                              "parameters": [
                                "\"Check: \" + CellX + \" \" + CellY",
                                "\"info\"",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "AjoutObjConcern"
                              },
                              "parameters": [
                                "",
                                "Object"
                              ]
                            },
                            {
                              "type": {
                                "value": "ObjectStack::Contains"
                              },
                              "parameters": [
                                "",
                                "Road",
                                "ObjectStack",
                                "Object",
                                "0"
                              ]
                            }
                          ],
                          "actions": [],
                          "events": [
                            {
                              "type": "BuiltinCommonInstructions::ForEach",
                              "object": "Object",
                              "conditions": [
                                {
                                  "type": {
                                    "value": "TrafficCar::TrafficCar::PropertyRoadOriginEdge"
                                  },
                                  "parameters": [
                                    "Object",
                                    "Behavior",
                                    "=",
                                    "OriginEdge"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "CurvedMovement::SpeedPathMovement::PositionOnPath"
                                  },
                                  "parameters": [
                                    "Object",
                                    "SpeedPathMovement",
                                    ">",
                                    "PositionOnPath",
                                    ""
                                  ]
                                }
                              ],
                              "actions": [
                                {
                                  "type": {
                                    "value": "SetNumberVariable"
                                  },
                                  "parameters": [
                                    "PositionMin",
                                    "=",
                                    "min(PositionMin, Object.SpeedPathMovement::PositionOnPath())"
                                  ]
                                }
                              ]
                            },
                            {
                              "disabled": true,
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "DebuggerTools::ConsoleLog"
                                  },
                                  "parameters": [
                                    "\"PositionMin: \" + PositionMin",
                                    "\"info\"",
                                    ""
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "NumberVariable"
                              },
                              "parameters": [
                                "PositionMin",
                                "!=",
                                "123456890"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "NextCarDistance",
                                "+",
                                "(PositionMin - 50) - PositionOnPath"
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "NumberVariable"
                              },
                              "parameters": [
                                "PositionMin",
                                "=",
                                "123456890"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "NextCarDistance",
                                "+",
                                "PathLength - PositionOnPath"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "CellX",
                                "+",
                                "TiledRoad::EdgeDeltaX(TargetEdge)"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "CellY",
                                "+",
                                "TiledRoad::EdgeDeltaY(TargetEdge)"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "OriginEdge",
                                "=",
                                "TiledRoad::OppositeEdge(TargetEdge)"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "TargetEdge",
                                "=",
                                "Road.RoadTile::RandomTargetEdgeFrom(OriginEdge)"
                              ]
                            }
                          ]
                        },
                        {
                          "infiniteLoopWarning": true,
                          "type": "BuiltinCommonInstructions::While",
                          "whileConditions": [
                            {
                              "type": {
                                "value": "NumberVariable"
                              },
                              "parameters": [
                                "PositionMin",
                                "=",
                                "123456890"
                              ]
                            },
                            {
                              "type": {
                                "value": "NumberVariable"
                              },
                              "parameters": [
                                "NextCarDistance",
                                "<",
                                "600"
                              ]
                            },
                            {
                              "type": {
                                "value": "NumberVariable"
                              },
                              "parameters": [
                                "Iteration",
                                "<",
                                "100"
                              ]
                            }
                          ],
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "Iteration",
                                "+",
                                "1"
                              ]
                            }
                          ],
                          "events": [
                            {
                              "disabled": true,
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "DebuggerTools::ConsoleLog"
                                  },
                                  "parameters": [
                                    "\"Check: \" + CellX + \" \" + CellY",
                                    "\"info\"",
                                    ""
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [
                                {
                                  "type": {
                                    "value": "AjoutObjConcern"
                                  },
                                  "parameters": [
                                    "",
                                    "Object"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "AjoutObjConcern"
                                  },
                                  "parameters": [
                                    "",
                                    "Road"
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "ObjectRectangularGrid::ContainsAt"
                                  },
                                  "parameters": [
                                    "",
                                    "RoadGrid",
                                    "ObjectRectangularGrid",
                                    "Road",
                                    "CellX",
                                    "CellY",
                                    ""
                                  ]
                                }
                              ],
                              "actions": [],
                              "events": [
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [
                                    {
                                      "type": {
                                        "value": "TiledRoad::RoadTile::IsCrossroad"
                                      },
                                      "parameters": [
                                        "Road",
                                        "RoadTile",
                                        ""
                                      ]
                                    }
                                  ],
                                  "actions": [
                                    {
                                      "type": {
                                        "value": "SetNumberVariable"
                                      },
                                      "parameters": [
                                        "PositionMin",
                                        "=",
                                        "0"
                                      ]
                                    }
                                  ],
                                  "events": [
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "NumberVariable"
                                          },
                                          "parameters": [
                                            "Iteration",
                                            "=",
                                            "1"
                                          ]
                                        }
                                      ],
                                      "actions": [],
                                      "events": [
                                        {
                                          "type": "BuiltinCommonInstructions::Standard",
                                          "conditions": [
                                            {
                                              "type": {
                                                "value": "ObjectStack::Contains"
                                              },
                                              "parameters": [
                                                "Road",
                                                "Road",
                                                "ObjectStack",
                                                "Object",
                                                ""
                                              ]
                                            },
                                            {
                                              "type": {
                                                "value": "TrafficCar::TrafficCar::PropertyRoadOriginEdge"
                                              },
                                              "parameters": [
                                                "Object",
                                                "Behavior",
                                                "!=",
                                                "OriginEdge"
                                              ]
                                            }
                                          ],
                                          "actions": [
                                            {
                                              "type": {
                                                "value": "SetBooleanVariable"
                                              },
                                              "parameters": [
                                                "CanCross",
                                                "False",
                                                ""
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "type": "BuiltinCommonInstructions::Standard",
                                          "conditions": [
                                            {
                                              "type": {
                                                "value": "BooleanVariable"
                                              },
                                              "parameters": [
                                                "CanCross",
                                                "True",
                                                "1"
                                              ]
                                            }
                                          ],
                                          "actions": [
                                            {
                                              "type": {
                                                "value": "SetNumberVariable"
                                              },
                                              "parameters": [
                                                "NextCarDistance",
                                                "+",
                                                "100"
                                              ]
                                            }
                                          ]
                                        }
                                      ],
                                      "variables": [
                                        {
                                          "folded": true,
                                          "name": "CanCross",
                                          "type": "boolean",
                                          "value": true
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "type": "BuiltinCommonInstructions::Standard",
                                  "conditions": [
                                    {
                                      "type": {
                                        "inverted": true,
                                        "value": "TiledRoad::RoadTile::IsCrossroad"
                                      },
                                      "parameters": [
                                        "Road",
                                        "RoadTile",
                                        ""
                                      ]
                                    }
                                  ],
                                  "actions": [],
                                  "events": [
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "ObjectStack::Contains"
                                          },
                                          "parameters": [
                                            "",
                                            "Road",
                                            "ObjectStack",
                                            "Object",
                                            "0"
                                          ]
                                        }
                                      ],
                                      "actions": [],
                                      "events": [
                                        {
                                          "type": "BuiltinCommonInstructions::ForEach",
                                          "object": "Object",
                                          "conditions": [],
                                          "actions": [],
                                          "events": [
                                            {
                                              "type": "BuiltinCommonInstructions::Standard",
                                              "conditions": [
                                                {
                                                  "type": {
                                                    "value": "TrafficCar::TrafficCar::PropertyRoadOriginEdge"
                                                  },
                                                  "parameters": [
                                                    "Object",
                                                    "Behavior",
                                                    "=",
                                                    "OriginEdge"
                                                  ]
                                                }
                                              ],
                                              "actions": [
                                                {
                                                  "type": {
                                                    "value": "SetNumberVariable"
                                                  },
                                                  "parameters": [
                                                    "PositionMin",
                                                    "=",
                                                    "min(PositionMin, Object.SpeedPathMovement::PositionOnPath())"
                                                  ]
                                                }
                                              ]
                                            },
                                            {
                                              "disabled": true,
                                              "type": "BuiltinCommonInstructions::Standard",
                                              "conditions": [
                                                {
                                                  "type": {
                                                    "value": "TrafficCar::TrafficCar::PropertyRoadOriginEdge"
                                                  },
                                                  "parameters": [
                                                    "Object",
                                                    "Behavior",
                                                    "!=",
                                                    "OriginEdge"
                                                  ]
                                                }
                                              ],
                                              "actions": [
                                                {
                                                  "type": {
                                                    "value": "DebuggerTools::ConsoleLog"
                                                  },
                                                  "parameters": [
                                                    "\"See a car: \" + ToString(Object.Behavior::PropertyRoadOriginEdge()) + \" != \" + OriginEdge + \" at \" + CellX + \" \" + CellY",
                                                    "\"info\"",
                                                    ""
                                                  ]
                                                }
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "NumberVariable"
                                          },
                                          "parameters": [
                                            "PositionMin",
                                            "!=",
                                            "123456890"
                                          ]
                                        }
                                      ],
                                      "actions": [
                                        {
                                          "type": {
                                            "value": "SetNumberVariable"
                                          },
                                          "parameters": [
                                            "NextCarDistance",
                                            "+",
                                            "PositionMin - 50"
                                          ]
                                        }
                                      ],
                                      "events": [
                                        {
                                          "disabled": true,
                                          "type": "BuiltinCommonInstructions::Standard",
                                          "conditions": [],
                                          "actions": [
                                            {
                                              "type": {
                                                "value": "DebuggerTools::ConsoleLog"
                                              },
                                              "parameters": [
                                                "\"Found a car: \" + CellX + \" \" + CellY",
                                                "\"info\"",
                                                ""
                                              ]
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "type": "BuiltinCommonInstructions::Standard",
                                      "conditions": [
                                        {
                                          "type": {
                                            "value": "NumberVariable"
                                          },
                                          "parameters": [
                                            "PositionMin",
                                            "=",
                                            "123456890"
                                          ]
                                        }
                                      ],
                                      "actions": [
                                        {
                                          "type": {
                                            "value": "SetNumberVariable"
                                          },
                                          "parameters": [
                                            "NextCarDistance",
                                            "+",
                                            "CurvedMovement::PathLength(Road.RoadTile::PathName(OriginEdge, TargetEdge))"
                                          ]
                                        },
                                        {
                                          "type": {
                                            "value": "SetNumberVariable"
                                          },
                                          "parameters": [
                                            "CellX",
                                            "+",
                                            "TiledRoad::EdgeDeltaX(TargetEdge)"
                                          ]
                                        },
                                        {
                                          "type": {
                                            "value": "SetNumberVariable"
                                          },
                                          "parameters": [
                                            "CellY",
                                            "+",
                                            "TiledRoad::EdgeDeltaY(TargetEdge)"
                                          ]
                                        },
                                        {
                                          "type": {
                                            "value": "SetNumberVariable"
                                          },
                                          "parameters": [
                                            "OriginEdge",
                                            "=",
                                            "TiledRoad::OppositeEdge(TargetEdge)"
                                          ]
                                        },
                                        {
                                          "type": {
                                            "value": "SetNumberVariable"
                                          },
                                          "parameters": [
                                            "TargetEdge",
                                            "=",
                                            "Road.RoadTile::RandomTargetEdgeFrom(OriginEdge)"
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "TrafficCar::TrafficCar::SetPropertyNextCarDistance"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "NextCarDistance"
                              ]
                            }
                          ],
                          "events": [
                            {
                              "disabled": true,
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "DebuggerTools::ConsoleLog"
                                  },
                                  "parameters": [
                                    "\"NextCarDistance: \" + NextCarDistance",
                                    "\"info\"",
                                    ""
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ],
                      "variables": [
                        {
                          "folded": true,
                          "name": "CellX",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "CellY",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "OriginEdge",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "TargetEdge",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "PositionOnPath",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "NextCarDistance",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "PositionMin",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "PathLength",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "Iteration",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "Variable",
                          "type": "number",
                          "value": 0
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "type": "objectList"
            },
            {
              "description": "Behavior",
              "name": "Behavior",
              "supplementaryInformation": "TrafficCar::TrafficCar",
              "type": "behavior"
            },
            {
              "description": "Movement on a curve (speed-based)",
              "name": "SpeedPathMovement",
              "supplementaryInformation": "CurvedMovement::SpeedPathMovement",
              "type": "behavior"
            },
            {
              "description": "Road grid",
              "name": "RoadGrid",
              "type": "objectList"
            },
            {
              "description": "Object rectangular grid",
              "name": "ObjectRectangularGrid",
              "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
              "type": "behavior"
            },
            {
              "description": "Road",
              "name": "Road",
              "type": "objectList"
            },
            {
              "description": "Road tile",
              "name": "RoadTile",
              "supplementaryInformation": "TiledRoad::RoadTile",
              "type": "behavior"
            },
            {
              "description": "Object stack",
              "name": "ObjectStack",
              "supplementaryInformation": "ObjectStack::ObjectStack",
              "type": "behavior"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "",
          "fullName": "Traffic car",
          "name": "TrafficCar",
          "objectType": "",
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPreEvents",
              "sentence": "",
              "events": [
                {
                  "disabled": true,
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "DebuggerTools::ConsoleLog"
                      },
                      "parameters": [
                        "ToString(max(0, Object.SpeedPathMovement::PositionOnPath() - OldPathPosition))",
                        "\"info\"",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::SetPropertyNextCarDistance"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "-",
                        "max(0, Object.SpeedPathMovement::PositionOnPath() - OldPathPosition)"
                      ]
                    },
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::SetPropertyOldPathPosition"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.SpeedPathMovement::PositionOnPath()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::PropertyNextCarDistance"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ">=",
                        "100"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::AccelarateAt"
                      },
                      "parameters": [
                        "Object",
                        "SpeedPathMovement",
                        "SpeedMax",
                        "Acceleration",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::PropertyNextCarDistance"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "<",
                        "100"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::AccelarateAt"
                      },
                      "parameters": [
                        "Object",
                        "SpeedPathMovement",
                        "0",
                        "-Deceleration",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::PropertyNextCarDistance"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "<",
                        "50"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::SetSpeed"
                      },
                      "parameters": [
                        "Object",
                        "SpeedPathMovement",
                        "=",
                        "0",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "disabled": true,
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "DebuggerTools::ConsoleLog"
                      },
                      "parameters": [
                        "\"NextCarDistance: \" + NextCarDistance",
                        "\"info\"",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "inverted": true,
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedAnEnd"
                      },
                      "parameters": [
                        "Object",
                        "SpeedPathMovement",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::SetPropertySpeed"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.SpeedPathMovement::Speed()"
                      ]
                    }
                  ]
                },
                {
                  "disabled": true,
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BuiltinCommonInstructions::Or"
                      },
                      "parameters": [],
                      "subInstructions": [
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::Speed"
                          },
                          "parameters": [
                            "Object",
                            "SpeedPathMovement",
                            ">",
                            "SpeedMax",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::Speed"
                          },
                          "parameters": [
                            "Object",
                            "SpeedPathMovement",
                            "<",
                            "0",
                            ""
                          ]
                        }
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "DebuggerTools::ConsoleLog"
                      },
                      "parameters": [
                        "\"Speed: \" + Speed",
                        "\"info\"",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TrafficCar::TrafficCar",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "Switch of road",
              "functionType": "Action",
              "name": "SwitchOfRoad",
              "private": true,
              "sentence": "Switch _PARAM0_ from _PARAM4_ within _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::PropertyHasJustBeenCreated"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    },
                    {
                      "type": {
                        "value": "CollisionNP"
                      },
                      "parameters": [
                        "Object",
                        "Road",
                        "",
                        "",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "AjoutHasard"
                      },
                      "parameters": [
                        "",
                        "Object"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "TrafficCar::TrafficCar::SetPropertyHasJustBeenCreated"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "ObjectStack::ObjectStack::AddOnTop"
                          },
                          "parameters": [
                            "Road",
                            "ObjectStack",
                            "Object",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "TrafficCar::TrafficCar::SetPropertyRoadOriginEdge"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "Road.RoadTile::RandomOriginEdge()"
                          ]
                        },
                        {
                          "type": {
                            "value": "TrafficCar::TrafficCar::SetPropertyRoadTargetEdge"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "Road.RoadTile::RandomTargetEdgeFrom(RoadOriginEdge)"
                          ]
                        },
                        {
                          "type": {
                            "value": "TiledRoad::RoadTile::SetRoadPath"
                          },
                          "parameters": [
                            "Road",
                            "RoadTile",
                            "RoadOriginEdge",
                            "RoadTargetEdge",
                            "Object",
                            "SpeedPathMovement",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetPositionOnPath"
                          },
                          "parameters": [
                            "Object",
                            "SpeedPathMovement",
                            "=",
                            "RandomFloat(Object.SpeedPathMovement::PathLength())",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "CurvedMovement::SpeedPathMovement::SetSpeed"
                          },
                          "parameters": [
                            "Object",
                            "SpeedPathMovement",
                            "=",
                            "SpeedMax",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "TrafficCar::TrafficCar::SetPropertyOldPathPosition"
                          },
                          "parameters": [
                            "Object",
                            "Behavior",
                            "=",
                            "Object.SpeedPathMovement::PositionOnPath()"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "CurvedMovement::SpeedPathMovement::HasReachedAnEnd"
                      },
                      "parameters": [
                        "Object",
                        "SpeedPathMovement",
                        ""
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "ObjectStack::Contains"
                              },
                              "parameters": [
                                "",
                                "Road",
                                "ObjectStack",
                                "Object",
                                "0"
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "CellX",
                                "=",
                                "RoadGrid.ObjectRectangularGrid::CellX(Road)"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "CellY",
                                "=",
                                "RoadGrid.ObjectRectangularGrid::CellY(Road)"
                              ]
                            },
                            {
                              "type": {
                                "value": "ObjectStack::ObjectStack::Remove"
                              },
                              "parameters": [
                                "Road",
                                "ObjectStack",
                                "Object",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "CellX",
                                "+",
                                "TiledRoad::EdgeDeltaX(RoadTargetEdge)"
                              ]
                            },
                            {
                              "type": {
                                "value": "SetNumberVariable"
                              },
                              "parameters": [
                                "CellY",
                                "+",
                                "TiledRoad::EdgeDeltaY(RoadTargetEdge)"
                              ]
                            }
                          ],
                          "events": [
                            {
                              "disabled": true,
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "DebuggerTools::ConsoleLog"
                                  },
                                  "parameters": [
                                    "\"Reached the end\"",
                                    "\"info\"",
                                    ""
                                  ]
                                },
                                {
                                  "type": {
                                    "value": "DebuggerTools::ConsoleLog"
                                  },
                                  "parameters": [
                                    "CellX + \" \" + CellY",
                                    "\"info\"",
                                    ""
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [
                            {
                              "type": {
                                "value": "ObjectRectangularGrid::ContainsAt"
                              },
                              "parameters": [
                                "",
                                "RoadGrid",
                                "ObjectRectangularGrid",
                                "Road",
                                "CellX",
                                "CellY",
                                ""
                              ]
                            }
                          ],
                          "actions": [
                            {
                              "type": {
                                "value": "ObjectStack::ObjectStack::AddOnTop"
                              },
                              "parameters": [
                                "Road",
                                "ObjectStack",
                                "Object",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "TrafficCar::TrafficCar::SetPropertyRoadOriginEdge"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "TiledRoad::OppositeEdge(RoadTargetEdge)"
                              ]
                            },
                            {
                              "type": {
                                "value": "TrafficCar::TrafficCar::SetPropertyRoadTargetEdge"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "Road.RoadTile::RandomTargetEdgeFrom(RoadOriginEdge)"
                              ]
                            },
                            {
                              "type": {
                                "value": "TiledRoad::RoadTile::SetRoadPath"
                              },
                              "parameters": [
                                "Road",
                                "RoadTile",
                                "RoadOriginEdge",
                                "RoadTargetEdge",
                                "Object",
                                "SpeedPathMovement",
                                ""
                              ]
                            },
                            {
                              "type": {
                                "value": "TrafficCar::TrafficCar::SetPropertyOldPathPosition"
                              },
                              "parameters": [
                                "Object",
                                "Behavior",
                                "=",
                                "0"
                              ]
                            },
                            {
                              "type": {
                                "value": "CurvedMovement::SpeedPathMovement::SetSpeed"
                              },
                              "parameters": [
                                "Object",
                                "SpeedPathMovement",
                                "=",
                                "Speed",
                                ""
                              ]
                            }
                          ],
                          "events": [
                            {
                              "disabled": true,
                              "type": "BuiltinCommonInstructions::Standard",
                              "conditions": [],
                              "actions": [
                                {
                                  "type": {
                                    "value": "DebuggerTools::ConsoleLog"
                                  },
                                  "parameters": [
                                    "RoadOriginEdge + \" --> \" + RoadTargetEdge",
                                    "\"info\"",
                                    ""
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ],
                      "variables": [
                        {
                          "folded": true,
                          "name": "CellX",
                          "type": "number",
                          "value": 0
                        },
                        {
                          "folded": true,
                          "name": "CellY",
                          "type": "number",
                          "value": 0
                        }
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "TrafficCar::TrafficCar",
                  "type": "behavior"
                },
                {
                  "description": "Road grid",
                  "name": "RoadGrid",
                  "type": "objectList"
                },
                {
                  "description": "Object rectangular grid",
                  "name": "ObjectRectangularGrid",
                  "supplementaryInformation": "ObjectRectangularGrid::ObjectRectangularGrid",
                  "type": "behavior"
                },
                {
                  "description": "Road",
                  "name": "Road",
                  "type": "objectList"
                },
                {
                  "description": "Road tile",
                  "name": "RoadTile",
                  "supplementaryInformation": "TiledRoad::RoadTile",
                  "type": "behavior"
                },
                {
                  "description": "Object stack",
                  "name": "ObjectStack",
                  "supplementaryInformation": "ObjectStack::ObjectStack",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "",
              "type": "Behavior",
              "label": "Movement on a curve (speed-based)",
              "description": "",
              "group": "",
              "extraInformation": [
                "CurvedMovement::SpeedPathMovement"
              ],
              "name": "SpeedPathMovement"
            },
            {
              "value": "100",
              "type": "Number",
              "unit": "PixelSpeed",
              "label": "Maximum speed",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "SpeedMax"
            },
            {
              "value": "50",
              "type": "Number",
              "unit": "PixelAcceleration",
              "label": "Acceleration",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Acceleration"
            },
            {
              "value": "100",
              "type": "Number",
              "unit": "PixelAcceleration",
              "label": "Deceleration",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Deceleration"
            },
            {
              "value": "",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "RoadOriginEdge"
            },
            {
              "value": "",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "RoadTargetEdge"
            },
            {
              "value": "true",
              "type": "Boolean",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "HasJustBeenCreated"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "NextCarDistance"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "OldPathPosition"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "PixelSpeed",
              "label": "",
              "description": "",
              "group": "",
              "extraInformation": [],
              "hidden": true,
              "name": "Speed"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    }
  ],
  "externalLayouts": [
    {
      "associatedLayout": "Game",
      "name": "Level1",
      "instances": [
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "bcfdd521-fe50-4e3f-b91a-9d73b72fe96b",
          "width": 256,
          "x": 1280,
          "y": 1088,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "97210e1e-0fe2-4470-b649-52fd75667fb5",
          "width": 256,
          "x": 768,
          "y": 448,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "3e217ee2-789d-4101-bfe1-7d1f93497ca9",
          "width": 256,
          "x": 1472,
          "y": 512,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "56cbc3bf-8596-4964-9bb1-d435ef26deef",
          "width": 256,
          "x": 512,
          "y": 448,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "31650634-da10-4bef-a53d-2fbc7f00c4a6",
          "width": 256,
          "x": 512,
          "y": 1088,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "4674c98e-f9ad-4c4a-8268-d5501967fa2e",
          "width": 256,
          "x": 768,
          "y": 1088,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "0c347560-65a4-4440-baff-086fd1567d09",
          "width": 256,
          "x": 1024,
          "y": 1088,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "f33beccc-0f5b-4b92-a193-ca3289b4a14d",
          "width": 256,
          "x": 448,
          "y": 640,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "11a0284f-62eb-4ab5-8952-50ec50b45ed0",
          "width": 256,
          "x": 1472,
          "y": 768,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "521d809c-97fb-42e1-9c23-2c6c9222c207",
          "width": 256,
          "x": 1024,
          "y": 448,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "20da10ce-0b97-4329-a824-7fdf6bd740c2",
          "width": 256,
          "x": 3584,
          "y": 2240,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "3bfc6886-f8b4-4139-a58d-53d6edd675f0",
          "width": 256,
          "x": 3584,
          "y": 1600,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "11df5d8d-69e9-4c57-ab85-2915eb88aaa9",
          "width": 256,
          "x": 2176,
          "y": 1088,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "1a6ec265-0739-4bc3-9944-0bb45851a49f",
          "width": 256,
          "x": 2816,
          "y": 2240,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "92bba79a-e89e-4535-b63e-3fe3ce6e911f",
          "width": 256,
          "x": 3072,
          "y": 2240,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "6cd00539-0275-4d78-a788-e9b28b9bd55c",
          "width": 256,
          "x": 3328,
          "y": 2240,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "2d09b44a-ed70-4e35-94a2-05f8dcccfc0b",
          "width": 256,
          "x": 3328,
          "y": 1600,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "05746046-8c04-48e2-a104-fda74c0fcba0",
          "width": 256,
          "x": 2816,
          "y": 1600,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "d2139f22-6fc5-43bc-93f5-88b408a0da00",
          "width": 256,
          "x": 2752,
          "y": 1792,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "a13ec1aa-8a54-4826-8e82-c7b0f5e1f576",
          "width": 256,
          "x": 1984,
          "y": 512,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "45b8dfbf-ccf4-4465-96c5-342d6cdaff5e",
          "width": 256,
          "x": 1984,
          "y": 768,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "92d6018a-a0d6-40fc-8347-7e08a20f9f54",
          "width": 256,
          "x": 2176,
          "y": 448,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "ded079a6-f2ff-4d59-a779-86ad03033732",
          "width": 256,
          "x": 2176,
          "y": 2240,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "ea2b887a-cdbb-4a08-85be-f387a5da95df",
          "width": 256,
          "x": 2240,
          "y": 1792,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "0cdb6e4b-e015-4c82-9126-12cc1c0a9168",
          "width": 256,
          "x": 2240,
          "y": 2048,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "90cabc2e-ff2d-4902-848a-3b2ca39c81c4",
          "width": 256,
          "x": 1984,
          "y": 1664,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": -90,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Player",
          "persistentUuid": "894bdbd1-6dc0-474b-ae8a-1ced5a9cc957",
          "width": 0,
          "x": 2339,
          "y": 1701,
          "zOrder": 26,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "0da5d162-ce33-441f-a8d3-ff017d2fd2d5",
          "rotationY": 90,
          "width": 0,
          "x": 3200,
          "y": 1395,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "86323d49-bfee-409d-910f-fdeea6999501",
          "rotationY": 90,
          "width": 0,
          "x": 3104,
          "y": 1395,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "d490a1e4-922e-4837-9160-56f76758c8b6",
          "rotationY": 90,
          "width": 0,
          "x": 3008,
          "y": 1395,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "36890c73-8149-4297-981e-d83555bf4dcb",
          "rotationY": 90,
          "width": 0,
          "x": 2912,
          "y": 1395,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "d392011b-0dab-4705-93c6-1565cede70d6",
          "rotationY": 90,
          "width": 0,
          "x": 256,
          "y": 2016,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "4e80ac91-a9c6-421d-84fb-da675ade03ca",
          "rotationY": 90,
          "width": 0,
          "x": 256,
          "y": 2208,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "3f567b7d-564a-4d42-95b9-421816917e0f",
          "rotationY": 90,
          "width": 0,
          "x": 672,
          "y": 2432,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "84e79653-7e26-4fef-875f-5e858a03fbf9",
          "rotationY": 90,
          "width": 0,
          "x": 480,
          "y": 2432,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "eeda5d0e-06b7-4c85-bf36-c3092ccc8d9f",
          "rotationY": 90,
          "width": 0,
          "x": 2080,
          "y": 1284,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "274b66e4-c95e-4374-add9-c1db8090bf6d",
          "rotationY": 90,
          "width": 0,
          "x": 1984,
          "y": 1284,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "eb1a46fb-2f6b-4f05-8932-eb9d7072b3ca",
          "rotationY": 90,
          "width": 0,
          "x": 2176,
          "y": 1284,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "b619af0b-588c-42ab-b98e-add403b1c6f7",
          "rotationY": 90,
          "width": 0,
          "x": 2272,
          "y": 1284,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "464e62ae-e49a-46ec-b81c-3ffff428122b",
          "rotationY": 90,
          "width": 0,
          "x": 1344,
          "y": 1408,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "ffe78002-8cb0-45e8-953f-65648fe0bb6b",
          "rotationY": 90,
          "width": 0,
          "x": 1248,
          "y": 1408,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "d5856c94-5ca4-4e9c-ad8a-27f64107011a",
          "rotationY": 90,
          "width": 0,
          "x": 1152,
          "y": 1408,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "c6cffc5d-5845-469a-a163-11f925f31309",
          "rotationY": 90,
          "width": 0,
          "x": 1056,
          "y": 1408,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "37983f2a-555b-4705-a7de-88a8f5145ed4",
          "rotationY": 90,
          "width": 0,
          "x": 256,
          "y": 2112,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "cc3ff3ba-91eb-4e5d-b982-61d5bbedae1e",
          "rotationY": 90,
          "width": 0,
          "x": 576,
          "y": 2432,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "84e5efdd-e8b2-4eec-a5c8-53026c16cd7c",
          "rotationY": 90,
          "width": 0,
          "x": 3776,
          "y": 2432,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "2c168740-81d7-4fc4-9470-16f9c927628d",
          "rotationY": 90,
          "width": 0,
          "x": 3584,
          "y": 2432,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "f7fc9e25-e24e-4df9-8093-e808223b4b99",
          "rotationY": 90,
          "width": 0,
          "x": 3680,
          "y": 2432,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "902cf497-b394-425a-a9db-5eddefc4e98c",
          "rotationY": 90,
          "width": 0,
          "x": 4000,
          "y": 2016,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "527f0396-148d-4b9a-891b-3b030ed4c7c9",
          "rotationY": 90,
          "width": 0,
          "x": 4000,
          "y": 2208,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "c43c4f54-000b-49ee-b8e7-fd9f39a65ad6",
          "rotationY": 90,
          "width": 0,
          "x": 4000,
          "y": 2112,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "4aa5ac47-d13c-47f3-b278-987402f165b8",
          "rotationY": 90,
          "width": 0,
          "x": 4000,
          "y": 448,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "36309f76-fad5-4086-a216-142c7000932a",
          "rotationY": 90,
          "width": 0,
          "x": 4000,
          "y": 640,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "13215893-1843-4998-beab-8c9420ab191e",
          "rotationY": 90,
          "width": 0,
          "x": 4000,
          "y": 544,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "01564816-db2d-4222-9271-691a782814ab",
          "rotationY": 90,
          "width": 0,
          "x": 256,
          "y": 448,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "4112fc62-34be-4269-b843-94d7ef614ad2",
          "rotationY": 90,
          "width": 0,
          "x": 256,
          "y": 640,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "ae78128d-84ce-4d60-8baa-f0b7edac934c",
          "rotationY": 90,
          "width": 0,
          "x": 256,
          "y": 544,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "1a6de6d8-8f3a-465c-8872-69f145ddef23",
          "rotationY": 90,
          "width": 0,
          "x": 672,
          "y": 224,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "a38b1d1e-0a5b-405c-ad85-4a4610c1b2c6",
          "rotationY": 90,
          "width": 0,
          "x": 480,
          "y": 224,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "a1fea144-0d41-47fe-9522-0191b2a188a8",
          "rotationY": 90,
          "width": 0,
          "x": 576,
          "y": 224,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "81751047-2c44-4915-aa4c-a8beb7ffb039",
          "rotationY": 90,
          "width": 0,
          "x": 2272,
          "y": 116,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "f2f482fe-5abe-4bed-a2a3-3d24fe635a26",
          "rotationY": 90,
          "width": 0,
          "x": 2176,
          "y": 116,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "8c7022de-259d-408e-a83b-e2dba8f1ac18",
          "rotationY": 90,
          "width": 0,
          "x": 2080,
          "y": 116,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "d52ddf39-738d-4e60-bf80-4b43f89099e2",
          "rotationY": 90,
          "width": 0,
          "x": 1984,
          "y": 116,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "d50d718d-7834-44dd-9d09-a68d411882f3",
          "rotationY": 90,
          "width": 0,
          "x": 2272,
          "y": 2560,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "b954ca9b-4c6e-4478-9606-4e6bbad0aa1e",
          "rotationY": 90,
          "width": 0,
          "x": 2176,
          "y": 2560,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "0a095649-4dbc-4c54-a193-66cae16a1879",
          "rotationY": 90,
          "width": 0,
          "x": 2080,
          "y": 2560,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "2e4839e5-ef94-40e6-b2a6-3671ed98ac00",
          "rotationY": 90,
          "width": 0,
          "x": 1984,
          "y": 2560,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "3c41c0ed-3526-4fe0-adea-135b38a8555f",
          "rotationY": 90,
          "width": 0,
          "x": 3776,
          "y": 224,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "7a5ff952-5e59-45d4-b1be-45e53fcdf281",
          "rotationY": 90,
          "width": 0,
          "x": 3584,
          "y": 224,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Coin",
          "persistentUuid": "502f8c2f-079b-4ee3-8fc2-69e112c4ee13",
          "rotationY": 90,
          "width": 0,
          "x": 3680,
          "y": 224,
          "z": 21,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "9589bc77-0357-4388-b5ec-e1092d0557fe",
          "width": 0,
          "x": 1962,
          "y": 1473,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "0923c025-2301-44f6-9c32-91043e3cf9c5",
          "width": 256,
          "x": 3072,
          "y": 1600,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "a94497ae-b7eb-4df8-840b-0ac8382f6327",
          "width": 256,
          "x": 2176,
          "y": 1600,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "a567d019-c172-4b8f-bfed-654c28709043",
          "width": 256,
          "x": 1280,
          "y": 448,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "c1cd9bb9-62e8-4e06-8503-92aac61c7262",
          "width": 256,
          "x": 2752,
          "y": 2048,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "c3a83986-488c-4812-ae8c-5415ad20f08e",
          "width": 256,
          "x": 1984,
          "y": 1920,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "594ae657-a1bb-436f-a4df-319949c2c14a",
          "width": 256,
          "x": 448,
          "y": 896,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 270,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "f4ccec6d-6fd1-4756-b079-8950ab54891e",
          "width": 256,
          "x": 2240,
          "y": 896,
          "zOrder": 31,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 270,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "76dfc897-cfb4-491a-8327-11380541a5ce",
          "width": 256,
          "x": 2240,
          "y": 640,
          "zOrder": 32,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 270,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "8c1e8064-f239-4db0-97b0-682bea722b0d",
          "width": 256,
          "x": 3776,
          "y": 1664,
          "zOrder": 34,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 270,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "395f9f8d-19bc-4927-a103-9550563fd1c6",
          "width": 256,
          "x": 3776,
          "y": 1920,
          "zOrder": 35,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "fa97679d-81b5-4edf-91ce-a00d4bc798c2",
          "width": 0,
          "x": 2008,
          "y": 1216,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "2dd3cdfa-a9aa-4fca-969d-a9b53a744eb2",
          "width": 0,
          "x": 1145,
          "y": 317,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "c1c8cd46-9a2b-4927-858b-76316c5a95b6",
          "width": 0,
          "x": 1320,
          "y": 65,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "32547478-ebd7-4242-8afc-5c8f969bd186",
          "width": 0,
          "x": 3306,
          "y": 1466,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "5f2e97f0-7bb3-457f-925e-d2d38ba0e7ab",
          "width": 0,
          "x": 3466,
          "y": 1466,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "384c861f-fddd-4481-b559-448e68de9746",
          "width": 0,
          "x": 3720,
          "y": 1466,
          "z": 4,
          "zOrder": 38,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "478f6d08-f51b-46ce-b5ae-a9ad98378e33",
          "width": 0,
          "x": 458,
          "y": 1474,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "3fce5402-89bd-4976-a7b4-b4238e485fb3",
          "width": 0,
          "x": 618,
          "y": 1474,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "acb3437b-84fc-4e7f-8260-5e39448bef0f",
          "width": 0,
          "x": 874,
          "y": 1474,
          "z": 4,
          "zOrder": 38,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "9d4b0ad2-7092-4d04-83ee-25f42217d50b",
          "width": 0,
          "x": 522,
          "y": 318,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "778bca32-1711-492f-a3b0-a7818a0be53a",
          "width": 0,
          "x": 682,
          "y": 318,
          "z": 4,
          "zOrder": 28,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "50e40d07-e62f-4bbc-95f4-31e3a00b13a7",
          "width": 0,
          "x": 938,
          "y": 318,
          "z": 4,
          "zOrder": 38,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "db6379dd-828b-4b97-8c34-1e3aefd16053",
          "width": 0,
          "x": 2152,
          "y": 1216,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "24c0eb97-df17-4ec3-b525-6775f3e4b171",
          "width": 0,
          "x": 1368,
          "y": 2370,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "3867bff0-bc6b-4cde-bd55-aa0e1acb951f",
          "width": 0,
          "x": 1144,
          "y": 2370,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "573153a2-d34f-4f7d-a078-d591f21417dd",
          "width": 0,
          "x": 2471,
          "y": 69,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "6c3d140a-a1d9-4713-be38-d77dadcc147a",
          "width": 0,
          "x": 2631,
          "y": 69,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "2cc2aad3-8095-45bf-b31c-3ea4c53a54fe",
          "width": 0,
          "x": 3783,
          "y": 66,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "e5a60d8e-77ff-4627-af10-ad2af0055da7",
          "width": 0,
          "x": 3638,
          "y": 67,
          "z": 4,
          "zOrder": 39,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "bc21ef32-eb2c-4588-8535-9bbaf10b0fe8",
          "width": 0,
          "x": 3178,
          "y": 1219,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "634c6020-2d28-47be-b2e4-2f0acdff4326",
          "width": 0,
          "x": 3050,
          "y": 1219,
          "z": 4,
          "zOrder": 39,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "Van",
          "persistentUuid": "c2d673cd-0b27-4ab6-b26b-641469b9514b",
          "width": 0,
          "x": 3498,
          "y": 2370,
          "z": 4,
          "zOrder": 37,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "SuvLuxury",
          "persistentUuid": "f1ea9686-2334-44fb-8dc3-981db82aea0d",
          "width": 0,
          "x": 3370,
          "y": 2370,
          "z": 4,
          "zOrder": 39,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "cb18e3ac-db07-44c5-8746-0baeeadebe74",
          "width": 0,
          "x": 1920,
          "y": 2304,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "75d41047-aac4-492d-a434-7c292fdc5932",
          "width": 0,
          "x": 1920,
          "y": 0,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "6bb6f7ac-9bdb-400d-bf70-164a7fe5bfec",
          "width": 0,
          "x": 1920,
          "y": 1152,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "92323d5f-fd91-4f0c-b2ba-7bed3b8a28a9",
          "width": 384,
          "x": 0,
          "y": 384,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "9ce5b297-a47a-4ca1-978f-48440f38ed59",
          "width": 384,
          "x": 384,
          "y": 1152,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadCrossroadPath",
          "persistentUuid": "a65bdf09-c0a8-40f2-bef2-dcde130625b7",
          "width": 0,
          "x": 2304,
          "y": 1152,
          "zOrder": 43,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadCrossroadPath",
          "persistentUuid": "efa57fb9-dd0b-431b-ba97-e56bd554f4cb",
          "width": 0,
          "x": 1536,
          "y": 1152,
          "zOrder": 43,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadIntersectionPath",
          "persistentUuid": "eb323bf0-2c9f-470d-8f30-7b79ca5b1c15",
          "width": 0,
          "x": 2304,
          "y": 2304,
          "zOrder": 44,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadIntersectionPath",
          "persistentUuid": "8a20020b-9ddf-4dd6-8eed-7203403731d5",
          "width": 0,
          "x": 1536,
          "y": 2304,
          "zOrder": 44,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadIntersectionPath",
          "persistentUuid": "92e15216-85fa-4eeb-bb9a-04d8f369f724",
          "width": 0,
          "x": 1536,
          "y": 0,
          "zOrder": 44,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadIntersectionPath",
          "persistentUuid": "c4452ded-2d3e-4846-aae6-f81cf1539dd1",
          "width": 0,
          "x": 2304,
          "y": 0,
          "zOrder": 44,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadIntersectionPath",
          "persistentUuid": "a5d5abcc-c6db-41b5-9eed-36f231b1422f",
          "width": 0,
          "x": 0,
          "y": 1152,
          "zOrder": 44,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": -90,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadIntersectionPath",
          "persistentUuid": "e8b0b84a-62f4-453c-beca-103132724997",
          "width": 0,
          "x": 3840,
          "y": 1152,
          "zOrder": 44,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadBend",
          "persistentUuid": "e22cf8f0-a157-4ec5-9e42-663c7f0af27b",
          "width": 0,
          "x": 0,
          "y": 2304,
          "zOrder": 45,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadBend",
          "persistentUuid": "97f7e8a7-7047-4992-bcc9-dbf5214b5414",
          "width": 0,
          "x": 0,
          "y": 0,
          "zOrder": 45,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 180,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadBend",
          "persistentUuid": "7b9c3f8f-bc84-4467-8d28-9453b49ca4c8",
          "width": 0,
          "x": 3840,
          "y": 0,
          "zOrder": 45,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": -90,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "RoadBend",
          "persistentUuid": "4776e313-1e93-4503-93d4-44d6489b243f",
          "width": 0,
          "x": 3840,
          "y": 2304,
          "zOrder": 45,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 315,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "CommonTree1",
          "persistentUuid": "52d896d4-1113-4367-94bf-9398965ca670",
          "width": 0,
          "x": 716,
          "y": 1698,
          "zOrder": 46,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 61,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "CommonTree1",
          "persistentUuid": "10990ae3-86ae-4dc3-af87-9f72cfbed80e",
          "width": 0,
          "x": 1306,
          "y": 1982,
          "zOrder": 46,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 274,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "CommonTree1",
          "persistentUuid": "79f0c61e-6546-421b-bdb9-fef257734726",
          "width": 0,
          "x": 769,
          "y": 2136,
          "zOrder": 46,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 57,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "CommonTree1",
          "persistentUuid": "85b17f12-f2b5-45c8-b365-ddfbbef7f2a0",
          "width": 0,
          "x": 3622,
          "y": 878,
          "zOrder": 46,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 299,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "CommonTree1",
          "persistentUuid": "e45f54e4-ed85-40d5-98eb-a3d7c77285d3",
          "width": 0,
          "x": 2958,
          "y": 888,
          "zOrder": 46,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 348,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "CommonTree1",
          "persistentUuid": "da1362be-1156-4cd4-af4b-891bb73a43fa",
          "width": 0,
          "x": 3196,
          "y": 573,
          "zOrder": 46,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 1,
          "height": 5888,
          "layer": "",
          "locked": true,
          "name": "Grass",
          "persistentUuid": "05276cd6-3502-4c9d-a19e-58308fbbb417",
          "sealed": true,
          "width": 7936,
          "x": -1920,
          "y": -1664,
          "z": -30,
          "zOrder": 47,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "485188d4-0bbd-454c-8c4b-9fd5bf0d5f45",
          "width": 384,
          "x": 768,
          "y": 1152,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "1ee347bf-3015-4f58-876c-d04d39ad28b5",
          "width": 384,
          "x": 1152,
          "y": 1152,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "a89019e6-91e2-478f-9599-5f4f0573ba9b",
          "width": 384,
          "x": 384,
          "y": 2304,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "4a87a06e-0e25-4dd0-998e-8f9d06d5b095",
          "width": 384,
          "x": 768,
          "y": 2304,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "5c88e60f-5797-4f27-b9e3-e87254df2481",
          "width": 384,
          "x": 1152,
          "y": 2304,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "c665fbeb-cf78-41b2-834c-5aea2132e67b",
          "width": 384,
          "x": 2688,
          "y": 2304,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "4bda5be6-6c5d-49ee-b13d-f37cd0d0290e",
          "width": 384,
          "x": 3072,
          "y": 2304,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "f40d8647-9d44-4a25-ab80-1798356bbbe7",
          "width": 384,
          "x": 3456,
          "y": 2304,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "16c2ae9d-3592-4805-9378-c39418cd412b",
          "width": 384,
          "x": 2688,
          "y": 1152,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "934e1926-cb34-432b-8e48-9a7052d2aa4d",
          "width": 384,
          "x": 3072,
          "y": 1152,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "5917738e-3f9e-4195-a0f6-826a9c9301ab",
          "width": 384,
          "x": 3456,
          "y": 1152,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "fe9e6d21-57fb-4e83-aec5-3f71a5581849",
          "width": 384,
          "x": 2688,
          "y": 0,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "0cfd277c-6655-4272-ae61-9dad944c0b9f",
          "width": 384,
          "x": 3072,
          "y": 0,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "cbd8cba4-80bf-4542-9a86-80644afd72eb",
          "width": 384,
          "x": 3456,
          "y": 0,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "9c17fccc-2bf0-4792-b6c5-27282819919c",
          "width": 384,
          "x": 384,
          "y": 0,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "c62c7d21-da9e-48d8-9554-3e6df00f64bd",
          "width": 384,
          "x": 768,
          "y": 0,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "6becb840-c118-4f06-9669-c5aaa5ab7e67",
          "width": 384,
          "x": 1152,
          "y": 0,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "36b75552-b744-4617-a8ef-1b961bc6fecf",
          "width": 384,
          "x": 0,
          "y": 768,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "0266b3b7-6ff5-4317-a50c-1905e0e5ef54",
          "width": 384,
          "x": 0,
          "y": 1536,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "a0a8e165-63e0-4a13-8de7-21a014d7664f",
          "width": 384,
          "x": 0,
          "y": 1920,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "be909e4c-1aff-4e93-90b9-d9a540c67a07",
          "width": 384,
          "x": 1536,
          "y": 384,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "c79daf4b-eb1a-4bad-90b5-7f3135dd0dc4",
          "width": 384,
          "x": 1536,
          "y": 768,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "2622a119-b5c8-4df7-acd2-d6cdc9b47767",
          "width": 384,
          "x": 2304,
          "y": 384,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "f93b22ef-0525-499a-b25d-40f2751c58ff",
          "width": 384,
          "x": 2304,
          "y": 768,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "c079341b-e9c6-46cc-8ea0-5d5767a66b77",
          "width": 384,
          "x": 3840,
          "y": 384,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "cd9f55ea-d28b-42d0-9051-00cc864edb69",
          "width": 384,
          "x": 3840,
          "y": 768,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "e9076c06-5b2f-4ca9-84b0-90d2c2d63472",
          "width": 384,
          "x": 3840,
          "y": 1536,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "36fd0435-9198-40e8-a5e4-15522cd72b03",
          "width": 384,
          "x": 3840,
          "y": 1920,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "7682f683-7323-4759-aed6-eed7e5db7466",
          "width": 384,
          "x": 2304,
          "y": 1536,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "5cde2482-d098-47d3-8ddd-ac224bab10bb",
          "width": 384,
          "x": 2304,
          "y": 1920,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "68ec3e88-518e-4c6a-a025-caac6f2bde28",
          "width": 384,
          "x": 1536,
          "y": 1536,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 8,
          "height": 384,
          "layer": "",
          "name": "RoadStraight",
          "persistentUuid": "55601cf4-3e07-4e09-b779-69dce4326b53",
          "width": 384,
          "x": 1536,
          "y": 1920,
          "zOrder": 42,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "241bf02a-d61e-408a-b763-017445343c9c",
          "width": 256,
          "x": 3776,
          "y": 2176,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 180.14706219218877,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingF",
          "persistentUuid": "2277534d-2e0a-4d47-8b03-ecb0fad2836d",
          "width": 256,
          "x": 1984,
          "y": 2176,
          "zOrder": 30,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "e80422b5-a9b3-4bca-b8a6-bb26aee89e2a",
          "width": 256,
          "x": 1472,
          "y": 1024,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 90,
          "customSize": true,
          "depth": 201.7647033558585,
          "height": 128,
          "layer": "",
          "name": "LargeBuildingA",
          "persistentUuid": "c9b2d6eb-523e-4f9a-b639-f862bf17cdd9",
          "width": 256,
          "x": 1984,
          "y": 1024,
          "zOrder": 25,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        }
      ],
      "editionSettings": {
        "grid": true,
        "gridType": "rectangular",
        "gridWidth": 128,
        "gridHeight": 128,
        "gridOffsetX": 0,
        "gridOffsetY": 0,
        "gridColor": 10401023,
        "gridAlpha": 0.8,
        "snap": true,
        "zoomFactor": 0.15508574551593238,
        "windowMask": false
      }
    }
  ],
  "externalSourceFiles": []
}